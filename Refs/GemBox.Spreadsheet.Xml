<?xml version="1.0"?>
<doc>
    <assembly>
        <name>GemBox.Spreadsheet</name>
    </assembly>
    <members>
        <member name="T:GemBox.Spreadsheet.ZlibConstants">
            <summary>
            A bunch of constants used in the Zlib interface.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ZlibConstants.Z_NO_FLUSH">
            <summary>
            No flush at all.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ZlibConstants.Z_PARTIAL_FLUSH">
            <summary>
            A little bit of flush?
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ZlibConstants.Z_SYNC_FLUSH">
            <summary>
            Sync flush?
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ZlibConstants.Z_FULL_FLUSH">
            <summary>
            Full flush?
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ZlibConstants.Z_FINISH">
            <summary>
            Finish?
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ZlibConstants.WINDOW_BITS_MAX">
            <summary>
            The maximum number of window bits for the Deflate algorithm.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ZlibConstants.WINDOW_BITS_DEFAULT">
            <summary>
            The default number of window bits for the Deflate algorithm.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ZlibConstants.Z_OK">
            <summary>
            indicates everything is A-OK
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ZlibConstants.Z_STREAM_END">
            <summary>
            Indicates that the last operation reached the end of the stream.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ZlibConstants.Z_NEED_DICT">
            <summary>
            The operation ended in need of a dictionary. 
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ZlibConstants.Z_STREAM_ERROR">
            <summary>
            There was an error with the stream - not enough data, not open and readable, etc.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ZlibConstants.Z_DATA_ERROR">
            <summary>
            There was an error with the data - not enough data, bad data, etc.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ZlibConstants.Z_BUF_ERROR">
            <summary>
            There was an error with the working buffer.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.EncryptionAlgorithm">
            <summary>
            An enum that provides the various encryption algorithms supported by this library.
            </summary>
            <remarks>
            <para>
            PkzipWeak implies the use of Zip 2.0 encryption, which is known to be weak and subvertible. 
            </para>
            <para>
            A note on interoperability: Values of PkzipWeak and None are specified in the PKWare AppNote.txt document, are 
            considered to be "standard".  Zip archives produced using these options will be interoperable with many other
            zip tools and libraries, including Windows Explorer.
            </para>
            <para>
            Values of WinZipAes128 and WinZipAes256 are not part of the Zip specification, but rather imply the use of a 
            vendor-specific extension from WinZip. If you want to produce interoperable Zip archives, do not use these values. 
            For example, if you
            produce a zip archive using WinZipAes256, you will be able to open it in Windows Explorer on Windows XP and Vista, 
            but you will not be able to extract entries; trying this will lead to an "unspecified error". For this reason, 
            some people have said that a zip archive that uses WinZip's AES encryption is not actually a zip archive at all.
            A zip archive produced this way will be readable with the WinZip tool
            (Version 11 and beyond).
            </para>
            <para>
            There are other third-party tools and libraries, both commercial and otherwise, that support WinZip's 
            AES encryption. These will be able to read AES-encrypted zip archives produced by DotNetZip, and conversely applications 
            that use DotNetZip to read zip archives will be able to read AES-encrypted archives produced by those tools
            or libraries.  Consult the documentation for those other tools and libraries to find out if WinZip's AES 
            encryption is supported. 
            </para>
            <para>
            In case you care: According to the WinZip specification, the actual key used is derived from the 
            <see cref="P:GemBox.Spreadsheet.ZipEntry.Password"/> via an algorithm that complies with RFC 2898, using an iteration count of 1000.
            I am no security expert, but I think you should use a long-ish password if you employ 256-bit AES
            encryption.  Make it 16 characters or more.  
            </para>
            <para>
            The WinZip AES algorithms are not supported with the version of DotNetZip that runs on the .NET Compact Framework. 
            This is because .NET CF lacks the HMACSHA1 class that is required for producing the archive.
            </para>
            </remarks>
        </member>
        <member name="F:GemBox.Spreadsheet.EncryptionAlgorithm.None">
            <summary>
            No encryption at all.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.EncryptionAlgorithm.PkzipWeak">
            <summary>
            Traditional or Classic pkzip encryption.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.EncryptionAlgorithm.WinZipAes128">
            <summary>
            WinZip AES encryption (128 key bits).
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.EncryptionAlgorithm.WinZipAes256">
            <summary>
            WinZip AES encryption (256 key bits).
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.EntrySource">
            <summary>
            An enum that specifies the source of the ZipEntry. 
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.EntrySource.None">
            <summary>
            Default value.  Invalid on a bonafide ZipEntry.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.EntrySource.Filesystem">
            <summary>
            Entry was instantiated by Adding an entry from the filesystem.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.EntrySource.Zipfile">
            <summary>
            Entry was instantiated by reading a zipfile.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.EntrySource.Stream">
            <summary>
            Entry was instantiated via a stream or string.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.ZipEntry">
            <summary>
            Represents a single entry in a ZipFile. Typically, applications
            get a ZipEntry by enumerating the entries within a ZipFile,
            or by adding an entry to a ZipFile.  
            </summary>
            <summary>
            This class models an entry in the directory contained within the zip file.
            The class is generally not used from within application code, though it is
            used by the ZipFile class.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.ZipEntry.Read(GemBox.Spreadsheet.ZipFile,System.Boolean)">
            <summary>
            Reads one ZipEntry from the given stream.  If the entry is encrypted, we don't
            decrypt at this point.  We also do not decompress.  Mostly we read metadata.
            </summary>
            <param name="zf">the zipfile this entry belongs to.</param>
            <param name="first">true of this is the first entry being read from the stream.</param>
            <returns>the ZipEntry read from the stream.</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.ZipEntry.Extract(System.IO.Stream)">
            <summary>
            Extracts the entry to the specified stream. 
            </summary>
            
            <remarks>
            
            <para>
            For example, the caller could specify Console.Out, or a MemoryStream.
            </para>
            
            </remarks>
            
            <param name="stream">the stream to which the entry should be extracted.  </param>
            
        </member>
        <member name="M:GemBox.Spreadsheet.ZipEntry.ReadDirEntry(System.IO.Stream,System.Text.Encoding)">
            <summary>
            Reads one entry from the zip directory structure in the zip file. 
            </summary>
            <param name="s">the stream from which to read.</param>
            <param name="expectedEncoding">
            The text encoding to use if the entry is not marked UTF-8.
            </param>
            <returns>the entry read from the archive.</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.ZipEntry.IsNotValidZipDirEntrySig(System.Int32)">
            <summary>
            Returns true if the passed-in value is a valid signature for a ZipDirEntry. 
            </summary>
            <param name="signature">the candidate 4-byte signature value.</param>
            <returns>true, if the signature is valid according to the PKWare spec.</returns>
        </member>
        <member name="P:GemBox.Spreadsheet.ZipEntry.LastModified">
             <summary>
             The time and date at which the file indicated by the ZipEntry was last modified. 
             </summary>
             
             <remarks>
             <para>
             The DotNetZip library sets the LastModified value for an entry, equal to the 
             Last Modified time of the file in the filesystem.  If an entry is added from a stream, 
             in which case no Last Modified attribute is available, the library uses 
             <c>System.DateTime.Now</c> for this value, for the given entry. 
             </para>
            
             <para>
             It is also possible to set the LastModified value on an entry, to an arbitrary
             value.  Be aware that because of the way the PKZip specification describes how
             times are stored in the zip file, the full precision of the
             <c>System.DateTime</c> datatype is not stored in LastModified when saving zip
             files.  For more information on how times are formatted, see the PKZip
             specification.
             </para>
            
             <para>
             The last modified time of the file created upon a call to <c>ZipEntry.Extract()</c> 
             may be adjusted during extraction to compensate
             for differences in how the .NET Base Class Library deals
             with daylight saving time (DST) versus how the Windows
             filesystem deals with daylight saving time. 
             See http://blogs.msdn.com/oldnewthing/archive/2003/10/24/55413.aspx for more context.
             </para>
             <para>
             In a nutshell: Daylight savings time rules change regularly.  In
             2007, for example, the inception week of DST changed.  In 1977,
             DST was in place all year round. In 1945, likewise.  And so on.
             Win32 does not attempt to guess which time zone rules were in
             effect at the time in question.  It will render a time as
             "standard time" and allow the app to change to DST as necessary.
              .NET makes a different choice.
             </para>
             <para>
             Compare the output of FileInfo.LastWriteTime.ToString("f") with
             what you see in the Windows Explorer property sheet for a file that was last
             written to on the other side of the DST transition. For example,
             suppose the file was last modified on October 17, 2003, during DST but
             DST is not currently in effect. Explorer's file properties
             reports Thursday, October 17, 2003, 8:45:38 AM, but .NETs
             FileInfo reports Thursday, October 17, 2003, 9:45 AM.
             </para>
             <para>
             Win32 says, "Thursday, October 17, 2002 8:45:38 AM PST". Note:
             Pacific STANDARD Time. Even though October 17 of that year
             occurred during Pacific Daylight Time, Win32 displays the time as
             standard time because that's what time it is NOW.
             </para>
             <para>
             .NET BCL assumes that the current DST rules were in place at the
             time in question.  So, .NET says, "Well, if the rules in effect
             now were also in effect on October 17, 2003, then that would be
             daylight time" so it displays "Thursday, October 17, 2003, 9:45
             AM PDT" - daylight time.
             </para>
             <para>
             So .NET gives a value which is more intuitively correct, but is
             also potentially incorrect, and which is not invertible. Win32
             gives a value which is intuitively incorrect, but is strictly
             correct.
             </para>
             <para>
             Because of this funkiness, this library adds one hour to the LastModified time
             on the extracted file, if necessary.  That is to say, if the time in question
             had occurred in what the .NET Base Class Library assumed to be DST (an
             assumption that may be wrong given the constantly changing DST rules).
             </para>
             </remarks>
            
        </member>
        <member name="P:GemBox.Spreadsheet.ZipEntry.ForceNoCompression">
             <summary>
             When this is set, the entry is not compressed when written to 
             the archive.  For example, the application might want to set flag to <c>true</c>
             this when zipping up JPG or MP3 files, which are already compressed.
             </summary>
             <seealso cref="P:GemBox.Spreadsheet.ZipFile.ForceNoCompression"/>
            
        </member>
        <member name="P:GemBox.Spreadsheet.ZipEntry.LocalFileName">
            <summary>
            The name of the filesystem file, referred to by the ZipEntry. 
            </summary>
            
            <remarks>
            <para>
            This may be different than the path used in the archive itself. What I mean is, 
            if you call <c>Zip.AddFile("fooo.txt", AlternativeDirectory)</c>, then the 
            path used for the ZipEntry within the zip archive will be different than this path.  
            This path is used to locate the thing-to-be-zipped on disk. 
            </para>
            <para>
            If the entry is being added from a stream, then this is null (Nothing in VB).
            </para>
            
            </remarks>
            <seealso cref="P:GemBox.Spreadsheet.ZipEntry.FileName"/>
        </member>
        <member name="P:GemBox.Spreadsheet.ZipEntry.FileName">
             <summary>
             The name of the file contained in the ZipEntry. 
             </summary>
             
             <remarks>
             <para>
             When writing a zip, this path has backslashes replaced with 
             forward slashes, according to the zip spec, for compatibility
             with Unix(tm) and ... get this.... Amiga!
             </para>
            
             <para>
             This is the name of the entry in the ZipFile itself.  This name may be different
             than the name of the filesystem file used to create the entry (LocalFileName). In fact, there
             may be no filesystem file at all, if the entry is created from a stream or a string.
             </para>
            
             <para>
             When setting this property, the value is made permanent only after a call to one of the ZipFile.Save() methods 
             on the ZipFile that contains the ZipEntry. By reading in a ZipFile, then explicitly setting the FileName on an
             entry contained within the ZipFile, and then calling Save(), you will effectively rename the entry within 
             the zip archive.
             </para>
             </remarks>
             <seealso cref="P:GemBox.Spreadsheet.ZipEntry.LocalFileName"/>
        </member>
        <member name="P:GemBox.Spreadsheet.ZipEntry.Comment">
             <summary>
             The comment attached to the ZipEntry. 
             </summary>
            
             <remarks>
             By default, the Comment is encoded in IBM437 code page. You can specify 
             an alternative with <see cref="P:GemBox.Spreadsheet.ZipEntry.ProvisionalAlternateEncoding"/>
             </remarks>
             <seealso cref="P:GemBox.Spreadsheet.ZipEntry.ProvisionalAlternateEncoding">ProvisionalAlternateEncoding</seealso>
        </member>
        <member name="P:GemBox.Spreadsheet.ZipEntry.OutputUsedZip64">
            <summary>
            Indicates whether the entry actually used ZIP64 extensions, as it was most recently written 
            to the output file or stream.
            </summary>
            <remarks>
            <para>
            This Nullable property is null (Nothing in VB) until a Save() method on the containing 
            <see cref="T:GemBox.Spreadsheet.ZipFile"/> instance has been called. HasValue is true only after a Save() method
            has been called. 
            </para>
            <para>
            The value of this property for a particular ZipEntry may change over successive calls to
            Save() methods on the containing ZipFile, even if the file that corresponds to the ZipEntry does
            not. This may happen if other entries contained in the ZipFile expand, causing the offset 
            for this particular entry to exceed 0xFFFFFFFF. 
            </para>
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ZipEntry.CompressionMethod">
            <summary>
            The compression method employed for this ZipEntry. 
            </summary>
            
            <remarks>
            <para>
            The ZIP specification allows a variety of compression methods.  This library 
            supports just two:  0x08 = Deflate.  0x00 = Store (no compression).  
            </para>
            
            <para>
            When reading an entry from an existing zipfile, the value you retrieve here
            indicates the compression method used on the entry by the original creator of the zip.  
            When writing a zipfile, you can specify either 0x08 (Deflate) or 0x00 (None).  If you 
            try setting something else, you will get an exception.  
            </para>
            
            <para>
            You may wish to set CompressionMethod to 0 (None) when zipping previously compressed
            data like a jpg, png, or mp3 file.  This can save time and cpu cycles.
            Setting CompressionMethod to 0 is equivalent to setting ForceNoCompression to true. 
            </para>
            
            <para>
            When updating a ZipFile, you may not modify the CompressionMethod on an entry that has been encrypted. 
            In other words, if you read an existing ZipFile with one of the ZipFile.Read() methods, and then 
            change the CompressionMethod on an entry that has Encryption not equal to None, you will receive an exception. 
            There is no way to modify the compression on an encrypted entry, without extracting it and re-adding it 
            into the ZipFile.  
            </para>
            </remarks>
            
            <example>
            In this example, the first entry added to the zip archive uses 
            the default behavior - compression is used where it makes sense.  
            The second entry, the MP3 file, is added to the archive without being compressed.
            <code>
            using (ZipFile zip = new ZipFile(ZipFileToCreate))
            {
              ZipEntry e1= zip.AddFile(@"c:\temp\Readme.txt");
              ZipEntry e2= zip.AddFile(@"c:\temp\StopThisTrain.mp3");
              e2.CompressionMethod = 0;
              zip.Save();
            }
            </code>
            
            <code lang="VB">
            Using zip as new ZipFile(ZipFileToCreate)
              zip.AddFile("c:\temp\Readme.txt")
              Dim e2 as ZipEntry = zip.AddFile("c:\temp\StopThisTrain.mp3")
              e2.CompressionMethod = 0
              zip.Save
            End Using
            </code>
            </example>
        </member>
        <member name="P:GemBox.Spreadsheet.ZipEntry.CompressedSize">
            <summary>
            The compressed size of the file, in bytes, within the zip archive. 
            </summary>
            <remarks>
            The compressed size is computed during compression. This means that it is only
            valid to read this AFTER reading in an existing zip file, or AFTER saving a
            zipfile you are creating.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ZipEntry.UncompressedSize">
            <summary>
            The size of the file, in bytes, before compression, or after extraction. 
            </summary>
            <remarks>
            This property is valid AFTER reading in an existing zip file, or AFTER saving the 
            ZipFile that contains the ZipEntry.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ZipEntry.IsDirectory">
            <summary>
            True if the entry is a directory (not a file). 
            This is a readonly property on the entry.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.ZipEntry.UsesEncryption">
            <summary>
            A derived property that is <c>true</c> if the entry uses encryption.  
            </summary>
            <remarks>
            This is a readonly property on the entry.
            Upon reading an entry, this bool is determined by
            the data read.  When writing an entry, this bool is
            determined by whether the Encryption property is set to something other than
            EncryptionAlgorithm.None. 
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ZipEntry.Encryption">
             <summary>
             Set this to specify which encryption algorithm to use for the entry.
             </summary>
             
             <remarks>
             <para>
             When setting this property, you must also set a Password on the entry.  The set of
             algorithms supported is determined by the authors of this library.  The PKZIP
             specification from PKWare defines a set of encryption algorithms, and the data formats
             for the zip archive that support them. Other vendors of tools and libraries, such as
             WinZip or Xceed, also specify and support different encryption algorithms and data
             formats.
             </para>
            
             <para>
             There is no common, ubiquitous multi-vendor standard for strong encryption. There is
             broad support for "traditional" Zip encryption, sometimes called Zip 2.0 encryption,
             as specified by PKWare, but this encryption is considered weak. This library currently
             supports AES 128 and 256 in addition to the Zip 2.0 "weak" encryption.
             </para>
            
             <para>
             The WinZip AES encryption algorithms are not supported on the .NET Compact Framework. 
             </para>
             </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ZipEntry.Password">
             <summary>
             The Password to be used when encrypting a ZipEntry upon ZipFile.Save(), or 
             when decrypting an entry upon Extract().
             </summary>
            
             <remarks>
             <para>
             This is a write-only property on the entry. 
             Set this to request that the entry be encrypted when writing the zip
             archive, or set it to specify the password to be used when extracting an 
             existing entry that is encrypted.   
             </para>
            
             <para>
             Some comments on Updating archives: Suppose you read a zipfile, and there is an
             encrypted entry.  Setting the password on that entry and then saving the zipfile
             does not update the password on that entry in the archive.  Instead, what happens
             is the existing entry is copied through to the new zip archive, in its original
             encrypted form.  Upon re-reading that archive, the entry can be decrypted with its
             original password. 
             </para>
            
             <para>
             If you read a zipfile, and there is an un-encrypted entry, you can set the password
             on the entry and then call Save() on the ZipFile, and get encryption on that entry. 
             </para>
            
             </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ZipEntry.OverwriteOnExtract">
            <summary>
            Specifies that the extraction should overwrite any existing files.
            </summary>
            <remarks>
            This applies only when calling an Extract method. By default this 
            property is false. Generally you will get overwrite behavior by calling 
            one of the overloads of the Extract() method that accepts a boolean flag
            to indicate explicitly whether you want overwrite.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ZipEntry.WillReadTwiceOnInflation">
             <summary>
             A callback that allows the application to specify whether multiple reads of the
             stream should be performed, in the case that a compression operation actually
             inflates the size of the file data.  
             </summary>
            
             <remarks>
             <para>
             In some cases, applying the Deflate compression algorithm in DeflateStream can
             result an increase in the size of the data.  This "inflation" can happen with
             previously compressed files, such as a zip, jpg, png, mp3, and so on.  In a few
             tests, inflation on zip files can be as large as 60%!  Inflation can also happen
             with very small files.  In these cases, by default, the DotNetZip library
             discards the compressed bytes, and stores the uncompressed file data into the
             zip archive.  This is an optimization where smaller size is preferred over
             longer run times.
             </para>
            
             <para>
             The application can specify that compression is not even tried, by setting the
             ForceNoCompression flag.  In this case, the compress-and-check-sizes process as
             decribed above, is not done.
             </para>
            
             <para>
             In some cases, neither choice is optimal.  The application wants compression,
             but in some cases also wants to avoid reading the stream more than once.  This
             may happen when the stream is very large, or when the read is very expensive, or
             when the difference between the compressed and uncompressed sizes is not
             significant.
             </para>
            
             <para>
             To satisfy these applications, this delegate allows the DotNetZip library to ask
             the application to for approval for re-reading the stream.  As with other
             properties (like Password and ForceNoCompression), setting the corresponding
             delegate on the ZipFile class itself will set it on all ZipEntry items that are
             subsequently added to the ZipFile instance.
             </para>
            
             </remarks>
             <seealso cref="P:GemBox.Spreadsheet.ZipFile.WillReadTwiceOnInflation"/>
             <seealso cref="T:GemBox.Spreadsheet.ReReadApprovalCallback"/>
        </member>
        <member name="P:GemBox.Spreadsheet.ZipEntry.WantCompression">
             <summary>
             A callback that allows the application to specify whether compression should
             be used for a given entry that is about to be added to the zip archive.
             </summary>
            
             <remarks>
             See <see cref="P:GemBox.Spreadsheet.ZipFile.WantCompression"/>
             </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ZipEntry.ProvisionalAlternateEncoding">
             <summary>
             The text encoding to use for this ZipEntry, when the default
             encoding is insufficient.
             </summary>
            
             <remarks>
             <para>
             According to the zip specification from PKWare, filenames and comments for a
             ZipEntry are encoded either with IBM437 or with UTF8.  But, some archivers do not
             follow the specification, and instead encode characters using the system default
             code page, or an arbitrary code page.  For example, WinRAR when run on a machine in
             Shanghai may encode filenames with the Chinese (Big-5) code page.  This behavior is
             contrary to the Zip specification, but it occurs anyway.  This property exists to
             support that non-compliant behavior when reading or writing zip files.
             </para>
             <para>
             When writing zip archives that will be read by one of these other archivers, use this property to 
             specify the code page to use when encoding filenames and comments into the zip
             file, when the IBM437 code page will not suffice.
             </para>
             <para>
             Be aware that a zip file created after you've explicitly specified the code page will not 
             be compliant to the PKWare specification, and may not be readable by compliant archivers. 
             On the other hand, many archivers are non-compliant and can read zip files created in 
             arbitrary code pages. 
             </para>
             <para>
             When using an arbitrary, non-UTF8 code page for encoding, there is no standard way for the 
             creator (DotNetZip) to specify in the zip file which code page has been used. DotNetZip is not
             able to inspect the zip file and determine the codepage used for the entries within it. Therefore, 
             you, the application author, must determine that.  If you use a codepage which results in filenames
             that are not legal in Windows, you will get exceptions upon extract. Caveat Emptor.
             </para>
             </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ZipEntry.ActualEncoding">
            <summary>
            The text encoding actually used for this ZipEntry.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.ZipEntry.AttributesIndicateDirectory">
            <summary>
            True if the referenced entry is a directory.  
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.MsoBaseRecord.ConvertToBytes(GemBox.Spreadsheet.MsoDelayedRecords)">
            <summary>
            Converts mso structure' representation to bytes.
            </summary>		
        </member>
        <member name="M:GemBox.Spreadsheet.MsoBaseRecord.Read(System.IO.BinaryReader)">
            <summary>
            Reads data from the specified reader.
            </summary>
            <param name="reader">The source binary reader.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.MsoBaseRecord.SetData(GemBox.Spreadsheet.MsoDelayedRecords)">
            <summary>
            Sets the inner data( mso structure' data without header: atom, type, length ).
            </summary>		
        </member>
        <member name="P:GemBox.Spreadsheet.MsoBaseRecord.Version">
            <summary>
            Get or sets the version if the record is an atom. 
            If the record is a container, this field has a value of 0xFFFF.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.MsoBaseRecord.Instance">
            <summary>
            Gets or setes the instance. Depending on the instance a record's contents 
            it can have different meanings.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.MsofbtSpRecord.Read(System.IO.BinaryReader)">
            <summary>
            Reads data from the specified reader.
            </summary>
            <param name="reader">The source binary reader.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.MsofbtSpRecord.SetData(GemBox.Spreadsheet.MsoDelayedRecords)">
            <summary>
            Sets the inner data( mso structure' data without header: atom, type, length ).
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.RefErr3dFormulaToken">
            <summary>
            Formula token for holding 3d reference error on internal cell range.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.RefFormulaToken">
            <summary>
            Formula token for holding reference.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.FormulaToken">
            <summary>
            Base formula token class for inheritance
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.FormulaToken.#ctor(GemBox.Spreadsheet.FormulaTokenCode,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:GemBox.Spreadsheet.FormulaToken"/> class.
            </summary>
            <param name="code">The code.</param>
            <param name="size">The size.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.FormulaToken.DelayInitialize(System.Object[])">
            <summary>
            Make custom delay initialize.
            </summary>
            <param name="data">The data for initialization which is unique for each formula token.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.FormulaToken.Read(System.Byte[],System.Int32)">
            <summary>
            Initialize formula token by reading input data from array of bytes
            </summary>
            <param name="rpnBytes">input data, array of bytes</param>
            <param name="startIndex">start position for array of bytes to read from</param>
        </member>
        <member name="M:GemBox.Spreadsheet.FormulaToken.ConvertToBytes">
            <summary>
            Convert formula token to bytes representation.
            </summary>
            <returns>bytes representation of the formula token</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.FormulaToken.ToString">
            <summary>
            Convert formula token to string representation.
            </summary>
            <returns>formula token string representation</returns>
        </member>
        <member name="P:GemBox.Spreadsheet.FormulaToken.Token">
            <summary>
            Gets the formula token code.
            </summary>
            <value>The formula token code.</value>
        </member>
        <member name="P:GemBox.Spreadsheet.FormulaToken.Size">
            <summary>
            Gets the size of the formula token.
            </summary>
            <value>The size of the formula token.</value>
        </member>
        <member name="F:GemBox.Spreadsheet.RefFormulaToken.ColumnBitMask">
            <summary>
            Bit mask for column options.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.RefFormulaToken.RowBitMask">
            <summary>
            Bit mask for row options.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.RefFormulaToken.regexOptions">
            <summary>
            Regular expression default options
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.RefFormulaToken.IsColumnRegex">
            <summary>
            Regular expression used to determinate whether the input string is column or not
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.RefFormulaToken.IsCellRegex">
            <summary>
            Regular expression used to determinate whether the input string is cell or not
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.RefFormulaToken.AbsoluteCellMark">
            <summary>
            Absolute preffix row\height symbol
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.RefFormulaToken.#ctor(GemBox.Spreadsheet.FormulaTokenCode)">
            <summary>
            Initializes a new instance of the <see cref="T:GemBox.Spreadsheet.RefFormulaToken"/> class.
            </summary>
            <param name="code">The code.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.RefFormulaToken.DelayInitialize(System.Object[])">
            <summary>
            Make custom delay initialize.
            </summary>
            <param name="data">The data for initialization which is unique for each formula token.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.RefFormulaToken.Read(System.Byte[],System.Int32)">
            <summary>
            Initialize formula token by reading input data from array of bytes
            </summary>
            <param name="rpnBytes">input data, array of bytes</param>
            <param name="startIndex">start position for array of bytes to read from</param>
        </member>
        <member name="M:GemBox.Spreadsheet.RefFormulaToken.ConvertToBytes">
            <summary>
            Convert formula token to array of byte representation.
            </summary>
            <returns>formula token' array of byte representation</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.RefFormulaToken.ToString">
            <summary>
            Convert formula token to string representation.
            </summary>
            <returns>formula token string representation</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.RefErr3dFormulaToken.ToString">
            <summary>
            Convert formula token to string representation.
            </summary>
            <returns>formula token string representation</returns>
        </member>
        <member name="T:GemBox.Spreadsheet.FormulaFunctionInfo">
            <summary>
            Hold information about function( name, code, expected arguments count. )
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.FormulaFunctionInfo.VariableArgumentAmountMark">
            <summary>
            Is used to the specify for appropriate functins the variable count of arguments
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.FormulaFunctionInfo.argumentsCount">
            <summary>
            Arguments count value, by default it is initilized with not fixed( variable ) argument count mark.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.FormulaFunctionInfo.#ctor(System.UInt16,System.String,GemBox.Spreadsheet.FormulaTokenCode,GemBox.Spreadsheet.FormulaTokenClass)">
            <summary>
            Initializes a new instance of the <see cref="T:GemBox.Spreadsheet.FormulaFunctionInfo"/> class.
            </summary>
            <param name="code">The function code.</param>
            <param name="name">The function name.</param>
            <param name="argumentCode">The argument code.</param>
            <param name="returnCode">The return code.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.FormulaFunctionInfo.#ctor(System.UInt16,System.String,GemBox.Spreadsheet.FormulaTokenCode,GemBox.Spreadsheet.FormulaTokenClass,System.Byte)">
            <summary>
            Initializes a new instance of the <see cref="T:GemBox.Spreadsheet.FormulaFunctionInfo"/> class.
            </summary>
            <param name="code">The function code.</param>
            <param name="name">The function name.</param>
            <param name="argumentCode">The argument code.</param>
            <param name="returnCode">The return code.</param>
            <param name="argumentsCount">The function's arguments count.</param>
        </member>
        <member name="P:GemBox.Spreadsheet.FormulaFunctionInfo.ReturnCode">
            <summary>
            Gets the return code.
            </summary>
            <value>The return code.</value>
        </member>
        <member name="P:GemBox.Spreadsheet.FormulaFunctionInfo.Code">
            <summary>
            Gets function code.
            </summary>
            <value>The function code.</value>
        </member>
        <member name="P:GemBox.Spreadsheet.FormulaFunctionInfo.ArgumentsCount">
            <summary>
            Arguments count value, by default it is initilized with not fixed( variable ) argument count mark.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.FormulaFunctionInfo.Name">
            <summary>
            Gets function name.
            </summary>
            <value>Function name.</value>
        </member>
        <member name="P:GemBox.Spreadsheet.FormulaFunctionInfo.IsFixedArgumentCount">
            <summary>
            Gets a value indicating whether function has fixed argument count.
            </summary>
            <value>
            	<c>true</c> if this function has fixed argument count; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="T:GemBox.Spreadsheet.HtmlExportPosition">
            <summary>
            Data that describes the current position in the exporter methods.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.HtmlExportPosition.#ctor(GemBox.Spreadsheet.CellRange,GemBox.Spreadsheet.ExcelRow,GemBox.Spreadsheet.ExcelColumn,System.Int32,System.Int32)">
            <summary>
            Creates new HTML export position.
            </summary>
            <param name="range">Cell range.</param>
            <param name="sheetRow">Current sheet row.</param>
            <param name="sheetColumn">Current sheet column.</param>
            <param name="htmlRowIndex">Current HTML row index.</param>
            <param name="htmlColumnIndex">Current HTML column index.</param>
        </member>
        <member name="P:GemBox.Spreadsheet.HtmlExportPosition.Range">
            <summary>
            Gets the cell range that is exporting to HTML.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.HtmlExportPosition.SheetRow">
            <summary>
            Gets the current sheet row.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.HtmlExportPosition.SheetColumn">
            <summary>
            Gets the current sheet column.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.HtmlExportPosition.HtmlRowIndex">
            <summary>
            Gets row index for the current row in HTML table.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.HtmlExportPosition.HtmlColumnIndex">
            <summary>
            Gets column index for the current column in HTML table.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.HtmlExporterOptions">
            <summary>
            Options and methods that define HTML export behavior.
            </summary>
            <remarks>Other than just properties, exporting process can be handled by user defined methods 
            that can replace any of the default ones. 
            User defined methods are simply passed as delegates.</remarks>
            <example>
Following code demonstrates how to use HtmlExporter. It shows next features:
<list type="number">
  <item> Export excel table (only used range) as HTML table node </item>
  <item> Override DefaultRowToHtml method </item>
</list>
  To export used range of the active worksheet to HTML file use <see cref="M:GemBox.Spreadsheet.ExcelFile.SaveHtml(System.String,GemBox.Spreadsheet.HtmlExporterOptions,System.Boolean)">ExcelFile.SaveHtml</see> method.
<code lang="vbnet">
  ' Method that returns xml node from excel file.
  Private Shared Function GetTableNodeFromExcelFile(ByVal fileName As String) As XmlNode
    Dim ef As New ExcelFile
    Dim options As New HtmlExporterOptions

    ef.LoadXlsx(fileName, XlsxOptions.None)

    ' By default grid lines are showed.
    options.ShowGridLines = False

    ' Overrides default MethodRowToHtml by assigning CustomRowToHtml to it.
    ' Default MethodRowToHtml is DefaultHtmlExporter.DefaultRowToHtml.
    ' Any method in exporting process can be overridden this way.
    options.MethodRowToHtml = New RowToHtmlDelegate(AddressOf Program.CustomRowToHtml)

    ' Range that is exporting is set to used range of the first worksheet.
    Dim range As CellRange = ef.Worksheets.Item(0).GetUsedCellRange

    Return DefaultHtmlExporter.DefaultTableToHtml(options, range)
  End Function

  ' Method that exports every row as default one, but for pair rows sets font style to bold.
  Private Shared Function CustomRowToHtml(ByVal options As HtmlExporterOptions, ByVal row As ExcelRow, ByVal range As CellRange, ByVal htmlRowIndex As Integer) As XmlNode
    ' Default method can be called from anywhere, including methods that are overriding default ones.
    Dim rowNode As XmlNode = DefaultHtmlExporter.DefaultRowToHtml(options, row, range, htmlRowIndex)

    If ((htmlRowIndex Mod 2) = 0) Then
      Dim styleAttribute As XmlAttribute = rowNode.Attributes.ItemOf("style")

      ' If style attribute don't exist, new style attribute is created.
      If (styleAttribute Is Nothing) Then
        styleAttribute = options.ExportingXmlDocument.CreateAttribute("style")
        rowNode.Attributes.Append(styleAttribute)
      End If
  
      ' Sets font-weight to bold.
      styleAttribute.Value = (styleAttribute.Value &amp; "font-weight:700;")
    End If
  
    Return rowNode
  End Function
</code>
<code lang="C#">
  // Method that returns xml node from excel file.
  private static XmlNode GetTableNodeFromExcelFile(string fileName)
  {
    ExcelFile ef = new ExcelFile();
    HtmlExporterOptions options = new HtmlExporterOptions();

    ef.LoadXlsx(fileName, XlsxOptions.None);

    // By default grid lines are showed.
    options.ShowGridLines = false;

    // Overrides default MethodRowToHtml by assigning CustomRowToHtml to it.
    // Default MethodRowToHtml is DefaultHtmlExporter.DefaultRowToHtml.
    // Any method in exporting process can be overridden this way.
    options.MethodRowToHtml = CustomRowToHtml;

    // Range that is exporting is set to used range of the first worksheet.
    CellRange range = ef.Worksheets[0].GetUsedCellRange();

    return DefaultHtmlExporter.DefaultTableToHtml(options, range);
  }

  // Method that exports every row as default one, but for pair rows sets font style to bold.
  private static XmlNode CustomRowToHtml(HtmlExporterOptions options, ExcelRow row, CellRange range, int htmlRowIndex)
  {
    // Default method can be called from anywhere, including methods that are overriding default ones.
    XmlNode rowNode = DefaultHtmlExporter.DefaultRowToHtml(options, row, range, htmlRowIndex);

    if (htmlRowIndex % 2 == 0)
    {
      XmlAttribute styleAttribute = rowNode.Attributes["style"];

      // If style attribute don't exist, new style attribute is created.
      if (styleAttribute == null)
      {
        styleAttribute = options.ExportingXmlDocument.CreateAttribute("style");
        rowNode.Attributes.Append(styleAttribute);
      }

      // Sets font-weight to bold.
      styleAttribute.Value += "font-weight:700;";
    }

    return rowNode;
  }
</code>
</example>
        </member>
        <member name="M:GemBox.Spreadsheet.HtmlExporterOptions.#ctor">
            <overloads>Creates new HTML exporter options.</overloads>
            <summary>
            Creates new HTML exporter options.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.HtmlExporterOptions.#ctor(System.Xml.XmlDocument)">
            <summary>
            Creates new HTML exporter options with defined xml document.
            </summary>
            <param name="exportingXmlDocument">Xml document used to create xml nodes.</param>
        </member>
        <member name="P:GemBox.Spreadsheet.HtmlExporterOptions.ExportPictures">
            <summary>
            Gets or sets a value indicating whether <see cref="T:GemBox.Spreadsheet.ExcelPicture"/>s will be exported.
            Only JPEG, GIF and PNG pictures that are contained in exporting <see cref="T:GemBox.Spreadsheet.CellRange"/> are exported.
            </summary>
            <value>
            <c>true</c> if <see cref="T:GemBox.Spreadsheet.ExcelPicture"/>s will be exported; otherwise, <c>false</c>.
            </value>
            <remarks>
            If <see cref="T:GemBox.Spreadsheet.ExcelFile"/> is exported to HTML, only pictures in used cell range will be exported. 
            If used cell range doesn't contain a picture, extend used cell range by setting <see cref="P:GemBox.Spreadsheet.ExcelCell.Value"/> to <c>null</c> of a cell containing the bottom-right corner of the picture.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.HtmlExporterOptions.PicturesDirectoryImgSrcPath">
            <summary>
            Gets or sets the pictures directory that will be used when referencing images in the HTML and Javascript. This value is used only if <see cref="P:GemBox.Spreadsheet.HtmlExporterOptions.ExportPictures"/> is <c>true</c>.
            </summary>
            <value>
            The pictures directory that will be used when referencing images in the HTML and Javascript.
            </value>
            <remarks>
            If value is <c>null</c> or empty string and HTML export is called with filePath parameter overload, 
            value will be automatically set to htmlFileNameWithoutExtension + "-Images". 
            This directory will be created in the same location as HTML file.        
            </remarks>
            <example>
    Following code demonstrates how to export Excel file to HTML with specifying location where images will be saved.
    <code lang="vbnet">
      ef.SaveHtml(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.Desktop), "Data.html"),
      New HtmlExporterOptions() With { _
        .ExportPictures = True, _
        .PicturesDirectoryPath = Path.Combine(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.Desktop), "Art"), "Images"), _
        .PicturesDirectoryImgSrcPath = "Art/Images" _
      }, True)
    </code>
    <code lang="C#">
      ef.SaveHtml(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.Desktop), "Data.html"),
      new HtmlExporterOptions()
      {
        ExportPictures = true,
        PicturesDirectoryPath = Path.Combine(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.Desktop), "Art"), "Images"),
        PicturesDirectoryImgSrcPath = "Art/Images"
      }, true);
    </code>
  </example>
        </member>
        <member name="P:GemBox.Spreadsheet.HtmlExporterOptions.PicturesDirectoryPath">
            <summary>
            Gets or sets the directory where <see cref="T:GemBox.Spreadsheet.ExcelPicture"/>s will be physically saved. This value is used only if <see cref="P:GemBox.Spreadsheet.HtmlExporterOptions.ExportPictures"/> is <c>true</c>.
            </summary>
            <value>
            The directory where <see cref="T:GemBox.Spreadsheet.ExcelPicture"/>s will be physically saved.
            </value>
            <remarks>
            If value is <c>null</c> or empty string and HTML export is called with filePath parameter overload, 
            value will be automatically set to htmlFileNameWithoutExtension + "-Images".
            This directory will be created in the same location as HTML file.
            </remarks>
            <example>
    Following code demonstrates how to export Excel file to HTML with specifying location where images will be saved.
    <code lang="vbnet">
      ef.SaveHtml(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.Desktop), "Data.html"),
      New HtmlExporterOptions() With { _
        .ExportPictures = True, _
        .PicturesDirectoryPath = Path.Combine(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.Desktop), "Art"), "Images"), _
        .PicturesDirectoryImgSrcPath = "Art/Images" _
      }, True)
    </code>
    <code lang="C#">
      ef.SaveHtml(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.Desktop), "Data.html"),
      new HtmlExporterOptions()
      {
        ExportPictures = true,
        PicturesDirectoryPath = Path.Combine(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.Desktop), "Art"), "Images"),
        PicturesDirectoryImgSrcPath = "Art/Images"
      }, true);
    </code>
  </example>
        </member>
        <member name="P:GemBox.Spreadsheet.HtmlExporterOptions.ExportingXmlDocument">
            <summary>
            Gets XmlDocument that is used to create new nodes.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.HtmlExporterOptions.ShowGridLines">
            <summary>
            If true, grid lines will be exported.
            </summary>
            <remarks>Default value is true.</remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.HtmlExporterOptions.CalculateTableWidth">
            <summary>
            Gets or sets the option to calculate table width.
            </summary>
            <remarks>Default value is false.</remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.HtmlExporterOptions.ExportHiddenRows">
            <summary>
            If true, hidden rows will be exported.
            </summary>
            <remarks>Default value is false.</remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.HtmlExporterOptions.ExportHiddenColumns">
            <summary>
            If true, hidden columns will be exported.
            </summary>
            <remarks>Default value is false.</remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.HtmlExporterOptions.ShowRowNumbers">
            <summary>
            Gets or sets the option to show row numbers in the first column.
            </summary>
            <remarks>Default value is false.</remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.HtmlExporterOptions.ShowColumnLetters">
            <summary>
            Gets or sets the option to show column letters in the first row.
            </summary>
            <remarks>Default value is false.</remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.HtmlExporterOptions.MethodCellValueToHtml">
            <summary>
            Gets or sets a method that exports cell value to HTML string.
            </summary>
            <remarks>Default method is <see cref="M:GemBox.Spreadsheet.DefaultHtmlExporter.DefaultCellValueToHtml(GemBox.Spreadsheet.ExcelCell,GemBox.Spreadsheet.HtmlExportPosition)">DefaultHtmlExporter.DefaultCellValueToHtml</see>.</remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.HtmlExporterOptions.MethodCellStyleToHtml">
            <summary>
            Gets or sets a method that exports cell style to HTML string.
            </summary>
            <remarks>Default method is <see cref="M:GemBox.Spreadsheet.DefaultHtmlExporter.DefaultCellStyleToHtml(GemBox.Spreadsheet.ExcelCell,GemBox.Spreadsheet.HtmlExportPosition)">DefaultHtmlExporter.DefaultCellStyleToHtml</see>.</remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.HtmlExporterOptions.MethodCellToHtml">
            <summary>
            Gets or sets a method that exports cell to xml node.
            </summary>
            <remarks>Default method is <see cref="M:GemBox.Spreadsheet.DefaultHtmlExporter.DefaultCellToHtml(GemBox.Spreadsheet.HtmlExporterOptions,GemBox.Spreadsheet.ExcelCell,GemBox.Spreadsheet.HtmlExportPosition)">DefaultHtmlExporter.DefaultCellToHtml</see>.</remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.HtmlExporterOptions.MethodRowNumberToHtml">
            <summary>
            Gets or sets a method that creates xml node with row number cell.
            </summary>
            <remarks>Default method is <see cref="M:GemBox.Spreadsheet.DefaultHtmlExporter.DefaultRowNumberToHtml(GemBox.Spreadsheet.HtmlExporterOptions,GemBox.Spreadsheet.ExcelRow,GemBox.Spreadsheet.CellRange,System.Int32)">DefaultHtmlExporter.DefaultRowNumberToHtml</see>.</remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.HtmlExporterOptions.MethodRowToHtml">
            <summary>
            Gets or sets a method that creates xml node for specified excel row.
            </summary>
            <remarks>Default method is <see cref="M:GemBox.Spreadsheet.DefaultHtmlExporter.DefaultRowToHtml(GemBox.Spreadsheet.HtmlExporterOptions,GemBox.Spreadsheet.ExcelRow,GemBox.Spreadsheet.CellRange,System.Int32)">DefaultHtmlExporter.DefaultRowToHtml</see>.</remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.HtmlExporterOptions.MethodColumnLetterToHtml">
            <summary>
            Gets or sets a method that creates xml node with column letter cell.
            </summary>
            <remarks>Default method is <see cref="M:GemBox.Spreadsheet.DefaultHtmlExporter.DefaultColumnLetterToHtml(GemBox.Spreadsheet.HtmlExporterOptions,GemBox.Spreadsheet.ExcelColumn,System.Int32)">DefaultHtmlExporter.DefaultColumnLetterToHtml</see>.</remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.HtmlExporterOptions.MethodColumnLettersToHtml">
            <summary>
            Gets or sets a method that creates xml node for row with column letters.
            </summary>
            <remarks>Default method is <see cref="M:GemBox.Spreadsheet.DefaultHtmlExporter.DefaultColumnLettersToHtml(GemBox.Spreadsheet.HtmlExporterOptions,GemBox.Spreadsheet.ExcelColumn,GemBox.Spreadsheet.ExcelColumn)">DefaultHtmlExporter.DefaultColumnLettersToHtml</see>.</remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.HtmlExporterOptions.MethodTableToHtml">
            <summary>
            Gets or sets a method that creates xml node for HTML table from specified cell range.
            </summary>
            <remarks>Default method is <see cref="M:GemBox.Spreadsheet.DefaultHtmlExporter.DefaultTableToHtml(GemBox.Spreadsheet.HtmlExporterOptions,GemBox.Spreadsheet.CellRange)">DefaultHtmlExporter.DefaultTableToHtml</see>.</remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.HtmlExporterOptions.MethodPageToHtml">
            <summary>
            Gets or sets a method that creates xml node for HTML page from specified cell range.
            </summary>
            <remarks>Default method is <see cref="M:GemBox.Spreadsheet.DefaultHtmlExporter.DefaultPageToHtml(GemBox.Spreadsheet.HtmlExporterOptions,GemBox.Spreadsheet.CellRange)">DefaultHtmlExporter.DefaultPageToHtml</see>.</remarks>
        </member>
        <member name="T:GemBox.Spreadsheet.HtmlExporterOptions.CellValueToHtmlDelegate">
            <summary>
            Delegate for handling export of cell value to string.
            </summary>
            <param name="cell">Excel cell.</param>
            <param name="position">Current position of the exporting process. It can be null.</param>
        </member>
        <member name="T:GemBox.Spreadsheet.HtmlExporterOptions.CellStyleToHtmlDelegate">
            <summary>
            Delegate for handling export of cell style to string.
            </summary>
            <param name="cell">Excel cell.</param>
            <param name="position">Current position of the exporting process. It can be null.</param>
        </member>
        <member name="T:GemBox.Spreadsheet.HtmlExporterOptions.CellToHtmlDelegate">
            <summary>
            Delegate for handling cell export.
            </summary>
            <param name="options">Options that describe exporting process.</param>
            <param name="cell">Excel cell.</param>
            <param name="position">Current position of the exporting process. It can be null.</param>
        </member>
        <member name="T:GemBox.Spreadsheet.HtmlExporterOptions.RowNumberToHtmlDelegate">
            <summary>
            Delegate for handling export of cell that represent row number.
            </summary>
            <param name="options">Options that describe exporting process.</param>
            <param name="row">Current excel row.</param>
            <param name="range">Cell range that is been exported.</param>
            <param name="htmlRowIndex">Row index in HTML table.</param>
        </member>
        <member name="T:GemBox.Spreadsheet.HtmlExporterOptions.RowToHtmlDelegate">
            <summary>
            Delegate for handling export of specified excel row.
            </summary>
            <param name="options">Options that describe exporting process.</param>
            <param name="row">Current excel row.</param>
            <param name="range">Cell range that is been exported.</param>
            <param name="htmlRowIndex">Row index in HTML table</param>
        </member>
        <member name="T:GemBox.Spreadsheet.HtmlExporterOptions.ColumnLetterToHtmlDelegate">
            <summary>
            Delegate for handling export of cell that represent column letter.
            </summary>
            <param name="options">Options that describe exporting process.</param>
            <param name="column">Current excel column.</param>
            <param name="htmlColumnIndex">Column index in HTML table.</param>
        </member>
        <member name="T:GemBox.Spreadsheet.HtmlExporterOptions.ColumnLettersToHtmlDelegate">
            <summary>
            Delegate for handling export of header row.
            </summary>
            <param name="options">Options that describe exporting process.</param>
            <param name="startColumn">Start excel column.</param>
            <param name="endColumn">End excel column.</param>
        </member>
        <member name="T:GemBox.Spreadsheet.HtmlExporterOptions.TableToHtmlDelegate">
            <summary>
            Delegate for handling export of table for specified range.
            </summary>
            <param name="options">Options that describe exporting process.</param>
            <param name="range">Range that is exporting.</param>
        </member>
        <member name="T:GemBox.Spreadsheet.HtmlExporterOptions.PageToHtmlDelegate">
            <summary>
            Delegate for handling export of the whole HTML page.
            </summary>
            <param name="options">Options that describe exporting process.</param>
            <param name="range">Range that is exporting.</param>
        </member>
        <member name="T:GemBox.Spreadsheet.DefaultHtmlExporter">
            <summary>
            Default methods for exporting to HTML.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.DefaultHtmlExporter.DefaultCellValueToHtml(GemBox.Spreadsheet.ExcelCell,GemBox.Spreadsheet.HtmlExportPosition)">
            <summary>
            Returns a string that will be writen as cell value.
            </summary>
            <remarks>If cell value is null, empty string is returned.</remarks>
            <param name="cell">Excel cell.</param>
            <param name="position">Current position of the exporting process. It can be null.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.DefaultHtmlExporter.DefaultCellStyleToHtml(GemBox.Spreadsheet.ExcelCell,GemBox.Spreadsheet.HtmlExportPosition)">
            <summary>
            If cell style is not the same as the default one, the default style is overrided with style string.
            </summary>
            <param name="cell">Excel cell.</param>
            <param name="position">Current position of the exporting process. It can be null.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.DefaultHtmlExporter.DefaultCellToHtml(GemBox.Spreadsheet.HtmlExporterOptions,GemBox.Spreadsheet.ExcelCell,GemBox.Spreadsheet.HtmlExportPosition)">
            <summary>
            Returns XmlNode with single cell entry.
            </summary>
            <remarks>If the cell is in merge region but not first in exporting region, null is returned.</remarks>
            <param name="options">Options that describe exporting process.</param>
            <param name="cell">Excel cell.</param>
            <param name="position">Current position of the exporting process. It can be null.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.DefaultHtmlExporter.DefaultRowNumberToHtml(GemBox.Spreadsheet.HtmlExporterOptions,GemBox.Spreadsheet.ExcelRow,GemBox.Spreadsheet.CellRange,System.Int32)">
            <summary>
            Returns XmlNode with cell entry for cell that represent row number.
            </summary>
            <param name="options">Options that describe exporting process.</param>
            <param name="row">Current excel row.</param>
            <param name="range">Cell range that is been exported.</param>
            <param name="htmlRowIndex">Row index in HTML table.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.DefaultHtmlExporter.DefaultRowToHtml(GemBox.Spreadsheet.HtmlExporterOptions,GemBox.Spreadsheet.ExcelRow,GemBox.Spreadsheet.CellRange,System.Int32)">
            <summary>
            Returns XmlNode with row entry for specified excel row.
            </summary>
            <param name="options">Options that describe exporting process.</param>
            <param name="row">Current excel row.</param>
            <param name="range">Cell range that is been exported.</param>
            <param name="htmlRowIndex">Row index in HTML table</param>
        </member>
        <member name="M:GemBox.Spreadsheet.DefaultHtmlExporter.DefaultColumnLetterToHtml(GemBox.Spreadsheet.HtmlExporterOptions,GemBox.Spreadsheet.ExcelColumn,System.Int32)">
            <summary>
            Returns XmlNode with cell entry for cell that represent column letter.
            </summary>
            <param name="options">Options that describe exporting process.</param>
            <param name="column">Current excel column.</param>
            <param name="htmlColumnIndex">Column index in HTML table.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.DefaultHtmlExporter.DefaultColumnLettersToHtml(GemBox.Spreadsheet.HtmlExporterOptions,GemBox.Spreadsheet.ExcelColumn,GemBox.Spreadsheet.ExcelColumn)">
            <summary>
            Returns XmlNode with row entry for header row.
            </summary>
            <param name="options">Options that describe exporting process.</param>
            <param name="startColumn">Start excel column.</param>
            <param name="endColumn">End excel column.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.DefaultHtmlExporter.DefaultTableToHtml(GemBox.Spreadsheet.HtmlExporterOptions,GemBox.Spreadsheet.CellRange)">
            <summary>
            Returns XmlNode with table entry for specified range.
            </summary>
            <param name="options">Options that describe exporting process.</param>
            <param name="range">Range that is exporting.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.DefaultHtmlExporter.DefaultPageToHtml(GemBox.Spreadsheet.HtmlExporterOptions,GemBox.Spreadsheet.CellRange)">
            <summary>
            Returns XmlDocument with page and table entry for specified range.
            </summary>
            <remarks>XmlDocument that is returned by this method is the same XmlDocument that is defined in the 
            <see cref="T:GemBox.Spreadsheet.HtmlExporterOptions">HtmlExporterOptions</see>.</remarks>
            <param name="options">Options that describe exporting process.</param>
            <param name="range">Range that is exporting.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.MsofbtClientDataRecord.Read(System.IO.BinaryReader)">
            <summary>
            Reads data from the specified reader.
            </summary>
            <param name="reader">The source binary reader.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.MsofbtClientDataRecord.ConvertToBytes(GemBox.Spreadsheet.MsoDelayedRecords)">
            <summary>
            Converts mso structure' representation to bytes.
            </summary>		
        </member>
        <member name="M:GemBox.Spreadsheet.MsofbtClientDataRecord.SetData(GemBox.Spreadsheet.MsoDelayedRecords)">
            <summary>
            Sets the inner data( mso structure' data without header: atom, type, length ).
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.RefErrFormulaToken">
            <summary>
            Formula token for holding reference error.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.RefErrFormulaToken.#ctor(GemBox.Spreadsheet.FormulaTokenCode)">
            <summary>
            Initializes a new instance of the <see cref="T:GemBox.Spreadsheet.RefErrFormulaToken"/> class.
            </summary>
            <param name="code">The code.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.RefErrFormulaToken.ToString">
            <summary>
            Convert formula token to string representation.
            </summary>
            <returns>formula token string representation</returns>
        </member>
        <member name="T:GemBox.Spreadsheet.Ref3dFormulaToken">
            <summary>
            Formula token for holding 3d reference on internal cell.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.Ref3dFormulaToken.regexOptions">
            <summary>
            Regular expression default options
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.Ref3dFormulaToken.IsCell3DRegex">
            <summary>
            Regular expression used to determinate whether the input string is 3d cell or not
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.Ref3dFormulaToken.refIndex">
            <summary>
            REF entry' index on EXTERNSHEET record( see the Link Table ).
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.Ref3dFormulaToken.#ctor(GemBox.Spreadsheet.ExcelWorksheet,GemBox.Spreadsheet.FormulaTokenCode)">
            <summary>
            Initializes a new instance of the <see cref="T:GemBox.Spreadsheet.Ref3dFormulaToken"/> class.
            </summary>
            <param name="sheet"></param>
            <param name="code">The code.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.Ref3dFormulaToken.IsRef3dToken(System.Byte)">
            <summary>
            Determines whether is the specified code related to ref3d token.
            </summary>
            <param name="code">The code to be checked.</param>
            <returns>
            	<c>true</c> if the specified code related to ref3d token; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:GemBox.Spreadsheet.Ref3dFormulaToken.DelayInitialize(System.Object[])">
            <summary>
            Make custom delay initialize.
            </summary>
            <param name="data">The data for initialization which is unique for each formula token.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.Ref3dFormulaToken.Read(System.Byte[],System.Int32)">
            <summary>
            Initialize formula token by reading input data from array of bytes
            </summary>
            <param name="rpnBytes">input data, array of bytes</param>
            <param name="startIndex">start position for array of bytes to read from</param>
        </member>
        <member name="M:GemBox.Spreadsheet.Ref3dFormulaToken.ConvertToBytes">
            <summary>
            Convert formula token to array of byte representation.
            </summary>
            <returns>formula token' array of byte representation</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.Ref3dFormulaToken.ToString">
            <summary>
            Convert formula token to string representation.
            </summary>
            <returns>formula token string representation</returns>
        </member>
        <member name="T:GemBox.Spreadsheet.MissArgFormulaToken">
            <summary>
            Formula token for holding missed argument( argument with no value ) in argument list of function.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.MissArgFormulaToken.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:GemBox.Spreadsheet.MissArgFormulaToken"/> class.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.MissArgFormulaToken.ToString">
            <summary>
            Convert formula token to string representation.
            </summary>
            <returns>formula token string representation</returns>
        </member>
        <member name="T:GemBox.Spreadsheet.FormulaFunctionsTable">
            <summary>
            Hold information about all supported functions.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.FormulaFunctionsTable.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:GemBox.Spreadsheet.FormulaFunctionsTable"/> class.
            Constructor is private to allow only creation of FormulaFunctionsTable instances only once.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.FormulaFunctionsTable.IsFunction(System.String)">
            <summary>
            Determines whether the specified name is function.
            </summary>
            <param name="name">The name.</param>
            <returns>
            	<c>true</c> if the specified name is function; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="P:GemBox.Spreadsheet.FormulaFunctionsTable.Instance">
            <summary>
            Gets the static FormulaFunctionsTable instance. Used to be shared between FormulaFunctionsTable' users.
            </summary>
            <value>The singleton FormulaFunctionTable instance.</value>
        </member>
        <member name="P:GemBox.Spreadsheet.FormulaFunctionsTable.Item(System.UInt16)">
            <summary>
            Gets the <see cref="T:GemBox.Spreadsheet.FormulaFunctionInfo"/> at the specified index.
            </summary>
            <value><see cref="T:GemBox.Spreadsheet.FormulaFunctionInfo"/> instance</value>
        </member>
        <member name="P:GemBox.Spreadsheet.FormulaFunctionsTable.Item(System.String)">
            <summary>
            Gets the <see cref="T:GemBox.Spreadsheet.FormulaFunctionInfo"/> at the specified index.
            </summary>
            <value><see cref="T:GemBox.Spreadsheet.FormulaFunctionInfo"/> instance</value>
        </member>
        <member name="T:GemBox.Spreadsheet.CellStyle">
            <summary>
            Contains settings specifying how the cell data will be displayed.
            </summary>
            <remarks>
            Various settings control various display aspects: alignment, patterns and shading, indentation, 
            rotation, cell protection, text wrapping, number format, font related settings and cell borders. You can 
            set cell style of a specific Excel through its <b>Style</b> property, or you can create new cell style 
            with desired properties and apply it to unlimited number of Excel objects. Note, however, that number of 
            distinct cell styles in Excel file can't exceed <see cref="F:GemBox.Spreadsheet.ExcelFile.MaxXlsCellStyles">
            ExcelFile.MaxCellStyles</see>. You don't have to worry about creating duplicate cell styles; internal 
            caching engine will eliminate duplicates in appropriate moments.
            </remarks>
            <example> Following code demonstrates various cell style properties:
<code lang="vbnet">
    Sub StylesSample(ByVal ws As ExcelWorksheet)
        ws.Cells(0, 0).Value = "Cell style examples:"

        Dim row As Integer = 0

        <font color="Green">' Column width of 4, 30 and 35 characters.</font>
        ws.Columns(0).Width = 4 * 256
        ws.Columns(1).Width = 30 * 256
        ws.Columns(2).Width = 35 * 256

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Borders.SetBorders(...)"
        ws.Cells(row, 2).Style.Borders.SetBorders(MultipleBorders.All, Color.FromArgb(252, 1, 1), LineStyle.Thin)

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.FillPattern.SetPattern(...)"
        ws.Cells(row, 2).Style.FillPattern.SetPattern(FillPatternStyle.ThinHorizontalCrosshatch, Color.Green, Color.Yellow)

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Color ="
        ws.Cells(row, 2).Value = "Color.Blue"
        ws.Cells(row, 2).Style.Font.Color = Color.Blue

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Italic ="
        ws.Cells(row, 2).Value = "true"
        ws.Cells(row, 2).Style.Font.Italic = True

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Name ="
        ws.Cells(row, 2).Value = "Comic Sans MS"
        ws.Cells(row, 2).Style.Font.Name = "Comic Sans MS"

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.ScriptPosition ="
        ws.Cells(row, 2).Value = "ScriptPosition.Superscript"
        ws.Cells(row, 2).Style.Font.ScriptPosition = ScriptPosition.Superscript

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Size ="
        ws.Cells(row, 2).Value = "18 * 20"
        ws.Cells(row, 2).Style.Font.Size = 18 * 20

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Strikeout ="
        ws.Cells(row, 2).Value = "true"
        ws.Cells(row, 2).Style.Font.Strikeout = True

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.UnderlineStyle ="
        ws.Cells(row, 2).Value = "UnderlineStyle.Double"
        ws.Cells(row, 2).Style.Font.UnderlineStyle = UnderlineStyle.Double

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Weight ="
        ws.Cells(row, 2).Value = "ExcelFont.BoldWeight"
        ws.Cells(row, 2).Style.Font.Weight = ExcelFont.BoldWeight

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.HorizontalAlignment ="
        ws.Cells(row, 2).Value = "HorizontalAlignmentStyle.Center"
        ws.Cells(row, 2).Style.HorizontalAlignment = HorizontalAlignmentStyle.Center

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Indent"
        ws.Cells(row, 2).Value = "five"
        ws.Cells(row, 2).Style.HorizontalAlignment = HorizontalAlignmentStyle.Left
        ws.Cells(row, 2).Style.Indent = 5

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.IsTextVertical = "
        ws.Cells(row, 2).Value = "true"
        <font color="Green">' Set row height to 50 points.</font>
        ws.Rows(row).Height = 50 * 20
        ws.Cells(row, 2).Style.IsTextVertical = True

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.NumberFormat"
        ws.Cells(row, 2).Value = 1234
        ws.Cells(row, 2).Style.NumberFormat = "#.##0,00 [$Krakozhian Money Units]"

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Rotation"
        ws.Cells(row, 2).Value = "35 degrees up"
        ws.Cells(row, 2).Style.Rotation = 35

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.ShrinkToFit"
        ws.Cells(row, 2).Value = "This property is set to true so this text appears shrunk."
        ws.Cells(row, 2).Style.ShrinkToFit = True

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.VerticalAlignment ="
        ws.Cells(row, 2).Value = "VerticalAlignmentStyle.Top"
        <font color="Green">' Set row height to 30 points.</font>
        ws.Rows(row).Height = 30 * 20
        ws.Cells(row, 2).Style.VerticalAlignment = VerticalAlignmentStyle.Top

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.WrapText"
        ws.Cells(row, 2).Value = "This property is set to true so this text appears broken into multiple lines."
        ws.Cells(row, 2).Style.WrapText = True
    End Sub
</code>
<code lang="C#">
	static void StylesSample(ExcelWorksheet ws)
	{
		ws.Cells[0,0].Value = "Cell style examples:";

		int row = 0;

		// Column width of 4, 30 and 35 characters.
		ws.Columns[0].Width = 4 * 256;
		ws.Columns[1].Width = 30 * 256;
		ws.Columns[2].Width = 35 * 256;

		ws.Cells[row+=2,1].Value = ".Style.Borders.SetBorders(...)";
		ws.Cells[row,2].Style.Borders.SetBorders(MultipleBorders.All, Color.FromArgb(252, 1, 1), LineStyle.Thin);

		ws.Cells[row+=2,1].Value = ".Style.FillPattern.SetPattern(...)";
		ws.Cells[row,2].Style.FillPattern.SetPattern(FillPatternStyle.ThinHorizontalCrosshatch, Color.Green, Color.Yellow);

		ws.Cells[row+=2,1].Value = ".Style.Font.Color =";
		ws.Cells[row,2].Value = "Color.Blue";
		ws.Cells[row,2].Style.Font.Color = Color.Blue;

		ws.Cells[row+=2,1].Value = ".Style.Font.Italic =";
		ws.Cells[row,2].Value = "true";
		ws.Cells[row,2].Style.Font.Italic = true;

		ws.Cells[row+=2,1].Value = ".Style.Font.Name =";
		ws.Cells[row,2].Value = "Comic Sans MS";
		ws.Cells[row,2].Style.Font.Name = "Comic Sans MS";

		ws.Cells[row+=2,1].Value = ".Style.Font.ScriptPosition =";
		ws.Cells[row,2].Value = "ScriptPosition.Superscript";
		ws.Cells[row,2].Style.Font.ScriptPosition = ScriptPosition.Superscript;

		ws.Cells[row+=2,1].Value = ".Style.Font.Size =";
		ws.Cells[row,2].Value = "18 * 20";
		ws.Cells[row,2].Style.Font.Size = 18 * 20;

		ws.Cells[row+=2,1].Value = ".Style.Font.Strikeout =";
		ws.Cells[row,2].Value = "true";
		ws.Cells[row,2].Style.Font.Strikeout = true;

		ws.Cells[row+=2,1].Value = ".Style.Font.UnderlineStyle =";
		ws.Cells[row,2].Value = "UnderlineStyle.Double";
		ws.Cells[row,2].Style.Font.UnderlineStyle = UnderlineStyle.Double;

		ws.Cells[row+=2,1].Value = ".Style.Font.Weight =";
		ws.Cells[row,2].Value = "ExcelFont.BoldWeight";
		ws.Cells[row,2].Style.Font.Weight = ExcelFont.BoldWeight;

		ws.Cells[row+=2,1].Value = ".Style.HorizontalAlignment =";
		ws.Cells[row,2].Value = "HorizontalAlignmentStyle.Center";
		ws.Cells[row,2].Style.HorizontalAlignment = HorizontalAlignmentStyle.Center;

		ws.Cells[row+=2,1].Value = ".Style.Indent";
		ws.Cells[row,2].Value = "five";
		ws.Cells[row,2].Style.HorizontalAlignment = HorizontalAlignmentStyle.Left;
		ws.Cells[row,2].Style.Indent = 5;

		ws.Cells[row+=2,1].Value = ".Style.IsTextVertical = ";
		ws.Cells[row,2].Value = "true";
		// Set row height to 50 points.
		ws.Rows[row].Height = 50 * 20;
		ws.Cells[row,2].Style.IsTextVertical = true;

		ws.Cells[row+=2,1].Value = ".Style.NumberFormat";
		ws.Cells[row,2].Value = 1234;
		ws.Cells[row,2].Style.NumberFormat = "#.##0,00 [$Krakozhian Money Units]";

		ws.Cells[row+=2,1].Value = ".Style.Rotation";
		ws.Cells[row,2].Value = "35 degrees up";
		ws.Cells[row,2].Style.Rotation = 35;

		ws.Cells[row+=2,1].Value = ".Style.ShrinkToFit";
		ws.Cells[row,2].Value = "This property is set to true so this text appears shrunk.";
		ws.Cells[row,2].Style.ShrinkToFit = true;

		ws.Cells[row+=2,1].Value = ".Style.VerticalAlignment =";
		ws.Cells[row,2].Value = "VerticalAlignmentStyle.Top";
		// Set row height to 30 points.
		ws.Rows[row].Height = 30 * 20;
		ws.Cells[row,2].Style.VerticalAlignment = VerticalAlignmentStyle.Top;

		ws.Cells[row+=2,1].Value = ".Style.WrapText";
		ws.Cells[row,2].Value = "This property is set to true so this text appears broken into multiple lines.";
		ws.Cells[row,2].Style.WrapText = true;
	}
</code> 
</example>
        </member>
        <member name="M:GemBox.Spreadsheet.CellStyle.#ctor">
            <summary>
            Creates new cell style with default values (Arial font with size 200).
            </summary>
            <remarks>
            Creating standalone cell style has sense only if you assign it to some Excel objects
            by setting <b>Style</b> property. Otherwise, the created cell style will have no effect on the Excel file.
            </remarks>
        </member>
        <member name="M:GemBox.Spreadsheet.CellStyle.#ctor(GemBox.Spreadsheet.ExcelFile)">
            <summary>
            Creates new cell style with default values (copies default font from ExcelFile object).
            </summary>
            <remarks>
            Creating standalone cell style has sense only if you assign it to some Excel objects
            by setting <b>Style</b> property. Otherwise, the created cell style will have no effect on the Excel file.
            </remarks>
            <param name="ef">ExcelFile object.</param>
        </member>
        <member name="P:GemBox.Spreadsheet.CellStyle.IsDefault">
            <summary>
            Returns <b>true</b> if cell style is default; otherwise, <b>false</b>.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.CellStyle.HorizontalAlignment">
            <summary>
            Gets or sets horizontal alignment.
            </summary>
            <remarks>
            Default value for this property is <see cref="F:GemBox.Spreadsheet.HorizontalAlignmentStyle.General">
            HorizontalAlignmentStyle.General</see>.
            </remarks>
            <example> Following code demonstrates various cell style properties:
<code lang="vbnet">
    Sub StylesSample(ByVal ws As ExcelWorksheet)
        ws.Cells(0, 0).Value = "Cell style examples:"

        Dim row As Integer = 0

        <font color="Green">' Column width of 4, 30 and 35 characters.</font>
        ws.Columns(0).Width = 4 * 256
        ws.Columns(1).Width = 30 * 256
        ws.Columns(2).Width = 35 * 256

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Borders.SetBorders(...)"
        ws.Cells(row, 2).Style.Borders.SetBorders(MultipleBorders.All, Color.FromArgb(252, 1, 1), LineStyle.Thin)

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.FillPattern.SetPattern(...)"
        ws.Cells(row, 2).Style.FillPattern.SetPattern(FillPatternStyle.ThinHorizontalCrosshatch, Color.Green, Color.Yellow)

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Color ="
        ws.Cells(row, 2).Value = "Color.Blue"
        ws.Cells(row, 2).Style.Font.Color = Color.Blue

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Italic ="
        ws.Cells(row, 2).Value = "true"
        ws.Cells(row, 2).Style.Font.Italic = True

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Name ="
        ws.Cells(row, 2).Value = "Comic Sans MS"
        ws.Cells(row, 2).Style.Font.Name = "Comic Sans MS"

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.ScriptPosition ="
        ws.Cells(row, 2).Value = "ScriptPosition.Superscript"
        ws.Cells(row, 2).Style.Font.ScriptPosition = ScriptPosition.Superscript

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Size ="
        ws.Cells(row, 2).Value = "18 * 20"
        ws.Cells(row, 2).Style.Font.Size = 18 * 20

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Strikeout ="
        ws.Cells(row, 2).Value = "true"
        ws.Cells(row, 2).Style.Font.Strikeout = True

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.UnderlineStyle ="
        ws.Cells(row, 2).Value = "UnderlineStyle.Double"
        ws.Cells(row, 2).Style.Font.UnderlineStyle = UnderlineStyle.Double

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Weight ="
        ws.Cells(row, 2).Value = "ExcelFont.BoldWeight"
        ws.Cells(row, 2).Style.Font.Weight = ExcelFont.BoldWeight

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.HorizontalAlignment ="
        ws.Cells(row, 2).Value = "HorizontalAlignmentStyle.Center"
        ws.Cells(row, 2).Style.HorizontalAlignment = HorizontalAlignmentStyle.Center

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Indent"
        ws.Cells(row, 2).Value = "five"
        ws.Cells(row, 2).Style.HorizontalAlignment = HorizontalAlignmentStyle.Left
        ws.Cells(row, 2).Style.Indent = 5

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.IsTextVertical = "
        ws.Cells(row, 2).Value = "true"
        <font color="Green">' Set row height to 50 points.</font>
        ws.Rows(row).Height = 50 * 20
        ws.Cells(row, 2).Style.IsTextVertical = True

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.NumberFormat"
        ws.Cells(row, 2).Value = 1234
        ws.Cells(row, 2).Style.NumberFormat = "#.##0,00 [$Krakozhian Money Units]"

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Rotation"
        ws.Cells(row, 2).Value = "35 degrees up"
        ws.Cells(row, 2).Style.Rotation = 35

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.ShrinkToFit"
        ws.Cells(row, 2).Value = "This property is set to true so this text appears shrunk."
        ws.Cells(row, 2).Style.ShrinkToFit = True

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.VerticalAlignment ="
        ws.Cells(row, 2).Value = "VerticalAlignmentStyle.Top"
        <font color="Green">' Set row height to 30 points.</font>
        ws.Rows(row).Height = 30 * 20
        ws.Cells(row, 2).Style.VerticalAlignment = VerticalAlignmentStyle.Top

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.WrapText"
        ws.Cells(row, 2).Value = "This property is set to true so this text appears broken into multiple lines."
        ws.Cells(row, 2).Style.WrapText = True
    End Sub
</code>
<code lang="C#">
	static void StylesSample(ExcelWorksheet ws)
	{
		ws.Cells[0,0].Value = "Cell style examples:";

		int row = 0;

		// Column width of 4, 30 and 35 characters.
		ws.Columns[0].Width = 4 * 256;
		ws.Columns[1].Width = 30 * 256;
		ws.Columns[2].Width = 35 * 256;

		ws.Cells[row+=2,1].Value = ".Style.Borders.SetBorders(...)";
		ws.Cells[row,2].Style.Borders.SetBorders(MultipleBorders.All, Color.FromArgb(252, 1, 1), LineStyle.Thin);

		ws.Cells[row+=2,1].Value = ".Style.FillPattern.SetPattern(...)";
		ws.Cells[row,2].Style.FillPattern.SetPattern(FillPatternStyle.ThinHorizontalCrosshatch, Color.Green, Color.Yellow);

		ws.Cells[row+=2,1].Value = ".Style.Font.Color =";
		ws.Cells[row,2].Value = "Color.Blue";
		ws.Cells[row,2].Style.Font.Color = Color.Blue;

		ws.Cells[row+=2,1].Value = ".Style.Font.Italic =";
		ws.Cells[row,2].Value = "true";
		ws.Cells[row,2].Style.Font.Italic = true;

		ws.Cells[row+=2,1].Value = ".Style.Font.Name =";
		ws.Cells[row,2].Value = "Comic Sans MS";
		ws.Cells[row,2].Style.Font.Name = "Comic Sans MS";

		ws.Cells[row+=2,1].Value = ".Style.Font.ScriptPosition =";
		ws.Cells[row,2].Value = "ScriptPosition.Superscript";
		ws.Cells[row,2].Style.Font.ScriptPosition = ScriptPosition.Superscript;

		ws.Cells[row+=2,1].Value = ".Style.Font.Size =";
		ws.Cells[row,2].Value = "18 * 20";
		ws.Cells[row,2].Style.Font.Size = 18 * 20;

		ws.Cells[row+=2,1].Value = ".Style.Font.Strikeout =";
		ws.Cells[row,2].Value = "true";
		ws.Cells[row,2].Style.Font.Strikeout = true;

		ws.Cells[row+=2,1].Value = ".Style.Font.UnderlineStyle =";
		ws.Cells[row,2].Value = "UnderlineStyle.Double";
		ws.Cells[row,2].Style.Font.UnderlineStyle = UnderlineStyle.Double;

		ws.Cells[row+=2,1].Value = ".Style.Font.Weight =";
		ws.Cells[row,2].Value = "ExcelFont.BoldWeight";
		ws.Cells[row,2].Style.Font.Weight = ExcelFont.BoldWeight;

		ws.Cells[row+=2,1].Value = ".Style.HorizontalAlignment =";
		ws.Cells[row,2].Value = "HorizontalAlignmentStyle.Center";
		ws.Cells[row,2].Style.HorizontalAlignment = HorizontalAlignmentStyle.Center;

		ws.Cells[row+=2,1].Value = ".Style.Indent";
		ws.Cells[row,2].Value = "five";
		ws.Cells[row,2].Style.HorizontalAlignment = HorizontalAlignmentStyle.Left;
		ws.Cells[row,2].Style.Indent = 5;

		ws.Cells[row+=2,1].Value = ".Style.IsTextVertical = ";
		ws.Cells[row,2].Value = "true";
		// Set row height to 50 points.
		ws.Rows[row].Height = 50 * 20;
		ws.Cells[row,2].Style.IsTextVertical = true;

		ws.Cells[row+=2,1].Value = ".Style.NumberFormat";
		ws.Cells[row,2].Value = 1234;
		ws.Cells[row,2].Style.NumberFormat = "#.##0,00 [$Krakozhian Money Units]";

		ws.Cells[row+=2,1].Value = ".Style.Rotation";
		ws.Cells[row,2].Value = "35 degrees up";
		ws.Cells[row,2].Style.Rotation = 35;

		ws.Cells[row+=2,1].Value = ".Style.ShrinkToFit";
		ws.Cells[row,2].Value = "This property is set to true so this text appears shrunk.";
		ws.Cells[row,2].Style.ShrinkToFit = true;

		ws.Cells[row+=2,1].Value = ".Style.VerticalAlignment =";
		ws.Cells[row,2].Value = "VerticalAlignmentStyle.Top";
		// Set row height to 30 points.
		ws.Rows[row].Height = 30 * 20;
		ws.Cells[row,2].Style.VerticalAlignment = VerticalAlignmentStyle.Top;

		ws.Cells[row+=2,1].Value = ".Style.WrapText";
		ws.Cells[row,2].Value = "This property is set to true so this text appears broken into multiple lines.";
		ws.Cells[row,2].Style.WrapText = true;
	}
</code> 
</example>
            <seealso cref="P:GemBox.Spreadsheet.CellStyle.VerticalAlignment"/>
        </member>
        <member name="P:GemBox.Spreadsheet.CellStyle.VerticalAlignment">
            <summary>
            Gets or sets vertical alignment.
            </summary>
            <remarks>
            Default value for this property is <see cref="F:GemBox.Spreadsheet.VerticalAlignmentStyle.Bottom">
            VerticalAlignmentStyle.Bottom</see>.
            </remarks>
            <example> Following code demonstrates various cell style properties:
<code lang="vbnet">
    Sub StylesSample(ByVal ws As ExcelWorksheet)
        ws.Cells(0, 0).Value = "Cell style examples:"

        Dim row As Integer = 0

        <font color="Green">' Column width of 4, 30 and 35 characters.</font>
        ws.Columns(0).Width = 4 * 256
        ws.Columns(1).Width = 30 * 256
        ws.Columns(2).Width = 35 * 256

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Borders.SetBorders(...)"
        ws.Cells(row, 2).Style.Borders.SetBorders(MultipleBorders.All, Color.FromArgb(252, 1, 1), LineStyle.Thin)

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.FillPattern.SetPattern(...)"
        ws.Cells(row, 2).Style.FillPattern.SetPattern(FillPatternStyle.ThinHorizontalCrosshatch, Color.Green, Color.Yellow)

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Color ="
        ws.Cells(row, 2).Value = "Color.Blue"
        ws.Cells(row, 2).Style.Font.Color = Color.Blue

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Italic ="
        ws.Cells(row, 2).Value = "true"
        ws.Cells(row, 2).Style.Font.Italic = True

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Name ="
        ws.Cells(row, 2).Value = "Comic Sans MS"
        ws.Cells(row, 2).Style.Font.Name = "Comic Sans MS"

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.ScriptPosition ="
        ws.Cells(row, 2).Value = "ScriptPosition.Superscript"
        ws.Cells(row, 2).Style.Font.ScriptPosition = ScriptPosition.Superscript

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Size ="
        ws.Cells(row, 2).Value = "18 * 20"
        ws.Cells(row, 2).Style.Font.Size = 18 * 20

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Strikeout ="
        ws.Cells(row, 2).Value = "true"
        ws.Cells(row, 2).Style.Font.Strikeout = True

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.UnderlineStyle ="
        ws.Cells(row, 2).Value = "UnderlineStyle.Double"
        ws.Cells(row, 2).Style.Font.UnderlineStyle = UnderlineStyle.Double

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Weight ="
        ws.Cells(row, 2).Value = "ExcelFont.BoldWeight"
        ws.Cells(row, 2).Style.Font.Weight = ExcelFont.BoldWeight

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.HorizontalAlignment ="
        ws.Cells(row, 2).Value = "HorizontalAlignmentStyle.Center"
        ws.Cells(row, 2).Style.HorizontalAlignment = HorizontalAlignmentStyle.Center

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Indent"
        ws.Cells(row, 2).Value = "five"
        ws.Cells(row, 2).Style.HorizontalAlignment = HorizontalAlignmentStyle.Left
        ws.Cells(row, 2).Style.Indent = 5

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.IsTextVertical = "
        ws.Cells(row, 2).Value = "true"
        <font color="Green">' Set row height to 50 points.</font>
        ws.Rows(row).Height = 50 * 20
        ws.Cells(row, 2).Style.IsTextVertical = True

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.NumberFormat"
        ws.Cells(row, 2).Value = 1234
        ws.Cells(row, 2).Style.NumberFormat = "#.##0,00 [$Krakozhian Money Units]"

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Rotation"
        ws.Cells(row, 2).Value = "35 degrees up"
        ws.Cells(row, 2).Style.Rotation = 35

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.ShrinkToFit"
        ws.Cells(row, 2).Value = "This property is set to true so this text appears shrunk."
        ws.Cells(row, 2).Style.ShrinkToFit = True

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.VerticalAlignment ="
        ws.Cells(row, 2).Value = "VerticalAlignmentStyle.Top"
        <font color="Green">' Set row height to 30 points.</font>
        ws.Rows(row).Height = 30 * 20
        ws.Cells(row, 2).Style.VerticalAlignment = VerticalAlignmentStyle.Top

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.WrapText"
        ws.Cells(row, 2).Value = "This property is set to true so this text appears broken into multiple lines."
        ws.Cells(row, 2).Style.WrapText = True
    End Sub
</code>
<code lang="C#">
	static void StylesSample(ExcelWorksheet ws)
	{
		ws.Cells[0,0].Value = "Cell style examples:";

		int row = 0;

		// Column width of 4, 30 and 35 characters.
		ws.Columns[0].Width = 4 * 256;
		ws.Columns[1].Width = 30 * 256;
		ws.Columns[2].Width = 35 * 256;

		ws.Cells[row+=2,1].Value = ".Style.Borders.SetBorders(...)";
		ws.Cells[row,2].Style.Borders.SetBorders(MultipleBorders.All, Color.FromArgb(252, 1, 1), LineStyle.Thin);

		ws.Cells[row+=2,1].Value = ".Style.FillPattern.SetPattern(...)";
		ws.Cells[row,2].Style.FillPattern.SetPattern(FillPatternStyle.ThinHorizontalCrosshatch, Color.Green, Color.Yellow);

		ws.Cells[row+=2,1].Value = ".Style.Font.Color =";
		ws.Cells[row,2].Value = "Color.Blue";
		ws.Cells[row,2].Style.Font.Color = Color.Blue;

		ws.Cells[row+=2,1].Value = ".Style.Font.Italic =";
		ws.Cells[row,2].Value = "true";
		ws.Cells[row,2].Style.Font.Italic = true;

		ws.Cells[row+=2,1].Value = ".Style.Font.Name =";
		ws.Cells[row,2].Value = "Comic Sans MS";
		ws.Cells[row,2].Style.Font.Name = "Comic Sans MS";

		ws.Cells[row+=2,1].Value = ".Style.Font.ScriptPosition =";
		ws.Cells[row,2].Value = "ScriptPosition.Superscript";
		ws.Cells[row,2].Style.Font.ScriptPosition = ScriptPosition.Superscript;

		ws.Cells[row+=2,1].Value = ".Style.Font.Size =";
		ws.Cells[row,2].Value = "18 * 20";
		ws.Cells[row,2].Style.Font.Size = 18 * 20;

		ws.Cells[row+=2,1].Value = ".Style.Font.Strikeout =";
		ws.Cells[row,2].Value = "true";
		ws.Cells[row,2].Style.Font.Strikeout = true;

		ws.Cells[row+=2,1].Value = ".Style.Font.UnderlineStyle =";
		ws.Cells[row,2].Value = "UnderlineStyle.Double";
		ws.Cells[row,2].Style.Font.UnderlineStyle = UnderlineStyle.Double;

		ws.Cells[row+=2,1].Value = ".Style.Font.Weight =";
		ws.Cells[row,2].Value = "ExcelFont.BoldWeight";
		ws.Cells[row,2].Style.Font.Weight = ExcelFont.BoldWeight;

		ws.Cells[row+=2,1].Value = ".Style.HorizontalAlignment =";
		ws.Cells[row,2].Value = "HorizontalAlignmentStyle.Center";
		ws.Cells[row,2].Style.HorizontalAlignment = HorizontalAlignmentStyle.Center;

		ws.Cells[row+=2,1].Value = ".Style.Indent";
		ws.Cells[row,2].Value = "five";
		ws.Cells[row,2].Style.HorizontalAlignment = HorizontalAlignmentStyle.Left;
		ws.Cells[row,2].Style.Indent = 5;

		ws.Cells[row+=2,1].Value = ".Style.IsTextVertical = ";
		ws.Cells[row,2].Value = "true";
		// Set row height to 50 points.
		ws.Rows[row].Height = 50 * 20;
		ws.Cells[row,2].Style.IsTextVertical = true;

		ws.Cells[row+=2,1].Value = ".Style.NumberFormat";
		ws.Cells[row,2].Value = 1234;
		ws.Cells[row,2].Style.NumberFormat = "#.##0,00 [$Krakozhian Money Units]";

		ws.Cells[row+=2,1].Value = ".Style.Rotation";
		ws.Cells[row,2].Value = "35 degrees up";
		ws.Cells[row,2].Style.Rotation = 35;

		ws.Cells[row+=2,1].Value = ".Style.ShrinkToFit";
		ws.Cells[row,2].Value = "This property is set to true so this text appears shrunk.";
		ws.Cells[row,2].Style.ShrinkToFit = true;

		ws.Cells[row+=2,1].Value = ".Style.VerticalAlignment =";
		ws.Cells[row,2].Value = "VerticalAlignmentStyle.Top";
		// Set row height to 30 points.
		ws.Rows[row].Height = 30 * 20;
		ws.Cells[row,2].Style.VerticalAlignment = VerticalAlignmentStyle.Top;

		ws.Cells[row+=2,1].Value = ".Style.WrapText";
		ws.Cells[row,2].Value = "This property is set to true so this text appears broken into multiple lines.";
		ws.Cells[row,2].Style.WrapText = true;
	}
</code> 
</example>
            <seealso cref="P:GemBox.Spreadsheet.CellStyle.HorizontalAlignment"/>
        </member>
        <member name="P:GemBox.Spreadsheet.CellStyle.FillPattern">
            <summary>
            Get or sets fill pattern.
            </summary>
            <example> Following code demonstrates various cell style properties:
<code lang="vbnet">
    Sub StylesSample(ByVal ws As ExcelWorksheet)
        ws.Cells(0, 0).Value = "Cell style examples:"

        Dim row As Integer = 0

        <font color="Green">' Column width of 4, 30 and 35 characters.</font>
        ws.Columns(0).Width = 4 * 256
        ws.Columns(1).Width = 30 * 256
        ws.Columns(2).Width = 35 * 256

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Borders.SetBorders(...)"
        ws.Cells(row, 2).Style.Borders.SetBorders(MultipleBorders.All, Color.FromArgb(252, 1, 1), LineStyle.Thin)

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.FillPattern.SetPattern(...)"
        ws.Cells(row, 2).Style.FillPattern.SetPattern(FillPatternStyle.ThinHorizontalCrosshatch, Color.Green, Color.Yellow)

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Color ="
        ws.Cells(row, 2).Value = "Color.Blue"
        ws.Cells(row, 2).Style.Font.Color = Color.Blue

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Italic ="
        ws.Cells(row, 2).Value = "true"
        ws.Cells(row, 2).Style.Font.Italic = True

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Name ="
        ws.Cells(row, 2).Value = "Comic Sans MS"
        ws.Cells(row, 2).Style.Font.Name = "Comic Sans MS"

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.ScriptPosition ="
        ws.Cells(row, 2).Value = "ScriptPosition.Superscript"
        ws.Cells(row, 2).Style.Font.ScriptPosition = ScriptPosition.Superscript

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Size ="
        ws.Cells(row, 2).Value = "18 * 20"
        ws.Cells(row, 2).Style.Font.Size = 18 * 20

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Strikeout ="
        ws.Cells(row, 2).Value = "true"
        ws.Cells(row, 2).Style.Font.Strikeout = True

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.UnderlineStyle ="
        ws.Cells(row, 2).Value = "UnderlineStyle.Double"
        ws.Cells(row, 2).Style.Font.UnderlineStyle = UnderlineStyle.Double

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Weight ="
        ws.Cells(row, 2).Value = "ExcelFont.BoldWeight"
        ws.Cells(row, 2).Style.Font.Weight = ExcelFont.BoldWeight

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.HorizontalAlignment ="
        ws.Cells(row, 2).Value = "HorizontalAlignmentStyle.Center"
        ws.Cells(row, 2).Style.HorizontalAlignment = HorizontalAlignmentStyle.Center

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Indent"
        ws.Cells(row, 2).Value = "five"
        ws.Cells(row, 2).Style.HorizontalAlignment = HorizontalAlignmentStyle.Left
        ws.Cells(row, 2).Style.Indent = 5

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.IsTextVertical = "
        ws.Cells(row, 2).Value = "true"
        <font color="Green">' Set row height to 50 points.</font>
        ws.Rows(row).Height = 50 * 20
        ws.Cells(row, 2).Style.IsTextVertical = True

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.NumberFormat"
        ws.Cells(row, 2).Value = 1234
        ws.Cells(row, 2).Style.NumberFormat = "#.##0,00 [$Krakozhian Money Units]"

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Rotation"
        ws.Cells(row, 2).Value = "35 degrees up"
        ws.Cells(row, 2).Style.Rotation = 35

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.ShrinkToFit"
        ws.Cells(row, 2).Value = "This property is set to true so this text appears shrunk."
        ws.Cells(row, 2).Style.ShrinkToFit = True

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.VerticalAlignment ="
        ws.Cells(row, 2).Value = "VerticalAlignmentStyle.Top"
        <font color="Green">' Set row height to 30 points.</font>
        ws.Rows(row).Height = 30 * 20
        ws.Cells(row, 2).Style.VerticalAlignment = VerticalAlignmentStyle.Top

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.WrapText"
        ws.Cells(row, 2).Value = "This property is set to true so this text appears broken into multiple lines."
        ws.Cells(row, 2).Style.WrapText = True
    End Sub
</code>
<code lang="C#">
	static void StylesSample(ExcelWorksheet ws)
	{
		ws.Cells[0,0].Value = "Cell style examples:";

		int row = 0;

		// Column width of 4, 30 and 35 characters.
		ws.Columns[0].Width = 4 * 256;
		ws.Columns[1].Width = 30 * 256;
		ws.Columns[2].Width = 35 * 256;

		ws.Cells[row+=2,1].Value = ".Style.Borders.SetBorders(...)";
		ws.Cells[row,2].Style.Borders.SetBorders(MultipleBorders.All, Color.FromArgb(252, 1, 1), LineStyle.Thin);

		ws.Cells[row+=2,1].Value = ".Style.FillPattern.SetPattern(...)";
		ws.Cells[row,2].Style.FillPattern.SetPattern(FillPatternStyle.ThinHorizontalCrosshatch, Color.Green, Color.Yellow);

		ws.Cells[row+=2,1].Value = ".Style.Font.Color =";
		ws.Cells[row,2].Value = "Color.Blue";
		ws.Cells[row,2].Style.Font.Color = Color.Blue;

		ws.Cells[row+=2,1].Value = ".Style.Font.Italic =";
		ws.Cells[row,2].Value = "true";
		ws.Cells[row,2].Style.Font.Italic = true;

		ws.Cells[row+=2,1].Value = ".Style.Font.Name =";
		ws.Cells[row,2].Value = "Comic Sans MS";
		ws.Cells[row,2].Style.Font.Name = "Comic Sans MS";

		ws.Cells[row+=2,1].Value = ".Style.Font.ScriptPosition =";
		ws.Cells[row,2].Value = "ScriptPosition.Superscript";
		ws.Cells[row,2].Style.Font.ScriptPosition = ScriptPosition.Superscript;

		ws.Cells[row+=2,1].Value = ".Style.Font.Size =";
		ws.Cells[row,2].Value = "18 * 20";
		ws.Cells[row,2].Style.Font.Size = 18 * 20;

		ws.Cells[row+=2,1].Value = ".Style.Font.Strikeout =";
		ws.Cells[row,2].Value = "true";
		ws.Cells[row,2].Style.Font.Strikeout = true;

		ws.Cells[row+=2,1].Value = ".Style.Font.UnderlineStyle =";
		ws.Cells[row,2].Value = "UnderlineStyle.Double";
		ws.Cells[row,2].Style.Font.UnderlineStyle = UnderlineStyle.Double;

		ws.Cells[row+=2,1].Value = ".Style.Font.Weight =";
		ws.Cells[row,2].Value = "ExcelFont.BoldWeight";
		ws.Cells[row,2].Style.Font.Weight = ExcelFont.BoldWeight;

		ws.Cells[row+=2,1].Value = ".Style.HorizontalAlignment =";
		ws.Cells[row,2].Value = "HorizontalAlignmentStyle.Center";
		ws.Cells[row,2].Style.HorizontalAlignment = HorizontalAlignmentStyle.Center;

		ws.Cells[row+=2,1].Value = ".Style.Indent";
		ws.Cells[row,2].Value = "five";
		ws.Cells[row,2].Style.HorizontalAlignment = HorizontalAlignmentStyle.Left;
		ws.Cells[row,2].Style.Indent = 5;

		ws.Cells[row+=2,1].Value = ".Style.IsTextVertical = ";
		ws.Cells[row,2].Value = "true";
		// Set row height to 50 points.
		ws.Rows[row].Height = 50 * 20;
		ws.Cells[row,2].Style.IsTextVertical = true;

		ws.Cells[row+=2,1].Value = ".Style.NumberFormat";
		ws.Cells[row,2].Value = 1234;
		ws.Cells[row,2].Style.NumberFormat = "#.##0,00 [$Krakozhian Money Units]";

		ws.Cells[row+=2,1].Value = ".Style.Rotation";
		ws.Cells[row,2].Value = "35 degrees up";
		ws.Cells[row,2].Style.Rotation = 35;

		ws.Cells[row+=2,1].Value = ".Style.ShrinkToFit";
		ws.Cells[row,2].Value = "This property is set to true so this text appears shrunk.";
		ws.Cells[row,2].Style.ShrinkToFit = true;

		ws.Cells[row+=2,1].Value = ".Style.VerticalAlignment =";
		ws.Cells[row,2].Value = "VerticalAlignmentStyle.Top";
		// Set row height to 30 points.
		ws.Rows[row].Height = 30 * 20;
		ws.Cells[row,2].Style.VerticalAlignment = VerticalAlignmentStyle.Top;

		ws.Cells[row+=2,1].Value = ".Style.WrapText";
		ws.Cells[row,2].Value = "This property is set to true so this text appears broken into multiple lines.";
		ws.Cells[row,2].Style.WrapText = true;
	}
</code> 
</example>
        </member>
        <member name="P:GemBox.Spreadsheet.CellStyle.Indent">
            <summary>
            Gets or sets cell data indentation.
            </summary>
            <remarks>
            <p>Indents cell contents from any edge of the cell, depending on 
            <see cref="P:GemBox.Spreadsheet.CellStyle.IsTextVertical">IsTextVertical</see> and associated alignment. If 
            you set this property to non-zero value and <see cref="P:GemBox.Spreadsheet.CellStyle.IsTextVertical">
            IsTextVertical</see> is <b>false</b>, it is recommended that you also set 
            <see cref="P:GemBox.Spreadsheet.CellStyle.HorizontalAlignment">HorizontalAlignment</see> to
            <see cref="F:GemBox.Spreadsheet.HorizontalAlignmentStyle.Left">HorizontalAlignmentStyle.Left</see> or
            <see cref="F:GemBox.Spreadsheet.HorizontalAlignmentStyle.Right">HorizontalAlignmentStyle.Right</see>. 
            Otherwise some versions of Microsoft Excel will have problems interpreting Indent value in 
            "Format Cells..." dialog &gt; "Alignment" tab. In the case where 
            <see cref="P:GemBox.Spreadsheet.CellStyle.IsTextVertical">IsTextVertical</see> is <b>true</b>, you should set
            <see cref="P:GemBox.Spreadsheet.CellStyle.VerticalAlignment">VerticalAlignment</see> instead.</p>
            <p>Unit is one character. Value must be between 0 and 15.</p>
            <p>Default value for this property is 0.</p>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if value is out of range.</exception>
            <example> Following code demonstrates various cell style properties:
<code lang="vbnet">
    Sub StylesSample(ByVal ws As ExcelWorksheet)
        ws.Cells(0, 0).Value = "Cell style examples:"

        Dim row As Integer = 0

        <font color="Green">' Column width of 4, 30 and 35 characters.</font>
        ws.Columns(0).Width = 4 * 256
        ws.Columns(1).Width = 30 * 256
        ws.Columns(2).Width = 35 * 256

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Borders.SetBorders(...)"
        ws.Cells(row, 2).Style.Borders.SetBorders(MultipleBorders.All, Color.FromArgb(252, 1, 1), LineStyle.Thin)

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.FillPattern.SetPattern(...)"
        ws.Cells(row, 2).Style.FillPattern.SetPattern(FillPatternStyle.ThinHorizontalCrosshatch, Color.Green, Color.Yellow)

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Color ="
        ws.Cells(row, 2).Value = "Color.Blue"
        ws.Cells(row, 2).Style.Font.Color = Color.Blue

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Italic ="
        ws.Cells(row, 2).Value = "true"
        ws.Cells(row, 2).Style.Font.Italic = True

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Name ="
        ws.Cells(row, 2).Value = "Comic Sans MS"
        ws.Cells(row, 2).Style.Font.Name = "Comic Sans MS"

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.ScriptPosition ="
        ws.Cells(row, 2).Value = "ScriptPosition.Superscript"
        ws.Cells(row, 2).Style.Font.ScriptPosition = ScriptPosition.Superscript

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Size ="
        ws.Cells(row, 2).Value = "18 * 20"
        ws.Cells(row, 2).Style.Font.Size = 18 * 20

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Strikeout ="
        ws.Cells(row, 2).Value = "true"
        ws.Cells(row, 2).Style.Font.Strikeout = True

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.UnderlineStyle ="
        ws.Cells(row, 2).Value = "UnderlineStyle.Double"
        ws.Cells(row, 2).Style.Font.UnderlineStyle = UnderlineStyle.Double

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Weight ="
        ws.Cells(row, 2).Value = "ExcelFont.BoldWeight"
        ws.Cells(row, 2).Style.Font.Weight = ExcelFont.BoldWeight

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.HorizontalAlignment ="
        ws.Cells(row, 2).Value = "HorizontalAlignmentStyle.Center"
        ws.Cells(row, 2).Style.HorizontalAlignment = HorizontalAlignmentStyle.Center

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Indent"
        ws.Cells(row, 2).Value = "five"
        ws.Cells(row, 2).Style.HorizontalAlignment = HorizontalAlignmentStyle.Left
        ws.Cells(row, 2).Style.Indent = 5

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.IsTextVertical = "
        ws.Cells(row, 2).Value = "true"
        <font color="Green">' Set row height to 50 points.</font>
        ws.Rows(row).Height = 50 * 20
        ws.Cells(row, 2).Style.IsTextVertical = True

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.NumberFormat"
        ws.Cells(row, 2).Value = 1234
        ws.Cells(row, 2).Style.NumberFormat = "#.##0,00 [$Krakozhian Money Units]"

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Rotation"
        ws.Cells(row, 2).Value = "35 degrees up"
        ws.Cells(row, 2).Style.Rotation = 35

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.ShrinkToFit"
        ws.Cells(row, 2).Value = "This property is set to true so this text appears shrunk."
        ws.Cells(row, 2).Style.ShrinkToFit = True

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.VerticalAlignment ="
        ws.Cells(row, 2).Value = "VerticalAlignmentStyle.Top"
        <font color="Green">' Set row height to 30 points.</font>
        ws.Rows(row).Height = 30 * 20
        ws.Cells(row, 2).Style.VerticalAlignment = VerticalAlignmentStyle.Top

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.WrapText"
        ws.Cells(row, 2).Value = "This property is set to true so this text appears broken into multiple lines."
        ws.Cells(row, 2).Style.WrapText = True
    End Sub
</code>
<code lang="C#">
	static void StylesSample(ExcelWorksheet ws)
	{
		ws.Cells[0,0].Value = "Cell style examples:";

		int row = 0;

		// Column width of 4, 30 and 35 characters.
		ws.Columns[0].Width = 4 * 256;
		ws.Columns[1].Width = 30 * 256;
		ws.Columns[2].Width = 35 * 256;

		ws.Cells[row+=2,1].Value = ".Style.Borders.SetBorders(...)";
		ws.Cells[row,2].Style.Borders.SetBorders(MultipleBorders.All, Color.FromArgb(252, 1, 1), LineStyle.Thin);

		ws.Cells[row+=2,1].Value = ".Style.FillPattern.SetPattern(...)";
		ws.Cells[row,2].Style.FillPattern.SetPattern(FillPatternStyle.ThinHorizontalCrosshatch, Color.Green, Color.Yellow);

		ws.Cells[row+=2,1].Value = ".Style.Font.Color =";
		ws.Cells[row,2].Value = "Color.Blue";
		ws.Cells[row,2].Style.Font.Color = Color.Blue;

		ws.Cells[row+=2,1].Value = ".Style.Font.Italic =";
		ws.Cells[row,2].Value = "true";
		ws.Cells[row,2].Style.Font.Italic = true;

		ws.Cells[row+=2,1].Value = ".Style.Font.Name =";
		ws.Cells[row,2].Value = "Comic Sans MS";
		ws.Cells[row,2].Style.Font.Name = "Comic Sans MS";

		ws.Cells[row+=2,1].Value = ".Style.Font.ScriptPosition =";
		ws.Cells[row,2].Value = "ScriptPosition.Superscript";
		ws.Cells[row,2].Style.Font.ScriptPosition = ScriptPosition.Superscript;

		ws.Cells[row+=2,1].Value = ".Style.Font.Size =";
		ws.Cells[row,2].Value = "18 * 20";
		ws.Cells[row,2].Style.Font.Size = 18 * 20;

		ws.Cells[row+=2,1].Value = ".Style.Font.Strikeout =";
		ws.Cells[row,2].Value = "true";
		ws.Cells[row,2].Style.Font.Strikeout = true;

		ws.Cells[row+=2,1].Value = ".Style.Font.UnderlineStyle =";
		ws.Cells[row,2].Value = "UnderlineStyle.Double";
		ws.Cells[row,2].Style.Font.UnderlineStyle = UnderlineStyle.Double;

		ws.Cells[row+=2,1].Value = ".Style.Font.Weight =";
		ws.Cells[row,2].Value = "ExcelFont.BoldWeight";
		ws.Cells[row,2].Style.Font.Weight = ExcelFont.BoldWeight;

		ws.Cells[row+=2,1].Value = ".Style.HorizontalAlignment =";
		ws.Cells[row,2].Value = "HorizontalAlignmentStyle.Center";
		ws.Cells[row,2].Style.HorizontalAlignment = HorizontalAlignmentStyle.Center;

		ws.Cells[row+=2,1].Value = ".Style.Indent";
		ws.Cells[row,2].Value = "five";
		ws.Cells[row,2].Style.HorizontalAlignment = HorizontalAlignmentStyle.Left;
		ws.Cells[row,2].Style.Indent = 5;

		ws.Cells[row+=2,1].Value = ".Style.IsTextVertical = ";
		ws.Cells[row,2].Value = "true";
		// Set row height to 50 points.
		ws.Rows[row].Height = 50 * 20;
		ws.Cells[row,2].Style.IsTextVertical = true;

		ws.Cells[row+=2,1].Value = ".Style.NumberFormat";
		ws.Cells[row,2].Value = 1234;
		ws.Cells[row,2].Style.NumberFormat = "#.##0,00 [$Krakozhian Money Units]";

		ws.Cells[row+=2,1].Value = ".Style.Rotation";
		ws.Cells[row,2].Value = "35 degrees up";
		ws.Cells[row,2].Style.Rotation = 35;

		ws.Cells[row+=2,1].Value = ".Style.ShrinkToFit";
		ws.Cells[row,2].Value = "This property is set to true so this text appears shrunk.";
		ws.Cells[row,2].Style.ShrinkToFit = true;

		ws.Cells[row+=2,1].Value = ".Style.VerticalAlignment =";
		ws.Cells[row,2].Value = "VerticalAlignmentStyle.Top";
		// Set row height to 30 points.
		ws.Rows[row].Height = 30 * 20;
		ws.Cells[row,2].Style.VerticalAlignment = VerticalAlignmentStyle.Top;

		ws.Cells[row+=2,1].Value = ".Style.WrapText";
		ws.Cells[row,2].Value = "This property is set to true so this text appears broken into multiple lines.";
		ws.Cells[row,2].Style.WrapText = true;
	}
</code> 
</example>
        </member>
        <member name="P:GemBox.Spreadsheet.CellStyle.Rotation">
            <summary>
            Gets or sets cell data rotation.
            </summary>
            <remarks>
            <p>Unit is degrees (1/360th of a full circle). Value must be between -90 and 90 and specifies 
            anticlockwise (counterclockwise [N.Amer]) rotation from the normal position.</p>
            <p>Because of Microsoft Excel limitations, this property and 
            <see cref="P:GemBox.Spreadsheet.CellStyle.IsTextVertical">IsTextVertical</see> property can't be used at the 
            same time. If <see cref="P:GemBox.Spreadsheet.CellStyle.IsTextVertical">IsTextVertical</see> is <b>true</b> and 
            rotation is set, <see cref="P:GemBox.Spreadsheet.CellStyle.IsTextVertical">IsTextVertical</see> will be set to 
            <b>false</b>. When <see cref="P:GemBox.Spreadsheet.CellStyle.IsTextVertical">IsTextVertical</see> is set to 
            <b>true</b>, rotation will be set to 0.</p>
            <p>Default value for this property is 0.</p>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if value is not between -90 and 90.</exception>
            <example> Following code demonstrates various cell style properties:
<code lang="vbnet">
    Sub StylesSample(ByVal ws As ExcelWorksheet)
        ws.Cells(0, 0).Value = "Cell style examples:"

        Dim row As Integer = 0

        <font color="Green">' Column width of 4, 30 and 35 characters.</font>
        ws.Columns(0).Width = 4 * 256
        ws.Columns(1).Width = 30 * 256
        ws.Columns(2).Width = 35 * 256

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Borders.SetBorders(...)"
        ws.Cells(row, 2).Style.Borders.SetBorders(MultipleBorders.All, Color.FromArgb(252, 1, 1), LineStyle.Thin)

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.FillPattern.SetPattern(...)"
        ws.Cells(row, 2).Style.FillPattern.SetPattern(FillPatternStyle.ThinHorizontalCrosshatch, Color.Green, Color.Yellow)

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Color ="
        ws.Cells(row, 2).Value = "Color.Blue"
        ws.Cells(row, 2).Style.Font.Color = Color.Blue

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Italic ="
        ws.Cells(row, 2).Value = "true"
        ws.Cells(row, 2).Style.Font.Italic = True

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Name ="
        ws.Cells(row, 2).Value = "Comic Sans MS"
        ws.Cells(row, 2).Style.Font.Name = "Comic Sans MS"

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.ScriptPosition ="
        ws.Cells(row, 2).Value = "ScriptPosition.Superscript"
        ws.Cells(row, 2).Style.Font.ScriptPosition = ScriptPosition.Superscript

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Size ="
        ws.Cells(row, 2).Value = "18 * 20"
        ws.Cells(row, 2).Style.Font.Size = 18 * 20

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Strikeout ="
        ws.Cells(row, 2).Value = "true"
        ws.Cells(row, 2).Style.Font.Strikeout = True

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.UnderlineStyle ="
        ws.Cells(row, 2).Value = "UnderlineStyle.Double"
        ws.Cells(row, 2).Style.Font.UnderlineStyle = UnderlineStyle.Double

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Weight ="
        ws.Cells(row, 2).Value = "ExcelFont.BoldWeight"
        ws.Cells(row, 2).Style.Font.Weight = ExcelFont.BoldWeight

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.HorizontalAlignment ="
        ws.Cells(row, 2).Value = "HorizontalAlignmentStyle.Center"
        ws.Cells(row, 2).Style.HorizontalAlignment = HorizontalAlignmentStyle.Center

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Indent"
        ws.Cells(row, 2).Value = "five"
        ws.Cells(row, 2).Style.HorizontalAlignment = HorizontalAlignmentStyle.Left
        ws.Cells(row, 2).Style.Indent = 5

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.IsTextVertical = "
        ws.Cells(row, 2).Value = "true"
        <font color="Green">' Set row height to 50 points.</font>
        ws.Rows(row).Height = 50 * 20
        ws.Cells(row, 2).Style.IsTextVertical = True

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.NumberFormat"
        ws.Cells(row, 2).Value = 1234
        ws.Cells(row, 2).Style.NumberFormat = "#.##0,00 [$Krakozhian Money Units]"

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Rotation"
        ws.Cells(row, 2).Value = "35 degrees up"
        ws.Cells(row, 2).Style.Rotation = 35

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.ShrinkToFit"
        ws.Cells(row, 2).Value = "This property is set to true so this text appears shrunk."
        ws.Cells(row, 2).Style.ShrinkToFit = True

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.VerticalAlignment ="
        ws.Cells(row, 2).Value = "VerticalAlignmentStyle.Top"
        <font color="Green">' Set row height to 30 points.</font>
        ws.Rows(row).Height = 30 * 20
        ws.Cells(row, 2).Style.VerticalAlignment = VerticalAlignmentStyle.Top

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.WrapText"
        ws.Cells(row, 2).Value = "This property is set to true so this text appears broken into multiple lines."
        ws.Cells(row, 2).Style.WrapText = True
    End Sub
</code>
<code lang="C#">
	static void StylesSample(ExcelWorksheet ws)
	{
		ws.Cells[0,0].Value = "Cell style examples:";

		int row = 0;

		// Column width of 4, 30 and 35 characters.
		ws.Columns[0].Width = 4 * 256;
		ws.Columns[1].Width = 30 * 256;
		ws.Columns[2].Width = 35 * 256;

		ws.Cells[row+=2,1].Value = ".Style.Borders.SetBorders(...)";
		ws.Cells[row,2].Style.Borders.SetBorders(MultipleBorders.All, Color.FromArgb(252, 1, 1), LineStyle.Thin);

		ws.Cells[row+=2,1].Value = ".Style.FillPattern.SetPattern(...)";
		ws.Cells[row,2].Style.FillPattern.SetPattern(FillPatternStyle.ThinHorizontalCrosshatch, Color.Green, Color.Yellow);

		ws.Cells[row+=2,1].Value = ".Style.Font.Color =";
		ws.Cells[row,2].Value = "Color.Blue";
		ws.Cells[row,2].Style.Font.Color = Color.Blue;

		ws.Cells[row+=2,1].Value = ".Style.Font.Italic =";
		ws.Cells[row,2].Value = "true";
		ws.Cells[row,2].Style.Font.Italic = true;

		ws.Cells[row+=2,1].Value = ".Style.Font.Name =";
		ws.Cells[row,2].Value = "Comic Sans MS";
		ws.Cells[row,2].Style.Font.Name = "Comic Sans MS";

		ws.Cells[row+=2,1].Value = ".Style.Font.ScriptPosition =";
		ws.Cells[row,2].Value = "ScriptPosition.Superscript";
		ws.Cells[row,2].Style.Font.ScriptPosition = ScriptPosition.Superscript;

		ws.Cells[row+=2,1].Value = ".Style.Font.Size =";
		ws.Cells[row,2].Value = "18 * 20";
		ws.Cells[row,2].Style.Font.Size = 18 * 20;

		ws.Cells[row+=2,1].Value = ".Style.Font.Strikeout =";
		ws.Cells[row,2].Value = "true";
		ws.Cells[row,2].Style.Font.Strikeout = true;

		ws.Cells[row+=2,1].Value = ".Style.Font.UnderlineStyle =";
		ws.Cells[row,2].Value = "UnderlineStyle.Double";
		ws.Cells[row,2].Style.Font.UnderlineStyle = UnderlineStyle.Double;

		ws.Cells[row+=2,1].Value = ".Style.Font.Weight =";
		ws.Cells[row,2].Value = "ExcelFont.BoldWeight";
		ws.Cells[row,2].Style.Font.Weight = ExcelFont.BoldWeight;

		ws.Cells[row+=2,1].Value = ".Style.HorizontalAlignment =";
		ws.Cells[row,2].Value = "HorizontalAlignmentStyle.Center";
		ws.Cells[row,2].Style.HorizontalAlignment = HorizontalAlignmentStyle.Center;

		ws.Cells[row+=2,1].Value = ".Style.Indent";
		ws.Cells[row,2].Value = "five";
		ws.Cells[row,2].Style.HorizontalAlignment = HorizontalAlignmentStyle.Left;
		ws.Cells[row,2].Style.Indent = 5;

		ws.Cells[row+=2,1].Value = ".Style.IsTextVertical = ";
		ws.Cells[row,2].Value = "true";
		// Set row height to 50 points.
		ws.Rows[row].Height = 50 * 20;
		ws.Cells[row,2].Style.IsTextVertical = true;

		ws.Cells[row+=2,1].Value = ".Style.NumberFormat";
		ws.Cells[row,2].Value = 1234;
		ws.Cells[row,2].Style.NumberFormat = "#.##0,00 [$Krakozhian Money Units]";

		ws.Cells[row+=2,1].Value = ".Style.Rotation";
		ws.Cells[row,2].Value = "35 degrees up";
		ws.Cells[row,2].Style.Rotation = 35;

		ws.Cells[row+=2,1].Value = ".Style.ShrinkToFit";
		ws.Cells[row,2].Value = "This property is set to true so this text appears shrunk.";
		ws.Cells[row,2].Style.ShrinkToFit = true;

		ws.Cells[row+=2,1].Value = ".Style.VerticalAlignment =";
		ws.Cells[row,2].Value = "VerticalAlignmentStyle.Top";
		// Set row height to 30 points.
		ws.Rows[row].Height = 30 * 20;
		ws.Cells[row,2].Style.VerticalAlignment = VerticalAlignmentStyle.Top;

		ws.Cells[row+=2,1].Value = ".Style.WrapText";
		ws.Cells[row,2].Value = "This property is set to true so this text appears broken into multiple lines.";
		ws.Cells[row,2].Style.WrapText = true;
	}
</code> 
</example>
            <seealso cref="P:GemBox.Spreadsheet.CellStyle.IsTextVertical"/>
        </member>
        <member name="P:GemBox.Spreadsheet.CellStyle.IsTextVertical">
            <summary>
            Gets or sets whether the cell text is displayed in a vertical style.
            </summary>
            <remarks>
            <p>If <b>true</b> letters are stacked top-to-bottom.</p>
            <p>Because of Microsoft Excel limitations, this property 
            and <see cref="P:GemBox.Spreadsheet.CellStyle.Rotation">Rotation</see> property can't be used at the same time. 
            When set, <see cref="P:GemBox.Spreadsheet.CellStyle.Rotation">Rotation</see> property is set to 0. 
            If <see cref="P:GemBox.Spreadsheet.CellStyle.Rotation">Rotation</see> property is latter set to some non-zero value,
            this property will be set to <b>false</b>.</p>
            <p>Default value for this property is <b>false</b>.</p>
            </remarks>
            <example> Following code demonstrates various cell style properties:
<code lang="vbnet">
    Sub StylesSample(ByVal ws As ExcelWorksheet)
        ws.Cells(0, 0).Value = "Cell style examples:"

        Dim row As Integer = 0

        <font color="Green">' Column width of 4, 30 and 35 characters.</font>
        ws.Columns(0).Width = 4 * 256
        ws.Columns(1).Width = 30 * 256
        ws.Columns(2).Width = 35 * 256

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Borders.SetBorders(...)"
        ws.Cells(row, 2).Style.Borders.SetBorders(MultipleBorders.All, Color.FromArgb(252, 1, 1), LineStyle.Thin)

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.FillPattern.SetPattern(...)"
        ws.Cells(row, 2).Style.FillPattern.SetPattern(FillPatternStyle.ThinHorizontalCrosshatch, Color.Green, Color.Yellow)

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Color ="
        ws.Cells(row, 2).Value = "Color.Blue"
        ws.Cells(row, 2).Style.Font.Color = Color.Blue

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Italic ="
        ws.Cells(row, 2).Value = "true"
        ws.Cells(row, 2).Style.Font.Italic = True

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Name ="
        ws.Cells(row, 2).Value = "Comic Sans MS"
        ws.Cells(row, 2).Style.Font.Name = "Comic Sans MS"

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.ScriptPosition ="
        ws.Cells(row, 2).Value = "ScriptPosition.Superscript"
        ws.Cells(row, 2).Style.Font.ScriptPosition = ScriptPosition.Superscript

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Size ="
        ws.Cells(row, 2).Value = "18 * 20"
        ws.Cells(row, 2).Style.Font.Size = 18 * 20

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Strikeout ="
        ws.Cells(row, 2).Value = "true"
        ws.Cells(row, 2).Style.Font.Strikeout = True

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.UnderlineStyle ="
        ws.Cells(row, 2).Value = "UnderlineStyle.Double"
        ws.Cells(row, 2).Style.Font.UnderlineStyle = UnderlineStyle.Double

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Weight ="
        ws.Cells(row, 2).Value = "ExcelFont.BoldWeight"
        ws.Cells(row, 2).Style.Font.Weight = ExcelFont.BoldWeight

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.HorizontalAlignment ="
        ws.Cells(row, 2).Value = "HorizontalAlignmentStyle.Center"
        ws.Cells(row, 2).Style.HorizontalAlignment = HorizontalAlignmentStyle.Center

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Indent"
        ws.Cells(row, 2).Value = "five"
        ws.Cells(row, 2).Style.HorizontalAlignment = HorizontalAlignmentStyle.Left
        ws.Cells(row, 2).Style.Indent = 5

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.IsTextVertical = "
        ws.Cells(row, 2).Value = "true"
        <font color="Green">' Set row height to 50 points.</font>
        ws.Rows(row).Height = 50 * 20
        ws.Cells(row, 2).Style.IsTextVertical = True

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.NumberFormat"
        ws.Cells(row, 2).Value = 1234
        ws.Cells(row, 2).Style.NumberFormat = "#.##0,00 [$Krakozhian Money Units]"

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Rotation"
        ws.Cells(row, 2).Value = "35 degrees up"
        ws.Cells(row, 2).Style.Rotation = 35

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.ShrinkToFit"
        ws.Cells(row, 2).Value = "This property is set to true so this text appears shrunk."
        ws.Cells(row, 2).Style.ShrinkToFit = True

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.VerticalAlignment ="
        ws.Cells(row, 2).Value = "VerticalAlignmentStyle.Top"
        <font color="Green">' Set row height to 30 points.</font>
        ws.Rows(row).Height = 30 * 20
        ws.Cells(row, 2).Style.VerticalAlignment = VerticalAlignmentStyle.Top

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.WrapText"
        ws.Cells(row, 2).Value = "This property is set to true so this text appears broken into multiple lines."
        ws.Cells(row, 2).Style.WrapText = True
    End Sub
</code>
<code lang="C#">
	static void StylesSample(ExcelWorksheet ws)
	{
		ws.Cells[0,0].Value = "Cell style examples:";

		int row = 0;

		// Column width of 4, 30 and 35 characters.
		ws.Columns[0].Width = 4 * 256;
		ws.Columns[1].Width = 30 * 256;
		ws.Columns[2].Width = 35 * 256;

		ws.Cells[row+=2,1].Value = ".Style.Borders.SetBorders(...)";
		ws.Cells[row,2].Style.Borders.SetBorders(MultipleBorders.All, Color.FromArgb(252, 1, 1), LineStyle.Thin);

		ws.Cells[row+=2,1].Value = ".Style.FillPattern.SetPattern(...)";
		ws.Cells[row,2].Style.FillPattern.SetPattern(FillPatternStyle.ThinHorizontalCrosshatch, Color.Green, Color.Yellow);

		ws.Cells[row+=2,1].Value = ".Style.Font.Color =";
		ws.Cells[row,2].Value = "Color.Blue";
		ws.Cells[row,2].Style.Font.Color = Color.Blue;

		ws.Cells[row+=2,1].Value = ".Style.Font.Italic =";
		ws.Cells[row,2].Value = "true";
		ws.Cells[row,2].Style.Font.Italic = true;

		ws.Cells[row+=2,1].Value = ".Style.Font.Name =";
		ws.Cells[row,2].Value = "Comic Sans MS";
		ws.Cells[row,2].Style.Font.Name = "Comic Sans MS";

		ws.Cells[row+=2,1].Value = ".Style.Font.ScriptPosition =";
		ws.Cells[row,2].Value = "ScriptPosition.Superscript";
		ws.Cells[row,2].Style.Font.ScriptPosition = ScriptPosition.Superscript;

		ws.Cells[row+=2,1].Value = ".Style.Font.Size =";
		ws.Cells[row,2].Value = "18 * 20";
		ws.Cells[row,2].Style.Font.Size = 18 * 20;

		ws.Cells[row+=2,1].Value = ".Style.Font.Strikeout =";
		ws.Cells[row,2].Value = "true";
		ws.Cells[row,2].Style.Font.Strikeout = true;

		ws.Cells[row+=2,1].Value = ".Style.Font.UnderlineStyle =";
		ws.Cells[row,2].Value = "UnderlineStyle.Double";
		ws.Cells[row,2].Style.Font.UnderlineStyle = UnderlineStyle.Double;

		ws.Cells[row+=2,1].Value = ".Style.Font.Weight =";
		ws.Cells[row,2].Value = "ExcelFont.BoldWeight";
		ws.Cells[row,2].Style.Font.Weight = ExcelFont.BoldWeight;

		ws.Cells[row+=2,1].Value = ".Style.HorizontalAlignment =";
		ws.Cells[row,2].Value = "HorizontalAlignmentStyle.Center";
		ws.Cells[row,2].Style.HorizontalAlignment = HorizontalAlignmentStyle.Center;

		ws.Cells[row+=2,1].Value = ".Style.Indent";
		ws.Cells[row,2].Value = "five";
		ws.Cells[row,2].Style.HorizontalAlignment = HorizontalAlignmentStyle.Left;
		ws.Cells[row,2].Style.Indent = 5;

		ws.Cells[row+=2,1].Value = ".Style.IsTextVertical = ";
		ws.Cells[row,2].Value = "true";
		// Set row height to 50 points.
		ws.Rows[row].Height = 50 * 20;
		ws.Cells[row,2].Style.IsTextVertical = true;

		ws.Cells[row+=2,1].Value = ".Style.NumberFormat";
		ws.Cells[row,2].Value = 1234;
		ws.Cells[row,2].Style.NumberFormat = "#.##0,00 [$Krakozhian Money Units]";

		ws.Cells[row+=2,1].Value = ".Style.Rotation";
		ws.Cells[row,2].Value = "35 degrees up";
		ws.Cells[row,2].Style.Rotation = 35;

		ws.Cells[row+=2,1].Value = ".Style.ShrinkToFit";
		ws.Cells[row,2].Value = "This property is set to true so this text appears shrunk.";
		ws.Cells[row,2].Style.ShrinkToFit = true;

		ws.Cells[row+=2,1].Value = ".Style.VerticalAlignment =";
		ws.Cells[row,2].Value = "VerticalAlignmentStyle.Top";
		// Set row height to 30 points.
		ws.Rows[row].Height = 30 * 20;
		ws.Cells[row,2].Style.VerticalAlignment = VerticalAlignmentStyle.Top;

		ws.Cells[row+=2,1].Value = ".Style.WrapText";
		ws.Cells[row,2].Value = "This property is set to true so this text appears broken into multiple lines.";
		ws.Cells[row,2].Style.WrapText = true;
	}
</code> 
</example>
            <seealso cref="P:GemBox.Spreadsheet.CellStyle.Rotation"/>
        </member>
        <member name="P:GemBox.Spreadsheet.CellStyle.Locked">
            <summary>
            Gets or sets if the cell is locked.
            </summary>
            <remarks>
            <p>This property has meaning only if <see cref="P:GemBox.Spreadsheet.ExcelFile.Protected">ExcelFile.Protected</see> 
            or is <see cref="P:GemBox.Spreadsheet.ExcelWorksheet.Protected">ExcelWorksheet.Protected</see> set to <b>true</b>. For more information consult Microsoft Excel documentation.</p>
            <p>Default value for this property is <b>true</b>.</p>
            </remarks>
            <seealso cref="P:GemBox.Spreadsheet.ExcelFile.Protected">ExcelFile.Protected</seealso>
            <seealso cref="P:GemBox.Spreadsheet.ExcelWorksheet.Protected">ExcelWorksheet.Protected</seealso>
        </member>
        <member name="P:GemBox.Spreadsheet.CellStyle.FormulaHidden">
            <summary>
            Gets or sets whether the formula is hidden in the formula bar when the cell is selected.
            </summary>
            <remarks>
            <p>This property has meaning only if <see cref="P:GemBox.Spreadsheet.ExcelFile.Protected">ExcelFile.Protected</see> 
            is set to <b>true</b>. For more information consult Microsoft Excel documentation.</p>
            <p>Default value for this property is <b>false</b>.</p>
            </remarks>
            <seealso cref="P:GemBox.Spreadsheet.ExcelFile.Protected">ExcelFile.Protected</seealso>
        </member>
        <member name="P:GemBox.Spreadsheet.CellStyle.WrapText">
            <summary>
            Gets or sets if the text is wrapped.
            </summary>
            <remarks>
            <p>If set to <b>true</b>, wraps cell data into multiple lines in a cell. The number of wrapped lines is 
            dependent on the width of the column and the length of the cell contents.</p>
            Default value for this property is <b>false</b>.
            </remarks>
            <example> Following code demonstrates various cell style properties:
<code lang="vbnet">
    Sub StylesSample(ByVal ws As ExcelWorksheet)
        ws.Cells(0, 0).Value = "Cell style examples:"

        Dim row As Integer = 0

        <font color="Green">' Column width of 4, 30 and 35 characters.</font>
        ws.Columns(0).Width = 4 * 256
        ws.Columns(1).Width = 30 * 256
        ws.Columns(2).Width = 35 * 256

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Borders.SetBorders(...)"
        ws.Cells(row, 2).Style.Borders.SetBorders(MultipleBorders.All, Color.FromArgb(252, 1, 1), LineStyle.Thin)

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.FillPattern.SetPattern(...)"
        ws.Cells(row, 2).Style.FillPattern.SetPattern(FillPatternStyle.ThinHorizontalCrosshatch, Color.Green, Color.Yellow)

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Color ="
        ws.Cells(row, 2).Value = "Color.Blue"
        ws.Cells(row, 2).Style.Font.Color = Color.Blue

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Italic ="
        ws.Cells(row, 2).Value = "true"
        ws.Cells(row, 2).Style.Font.Italic = True

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Name ="
        ws.Cells(row, 2).Value = "Comic Sans MS"
        ws.Cells(row, 2).Style.Font.Name = "Comic Sans MS"

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.ScriptPosition ="
        ws.Cells(row, 2).Value = "ScriptPosition.Superscript"
        ws.Cells(row, 2).Style.Font.ScriptPosition = ScriptPosition.Superscript

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Size ="
        ws.Cells(row, 2).Value = "18 * 20"
        ws.Cells(row, 2).Style.Font.Size = 18 * 20

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Strikeout ="
        ws.Cells(row, 2).Value = "true"
        ws.Cells(row, 2).Style.Font.Strikeout = True

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.UnderlineStyle ="
        ws.Cells(row, 2).Value = "UnderlineStyle.Double"
        ws.Cells(row, 2).Style.Font.UnderlineStyle = UnderlineStyle.Double

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Weight ="
        ws.Cells(row, 2).Value = "ExcelFont.BoldWeight"
        ws.Cells(row, 2).Style.Font.Weight = ExcelFont.BoldWeight

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.HorizontalAlignment ="
        ws.Cells(row, 2).Value = "HorizontalAlignmentStyle.Center"
        ws.Cells(row, 2).Style.HorizontalAlignment = HorizontalAlignmentStyle.Center

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Indent"
        ws.Cells(row, 2).Value = "five"
        ws.Cells(row, 2).Style.HorizontalAlignment = HorizontalAlignmentStyle.Left
        ws.Cells(row, 2).Style.Indent = 5

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.IsTextVertical = "
        ws.Cells(row, 2).Value = "true"
        <font color="Green">' Set row height to 50 points.</font>
        ws.Rows(row).Height = 50 * 20
        ws.Cells(row, 2).Style.IsTextVertical = True

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.NumberFormat"
        ws.Cells(row, 2).Value = 1234
        ws.Cells(row, 2).Style.NumberFormat = "#.##0,00 [$Krakozhian Money Units]"

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Rotation"
        ws.Cells(row, 2).Value = "35 degrees up"
        ws.Cells(row, 2).Style.Rotation = 35

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.ShrinkToFit"
        ws.Cells(row, 2).Value = "This property is set to true so this text appears shrunk."
        ws.Cells(row, 2).Style.ShrinkToFit = True

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.VerticalAlignment ="
        ws.Cells(row, 2).Value = "VerticalAlignmentStyle.Top"
        <font color="Green">' Set row height to 30 points.</font>
        ws.Rows(row).Height = 30 * 20
        ws.Cells(row, 2).Style.VerticalAlignment = VerticalAlignmentStyle.Top

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.WrapText"
        ws.Cells(row, 2).Value = "This property is set to true so this text appears broken into multiple lines."
        ws.Cells(row, 2).Style.WrapText = True
    End Sub
</code>
<code lang="C#">
	static void StylesSample(ExcelWorksheet ws)
	{
		ws.Cells[0,0].Value = "Cell style examples:";

		int row = 0;

		// Column width of 4, 30 and 35 characters.
		ws.Columns[0].Width = 4 * 256;
		ws.Columns[1].Width = 30 * 256;
		ws.Columns[2].Width = 35 * 256;

		ws.Cells[row+=2,1].Value = ".Style.Borders.SetBorders(...)";
		ws.Cells[row,2].Style.Borders.SetBorders(MultipleBorders.All, Color.FromArgb(252, 1, 1), LineStyle.Thin);

		ws.Cells[row+=2,1].Value = ".Style.FillPattern.SetPattern(...)";
		ws.Cells[row,2].Style.FillPattern.SetPattern(FillPatternStyle.ThinHorizontalCrosshatch, Color.Green, Color.Yellow);

		ws.Cells[row+=2,1].Value = ".Style.Font.Color =";
		ws.Cells[row,2].Value = "Color.Blue";
		ws.Cells[row,2].Style.Font.Color = Color.Blue;

		ws.Cells[row+=2,1].Value = ".Style.Font.Italic =";
		ws.Cells[row,2].Value = "true";
		ws.Cells[row,2].Style.Font.Italic = true;

		ws.Cells[row+=2,1].Value = ".Style.Font.Name =";
		ws.Cells[row,2].Value = "Comic Sans MS";
		ws.Cells[row,2].Style.Font.Name = "Comic Sans MS";

		ws.Cells[row+=2,1].Value = ".Style.Font.ScriptPosition =";
		ws.Cells[row,2].Value = "ScriptPosition.Superscript";
		ws.Cells[row,2].Style.Font.ScriptPosition = ScriptPosition.Superscript;

		ws.Cells[row+=2,1].Value = ".Style.Font.Size =";
		ws.Cells[row,2].Value = "18 * 20";
		ws.Cells[row,2].Style.Font.Size = 18 * 20;

		ws.Cells[row+=2,1].Value = ".Style.Font.Strikeout =";
		ws.Cells[row,2].Value = "true";
		ws.Cells[row,2].Style.Font.Strikeout = true;

		ws.Cells[row+=2,1].Value = ".Style.Font.UnderlineStyle =";
		ws.Cells[row,2].Value = "UnderlineStyle.Double";
		ws.Cells[row,2].Style.Font.UnderlineStyle = UnderlineStyle.Double;

		ws.Cells[row+=2,1].Value = ".Style.Font.Weight =";
		ws.Cells[row,2].Value = "ExcelFont.BoldWeight";
		ws.Cells[row,2].Style.Font.Weight = ExcelFont.BoldWeight;

		ws.Cells[row+=2,1].Value = ".Style.HorizontalAlignment =";
		ws.Cells[row,2].Value = "HorizontalAlignmentStyle.Center";
		ws.Cells[row,2].Style.HorizontalAlignment = HorizontalAlignmentStyle.Center;

		ws.Cells[row+=2,1].Value = ".Style.Indent";
		ws.Cells[row,2].Value = "five";
		ws.Cells[row,2].Style.HorizontalAlignment = HorizontalAlignmentStyle.Left;
		ws.Cells[row,2].Style.Indent = 5;

		ws.Cells[row+=2,1].Value = ".Style.IsTextVertical = ";
		ws.Cells[row,2].Value = "true";
		// Set row height to 50 points.
		ws.Rows[row].Height = 50 * 20;
		ws.Cells[row,2].Style.IsTextVertical = true;

		ws.Cells[row+=2,1].Value = ".Style.NumberFormat";
		ws.Cells[row,2].Value = 1234;
		ws.Cells[row,2].Style.NumberFormat = "#.##0,00 [$Krakozhian Money Units]";

		ws.Cells[row+=2,1].Value = ".Style.Rotation";
		ws.Cells[row,2].Value = "35 degrees up";
		ws.Cells[row,2].Style.Rotation = 35;

		ws.Cells[row+=2,1].Value = ".Style.ShrinkToFit";
		ws.Cells[row,2].Value = "This property is set to true so this text appears shrunk.";
		ws.Cells[row,2].Style.ShrinkToFit = true;

		ws.Cells[row+=2,1].Value = ".Style.VerticalAlignment =";
		ws.Cells[row,2].Value = "VerticalAlignmentStyle.Top";
		// Set row height to 30 points.
		ws.Rows[row].Height = 30 * 20;
		ws.Cells[row,2].Style.VerticalAlignment = VerticalAlignmentStyle.Top;

		ws.Cells[row+=2,1].Value = ".Style.WrapText";
		ws.Cells[row,2].Value = "This property is set to true so this text appears broken into multiple lines.";
		ws.Cells[row,2].Style.WrapText = true;
	}
</code> 
</example>
        </member>
        <member name="P:GemBox.Spreadsheet.CellStyle.ShrinkToFit">
            <summary>
            Gets or sets if the cell text is shrunk to fit the cell.
            </summary>
            <remarks>
            <p>If set to <b>true</b>, reduces the apparent size of font characters so that all data in a selected 
            cell fits within the column. For more information consult Microsoft Excel documentation.</p>
            Default value for this property is <b>false</b>.
            </remarks>
            <example> Following code demonstrates various cell style properties:
<code lang="vbnet">
    Sub StylesSample(ByVal ws As ExcelWorksheet)
        ws.Cells(0, 0).Value = "Cell style examples:"

        Dim row As Integer = 0

        <font color="Green">' Column width of 4, 30 and 35 characters.</font>
        ws.Columns(0).Width = 4 * 256
        ws.Columns(1).Width = 30 * 256
        ws.Columns(2).Width = 35 * 256

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Borders.SetBorders(...)"
        ws.Cells(row, 2).Style.Borders.SetBorders(MultipleBorders.All, Color.FromArgb(252, 1, 1), LineStyle.Thin)

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.FillPattern.SetPattern(...)"
        ws.Cells(row, 2).Style.FillPattern.SetPattern(FillPatternStyle.ThinHorizontalCrosshatch, Color.Green, Color.Yellow)

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Color ="
        ws.Cells(row, 2).Value = "Color.Blue"
        ws.Cells(row, 2).Style.Font.Color = Color.Blue

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Italic ="
        ws.Cells(row, 2).Value = "true"
        ws.Cells(row, 2).Style.Font.Italic = True

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Name ="
        ws.Cells(row, 2).Value = "Comic Sans MS"
        ws.Cells(row, 2).Style.Font.Name = "Comic Sans MS"

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.ScriptPosition ="
        ws.Cells(row, 2).Value = "ScriptPosition.Superscript"
        ws.Cells(row, 2).Style.Font.ScriptPosition = ScriptPosition.Superscript

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Size ="
        ws.Cells(row, 2).Value = "18 * 20"
        ws.Cells(row, 2).Style.Font.Size = 18 * 20

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Strikeout ="
        ws.Cells(row, 2).Value = "true"
        ws.Cells(row, 2).Style.Font.Strikeout = True

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.UnderlineStyle ="
        ws.Cells(row, 2).Value = "UnderlineStyle.Double"
        ws.Cells(row, 2).Style.Font.UnderlineStyle = UnderlineStyle.Double

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Weight ="
        ws.Cells(row, 2).Value = "ExcelFont.BoldWeight"
        ws.Cells(row, 2).Style.Font.Weight = ExcelFont.BoldWeight

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.HorizontalAlignment ="
        ws.Cells(row, 2).Value = "HorizontalAlignmentStyle.Center"
        ws.Cells(row, 2).Style.HorizontalAlignment = HorizontalAlignmentStyle.Center

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Indent"
        ws.Cells(row, 2).Value = "five"
        ws.Cells(row, 2).Style.HorizontalAlignment = HorizontalAlignmentStyle.Left
        ws.Cells(row, 2).Style.Indent = 5

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.IsTextVertical = "
        ws.Cells(row, 2).Value = "true"
        <font color="Green">' Set row height to 50 points.</font>
        ws.Rows(row).Height = 50 * 20
        ws.Cells(row, 2).Style.IsTextVertical = True

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.NumberFormat"
        ws.Cells(row, 2).Value = 1234
        ws.Cells(row, 2).Style.NumberFormat = "#.##0,00 [$Krakozhian Money Units]"

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Rotation"
        ws.Cells(row, 2).Value = "35 degrees up"
        ws.Cells(row, 2).Style.Rotation = 35

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.ShrinkToFit"
        ws.Cells(row, 2).Value = "This property is set to true so this text appears shrunk."
        ws.Cells(row, 2).Style.ShrinkToFit = True

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.VerticalAlignment ="
        ws.Cells(row, 2).Value = "VerticalAlignmentStyle.Top"
        <font color="Green">' Set row height to 30 points.</font>
        ws.Rows(row).Height = 30 * 20
        ws.Cells(row, 2).Style.VerticalAlignment = VerticalAlignmentStyle.Top

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.WrapText"
        ws.Cells(row, 2).Value = "This property is set to true so this text appears broken into multiple lines."
        ws.Cells(row, 2).Style.WrapText = True
    End Sub
</code>
<code lang="C#">
	static void StylesSample(ExcelWorksheet ws)
	{
		ws.Cells[0,0].Value = "Cell style examples:";

		int row = 0;

		// Column width of 4, 30 and 35 characters.
		ws.Columns[0].Width = 4 * 256;
		ws.Columns[1].Width = 30 * 256;
		ws.Columns[2].Width = 35 * 256;

		ws.Cells[row+=2,1].Value = ".Style.Borders.SetBorders(...)";
		ws.Cells[row,2].Style.Borders.SetBorders(MultipleBorders.All, Color.FromArgb(252, 1, 1), LineStyle.Thin);

		ws.Cells[row+=2,1].Value = ".Style.FillPattern.SetPattern(...)";
		ws.Cells[row,2].Style.FillPattern.SetPattern(FillPatternStyle.ThinHorizontalCrosshatch, Color.Green, Color.Yellow);

		ws.Cells[row+=2,1].Value = ".Style.Font.Color =";
		ws.Cells[row,2].Value = "Color.Blue";
		ws.Cells[row,2].Style.Font.Color = Color.Blue;

		ws.Cells[row+=2,1].Value = ".Style.Font.Italic =";
		ws.Cells[row,2].Value = "true";
		ws.Cells[row,2].Style.Font.Italic = true;

		ws.Cells[row+=2,1].Value = ".Style.Font.Name =";
		ws.Cells[row,2].Value = "Comic Sans MS";
		ws.Cells[row,2].Style.Font.Name = "Comic Sans MS";

		ws.Cells[row+=2,1].Value = ".Style.Font.ScriptPosition =";
		ws.Cells[row,2].Value = "ScriptPosition.Superscript";
		ws.Cells[row,2].Style.Font.ScriptPosition = ScriptPosition.Superscript;

		ws.Cells[row+=2,1].Value = ".Style.Font.Size =";
		ws.Cells[row,2].Value = "18 * 20";
		ws.Cells[row,2].Style.Font.Size = 18 * 20;

		ws.Cells[row+=2,1].Value = ".Style.Font.Strikeout =";
		ws.Cells[row,2].Value = "true";
		ws.Cells[row,2].Style.Font.Strikeout = true;

		ws.Cells[row+=2,1].Value = ".Style.Font.UnderlineStyle =";
		ws.Cells[row,2].Value = "UnderlineStyle.Double";
		ws.Cells[row,2].Style.Font.UnderlineStyle = UnderlineStyle.Double;

		ws.Cells[row+=2,1].Value = ".Style.Font.Weight =";
		ws.Cells[row,2].Value = "ExcelFont.BoldWeight";
		ws.Cells[row,2].Style.Font.Weight = ExcelFont.BoldWeight;

		ws.Cells[row+=2,1].Value = ".Style.HorizontalAlignment =";
		ws.Cells[row,2].Value = "HorizontalAlignmentStyle.Center";
		ws.Cells[row,2].Style.HorizontalAlignment = HorizontalAlignmentStyle.Center;

		ws.Cells[row+=2,1].Value = ".Style.Indent";
		ws.Cells[row,2].Value = "five";
		ws.Cells[row,2].Style.HorizontalAlignment = HorizontalAlignmentStyle.Left;
		ws.Cells[row,2].Style.Indent = 5;

		ws.Cells[row+=2,1].Value = ".Style.IsTextVertical = ";
		ws.Cells[row,2].Value = "true";
		// Set row height to 50 points.
		ws.Rows[row].Height = 50 * 20;
		ws.Cells[row,2].Style.IsTextVertical = true;

		ws.Cells[row+=2,1].Value = ".Style.NumberFormat";
		ws.Cells[row,2].Value = 1234;
		ws.Cells[row,2].Style.NumberFormat = "#.##0,00 [$Krakozhian Money Units]";

		ws.Cells[row+=2,1].Value = ".Style.Rotation";
		ws.Cells[row,2].Value = "35 degrees up";
		ws.Cells[row,2].Style.Rotation = 35;

		ws.Cells[row+=2,1].Value = ".Style.ShrinkToFit";
		ws.Cells[row,2].Value = "This property is set to true so this text appears shrunk.";
		ws.Cells[row,2].Style.ShrinkToFit = true;

		ws.Cells[row+=2,1].Value = ".Style.VerticalAlignment =";
		ws.Cells[row,2].Value = "VerticalAlignmentStyle.Top";
		// Set row height to 30 points.
		ws.Rows[row].Height = 30 * 20;
		ws.Cells[row,2].Style.VerticalAlignment = VerticalAlignmentStyle.Top;

		ws.Cells[row+=2,1].Value = ".Style.WrapText";
		ws.Cells[row,2].Value = "This property is set to true so this text appears broken into multiple lines.";
		ws.Cells[row,2].Style.WrapText = true;
	}
</code> 
</example>
        </member>
        <member name="P:GemBox.Spreadsheet.CellStyle.NumberFormat">
            <summary>
            Gets or sets format string that will be used to interpret and display cell value.
            </summary>
            <remarks>
            <p>If the value of this property is <see cref="F:System.String.Empty">String.Empty</see> and 
            <see cref="P:GemBox.Spreadsheet.ExcelCell.Value">ExcelCell.Value</see> is of 
            <see cref="T:System.DateTime">DateTime</see> type, 
            ISO date/time format will be used as number format.</p>
            <p>
            Custom  number format has to be in invariant culture format.
            </p>
            <p>
            Example:
            </p>
            <p>
            <font face="Arial" size="1">
            <table border="1" cellpadding="5" cellspacing="0" ID="Table1">
            <tr>
            <td><b>Format string</b></td>
            <td><b>Value</b></td>
            <td><b>Output</b></td>
            </tr>
            <tr>
            <td>#####</td>
            <td>123</td>
            <td>123</td>
            </tr>
            <tr>
            <td>00000</td>
            <td>123</td>
            <td>00123</td>
            </tr>
            <tr>
            <td>#,#</td>
            <td>1234567890</td>
            <td>1,234,567,890</td>
            </tr>
            <tr>
            <td>00.00</td>
            <td>1.2</td>
            <td>01.20</td>
            </tr>
            <tr>
            <td>#,##0.00</td>
            <td>1234567890</td>
            <td>1,234,567,890.00</td>
            </tr>
            <tr>
            <td>#0.##%</td>
            <td>0.092</td>
            <td>9.2%</td>
            </tr>
            </table>
            </font>
            </p>
            <p>For more information on number format strings consult Microsoft Excel documentation.</p>
            Default value for this property is <see cref="F:System.String.Empty">String.Empty</see>.
            </remarks>
            <example> Following code demonstrates various cell style properties:
<code lang="vbnet">
    Sub StylesSample(ByVal ws As ExcelWorksheet)
        ws.Cells(0, 0).Value = "Cell style examples:"

        Dim row As Integer = 0

        <font color="Green">' Column width of 4, 30 and 35 characters.</font>
        ws.Columns(0).Width = 4 * 256
        ws.Columns(1).Width = 30 * 256
        ws.Columns(2).Width = 35 * 256

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Borders.SetBorders(...)"
        ws.Cells(row, 2).Style.Borders.SetBorders(MultipleBorders.All, Color.FromArgb(252, 1, 1), LineStyle.Thin)

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.FillPattern.SetPattern(...)"
        ws.Cells(row, 2).Style.FillPattern.SetPattern(FillPatternStyle.ThinHorizontalCrosshatch, Color.Green, Color.Yellow)

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Color ="
        ws.Cells(row, 2).Value = "Color.Blue"
        ws.Cells(row, 2).Style.Font.Color = Color.Blue

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Italic ="
        ws.Cells(row, 2).Value = "true"
        ws.Cells(row, 2).Style.Font.Italic = True

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Name ="
        ws.Cells(row, 2).Value = "Comic Sans MS"
        ws.Cells(row, 2).Style.Font.Name = "Comic Sans MS"

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.ScriptPosition ="
        ws.Cells(row, 2).Value = "ScriptPosition.Superscript"
        ws.Cells(row, 2).Style.Font.ScriptPosition = ScriptPosition.Superscript

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Size ="
        ws.Cells(row, 2).Value = "18 * 20"
        ws.Cells(row, 2).Style.Font.Size = 18 * 20

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Strikeout ="
        ws.Cells(row, 2).Value = "true"
        ws.Cells(row, 2).Style.Font.Strikeout = True

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.UnderlineStyle ="
        ws.Cells(row, 2).Value = "UnderlineStyle.Double"
        ws.Cells(row, 2).Style.Font.UnderlineStyle = UnderlineStyle.Double

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Weight ="
        ws.Cells(row, 2).Value = "ExcelFont.BoldWeight"
        ws.Cells(row, 2).Style.Font.Weight = ExcelFont.BoldWeight

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.HorizontalAlignment ="
        ws.Cells(row, 2).Value = "HorizontalAlignmentStyle.Center"
        ws.Cells(row, 2).Style.HorizontalAlignment = HorizontalAlignmentStyle.Center

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Indent"
        ws.Cells(row, 2).Value = "five"
        ws.Cells(row, 2).Style.HorizontalAlignment = HorizontalAlignmentStyle.Left
        ws.Cells(row, 2).Style.Indent = 5

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.IsTextVertical = "
        ws.Cells(row, 2).Value = "true"
        <font color="Green">' Set row height to 50 points.</font>
        ws.Rows(row).Height = 50 * 20
        ws.Cells(row, 2).Style.IsTextVertical = True

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.NumberFormat"
        ws.Cells(row, 2).Value = 1234
        ws.Cells(row, 2).Style.NumberFormat = "#.##0,00 [$Krakozhian Money Units]"

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Rotation"
        ws.Cells(row, 2).Value = "35 degrees up"
        ws.Cells(row, 2).Style.Rotation = 35

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.ShrinkToFit"
        ws.Cells(row, 2).Value = "This property is set to true so this text appears shrunk."
        ws.Cells(row, 2).Style.ShrinkToFit = True

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.VerticalAlignment ="
        ws.Cells(row, 2).Value = "VerticalAlignmentStyle.Top"
        <font color="Green">' Set row height to 30 points.</font>
        ws.Rows(row).Height = 30 * 20
        ws.Cells(row, 2).Style.VerticalAlignment = VerticalAlignmentStyle.Top

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.WrapText"
        ws.Cells(row, 2).Value = "This property is set to true so this text appears broken into multiple lines."
        ws.Cells(row, 2).Style.WrapText = True
    End Sub
</code>
<code lang="C#">
	static void StylesSample(ExcelWorksheet ws)
	{
		ws.Cells[0,0].Value = "Cell style examples:";

		int row = 0;

		// Column width of 4, 30 and 35 characters.
		ws.Columns[0].Width = 4 * 256;
		ws.Columns[1].Width = 30 * 256;
		ws.Columns[2].Width = 35 * 256;

		ws.Cells[row+=2,1].Value = ".Style.Borders.SetBorders(...)";
		ws.Cells[row,2].Style.Borders.SetBorders(MultipleBorders.All, Color.FromArgb(252, 1, 1), LineStyle.Thin);

		ws.Cells[row+=2,1].Value = ".Style.FillPattern.SetPattern(...)";
		ws.Cells[row,2].Style.FillPattern.SetPattern(FillPatternStyle.ThinHorizontalCrosshatch, Color.Green, Color.Yellow);

		ws.Cells[row+=2,1].Value = ".Style.Font.Color =";
		ws.Cells[row,2].Value = "Color.Blue";
		ws.Cells[row,2].Style.Font.Color = Color.Blue;

		ws.Cells[row+=2,1].Value = ".Style.Font.Italic =";
		ws.Cells[row,2].Value = "true";
		ws.Cells[row,2].Style.Font.Italic = true;

		ws.Cells[row+=2,1].Value = ".Style.Font.Name =";
		ws.Cells[row,2].Value = "Comic Sans MS";
		ws.Cells[row,2].Style.Font.Name = "Comic Sans MS";

		ws.Cells[row+=2,1].Value = ".Style.Font.ScriptPosition =";
		ws.Cells[row,2].Value = "ScriptPosition.Superscript";
		ws.Cells[row,2].Style.Font.ScriptPosition = ScriptPosition.Superscript;

		ws.Cells[row+=2,1].Value = ".Style.Font.Size =";
		ws.Cells[row,2].Value = "18 * 20";
		ws.Cells[row,2].Style.Font.Size = 18 * 20;

		ws.Cells[row+=2,1].Value = ".Style.Font.Strikeout =";
		ws.Cells[row,2].Value = "true";
		ws.Cells[row,2].Style.Font.Strikeout = true;

		ws.Cells[row+=2,1].Value = ".Style.Font.UnderlineStyle =";
		ws.Cells[row,2].Value = "UnderlineStyle.Double";
		ws.Cells[row,2].Style.Font.UnderlineStyle = UnderlineStyle.Double;

		ws.Cells[row+=2,1].Value = ".Style.Font.Weight =";
		ws.Cells[row,2].Value = "ExcelFont.BoldWeight";
		ws.Cells[row,2].Style.Font.Weight = ExcelFont.BoldWeight;

		ws.Cells[row+=2,1].Value = ".Style.HorizontalAlignment =";
		ws.Cells[row,2].Value = "HorizontalAlignmentStyle.Center";
		ws.Cells[row,2].Style.HorizontalAlignment = HorizontalAlignmentStyle.Center;

		ws.Cells[row+=2,1].Value = ".Style.Indent";
		ws.Cells[row,2].Value = "five";
		ws.Cells[row,2].Style.HorizontalAlignment = HorizontalAlignmentStyle.Left;
		ws.Cells[row,2].Style.Indent = 5;

		ws.Cells[row+=2,1].Value = ".Style.IsTextVertical = ";
		ws.Cells[row,2].Value = "true";
		// Set row height to 50 points.
		ws.Rows[row].Height = 50 * 20;
		ws.Cells[row,2].Style.IsTextVertical = true;

		ws.Cells[row+=2,1].Value = ".Style.NumberFormat";
		ws.Cells[row,2].Value = 1234;
		ws.Cells[row,2].Style.NumberFormat = "#.##0,00 [$Krakozhian Money Units]";

		ws.Cells[row+=2,1].Value = ".Style.Rotation";
		ws.Cells[row,2].Value = "35 degrees up";
		ws.Cells[row,2].Style.Rotation = 35;

		ws.Cells[row+=2,1].Value = ".Style.ShrinkToFit";
		ws.Cells[row,2].Value = "This property is set to true so this text appears shrunk.";
		ws.Cells[row,2].Style.ShrinkToFit = true;

		ws.Cells[row+=2,1].Value = ".Style.VerticalAlignment =";
		ws.Cells[row,2].Value = "VerticalAlignmentStyle.Top";
		// Set row height to 30 points.
		ws.Rows[row].Height = 30 * 20;
		ws.Cells[row,2].Style.VerticalAlignment = VerticalAlignmentStyle.Top;

		ws.Cells[row+=2,1].Value = ".Style.WrapText";
		ws.Cells[row,2].Value = "This property is set to true so this text appears broken into multiple lines.";
		ws.Cells[row,2].Style.WrapText = true;
	}
</code> 
</example>
        </member>
        <member name="P:GemBox.Spreadsheet.CellStyle.Font">
            <summary>
            Gets or sets font related settings.
            </summary>
            <example> Following code demonstrates various cell style properties:
<code lang="vbnet">
    Sub StylesSample(ByVal ws As ExcelWorksheet)
        ws.Cells(0, 0).Value = "Cell style examples:"

        Dim row As Integer = 0

        <font color="Green">' Column width of 4, 30 and 35 characters.</font>
        ws.Columns(0).Width = 4 * 256
        ws.Columns(1).Width = 30 * 256
        ws.Columns(2).Width = 35 * 256

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Borders.SetBorders(...)"
        ws.Cells(row, 2).Style.Borders.SetBorders(MultipleBorders.All, Color.FromArgb(252, 1, 1), LineStyle.Thin)

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.FillPattern.SetPattern(...)"
        ws.Cells(row, 2).Style.FillPattern.SetPattern(FillPatternStyle.ThinHorizontalCrosshatch, Color.Green, Color.Yellow)

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Color ="
        ws.Cells(row, 2).Value = "Color.Blue"
        ws.Cells(row, 2).Style.Font.Color = Color.Blue

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Italic ="
        ws.Cells(row, 2).Value = "true"
        ws.Cells(row, 2).Style.Font.Italic = True

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Name ="
        ws.Cells(row, 2).Value = "Comic Sans MS"
        ws.Cells(row, 2).Style.Font.Name = "Comic Sans MS"

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.ScriptPosition ="
        ws.Cells(row, 2).Value = "ScriptPosition.Superscript"
        ws.Cells(row, 2).Style.Font.ScriptPosition = ScriptPosition.Superscript

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Size ="
        ws.Cells(row, 2).Value = "18 * 20"
        ws.Cells(row, 2).Style.Font.Size = 18 * 20

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Strikeout ="
        ws.Cells(row, 2).Value = "true"
        ws.Cells(row, 2).Style.Font.Strikeout = True

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.UnderlineStyle ="
        ws.Cells(row, 2).Value = "UnderlineStyle.Double"
        ws.Cells(row, 2).Style.Font.UnderlineStyle = UnderlineStyle.Double

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Weight ="
        ws.Cells(row, 2).Value = "ExcelFont.BoldWeight"
        ws.Cells(row, 2).Style.Font.Weight = ExcelFont.BoldWeight

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.HorizontalAlignment ="
        ws.Cells(row, 2).Value = "HorizontalAlignmentStyle.Center"
        ws.Cells(row, 2).Style.HorizontalAlignment = HorizontalAlignmentStyle.Center

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Indent"
        ws.Cells(row, 2).Value = "five"
        ws.Cells(row, 2).Style.HorizontalAlignment = HorizontalAlignmentStyle.Left
        ws.Cells(row, 2).Style.Indent = 5

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.IsTextVertical = "
        ws.Cells(row, 2).Value = "true"
        <font color="Green">' Set row height to 50 points.</font>
        ws.Rows(row).Height = 50 * 20
        ws.Cells(row, 2).Style.IsTextVertical = True

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.NumberFormat"
        ws.Cells(row, 2).Value = 1234
        ws.Cells(row, 2).Style.NumberFormat = "#.##0,00 [$Krakozhian Money Units]"

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Rotation"
        ws.Cells(row, 2).Value = "35 degrees up"
        ws.Cells(row, 2).Style.Rotation = 35

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.ShrinkToFit"
        ws.Cells(row, 2).Value = "This property is set to true so this text appears shrunk."
        ws.Cells(row, 2).Style.ShrinkToFit = True

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.VerticalAlignment ="
        ws.Cells(row, 2).Value = "VerticalAlignmentStyle.Top"
        <font color="Green">' Set row height to 30 points.</font>
        ws.Rows(row).Height = 30 * 20
        ws.Cells(row, 2).Style.VerticalAlignment = VerticalAlignmentStyle.Top

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.WrapText"
        ws.Cells(row, 2).Value = "This property is set to true so this text appears broken into multiple lines."
        ws.Cells(row, 2).Style.WrapText = True
    End Sub
</code>
<code lang="C#">
	static void StylesSample(ExcelWorksheet ws)
	{
		ws.Cells[0,0].Value = "Cell style examples:";

		int row = 0;

		// Column width of 4, 30 and 35 characters.
		ws.Columns[0].Width = 4 * 256;
		ws.Columns[1].Width = 30 * 256;
		ws.Columns[2].Width = 35 * 256;

		ws.Cells[row+=2,1].Value = ".Style.Borders.SetBorders(...)";
		ws.Cells[row,2].Style.Borders.SetBorders(MultipleBorders.All, Color.FromArgb(252, 1, 1), LineStyle.Thin);

		ws.Cells[row+=2,1].Value = ".Style.FillPattern.SetPattern(...)";
		ws.Cells[row,2].Style.FillPattern.SetPattern(FillPatternStyle.ThinHorizontalCrosshatch, Color.Green, Color.Yellow);

		ws.Cells[row+=2,1].Value = ".Style.Font.Color =";
		ws.Cells[row,2].Value = "Color.Blue";
		ws.Cells[row,2].Style.Font.Color = Color.Blue;

		ws.Cells[row+=2,1].Value = ".Style.Font.Italic =";
		ws.Cells[row,2].Value = "true";
		ws.Cells[row,2].Style.Font.Italic = true;

		ws.Cells[row+=2,1].Value = ".Style.Font.Name =";
		ws.Cells[row,2].Value = "Comic Sans MS";
		ws.Cells[row,2].Style.Font.Name = "Comic Sans MS";

		ws.Cells[row+=2,1].Value = ".Style.Font.ScriptPosition =";
		ws.Cells[row,2].Value = "ScriptPosition.Superscript";
		ws.Cells[row,2].Style.Font.ScriptPosition = ScriptPosition.Superscript;

		ws.Cells[row+=2,1].Value = ".Style.Font.Size =";
		ws.Cells[row,2].Value = "18 * 20";
		ws.Cells[row,2].Style.Font.Size = 18 * 20;

		ws.Cells[row+=2,1].Value = ".Style.Font.Strikeout =";
		ws.Cells[row,2].Value = "true";
		ws.Cells[row,2].Style.Font.Strikeout = true;

		ws.Cells[row+=2,1].Value = ".Style.Font.UnderlineStyle =";
		ws.Cells[row,2].Value = "UnderlineStyle.Double";
		ws.Cells[row,2].Style.Font.UnderlineStyle = UnderlineStyle.Double;

		ws.Cells[row+=2,1].Value = ".Style.Font.Weight =";
		ws.Cells[row,2].Value = "ExcelFont.BoldWeight";
		ws.Cells[row,2].Style.Font.Weight = ExcelFont.BoldWeight;

		ws.Cells[row+=2,1].Value = ".Style.HorizontalAlignment =";
		ws.Cells[row,2].Value = "HorizontalAlignmentStyle.Center";
		ws.Cells[row,2].Style.HorizontalAlignment = HorizontalAlignmentStyle.Center;

		ws.Cells[row+=2,1].Value = ".Style.Indent";
		ws.Cells[row,2].Value = "five";
		ws.Cells[row,2].Style.HorizontalAlignment = HorizontalAlignmentStyle.Left;
		ws.Cells[row,2].Style.Indent = 5;

		ws.Cells[row+=2,1].Value = ".Style.IsTextVertical = ";
		ws.Cells[row,2].Value = "true";
		// Set row height to 50 points.
		ws.Rows[row].Height = 50 * 20;
		ws.Cells[row,2].Style.IsTextVertical = true;

		ws.Cells[row+=2,1].Value = ".Style.NumberFormat";
		ws.Cells[row,2].Value = 1234;
		ws.Cells[row,2].Style.NumberFormat = "#.##0,00 [$Krakozhian Money Units]";

		ws.Cells[row+=2,1].Value = ".Style.Rotation";
		ws.Cells[row,2].Value = "35 degrees up";
		ws.Cells[row,2].Style.Rotation = 35;

		ws.Cells[row+=2,1].Value = ".Style.ShrinkToFit";
		ws.Cells[row,2].Value = "This property is set to true so this text appears shrunk.";
		ws.Cells[row,2].Style.ShrinkToFit = true;

		ws.Cells[row+=2,1].Value = ".Style.VerticalAlignment =";
		ws.Cells[row,2].Value = "VerticalAlignmentStyle.Top";
		// Set row height to 30 points.
		ws.Rows[row].Height = 30 * 20;
		ws.Cells[row,2].Style.VerticalAlignment = VerticalAlignmentStyle.Top;

		ws.Cells[row+=2,1].Value = ".Style.WrapText";
		ws.Cells[row,2].Value = "This property is set to true so this text appears broken into multiple lines.";
		ws.Cells[row,2].Style.WrapText = true;
	}
</code> 
</example>
        </member>
        <member name="P:GemBox.Spreadsheet.CellStyle.Borders">
            <summary>
            Gets or sets cell borders (<see cref="T:GemBox.Spreadsheet.CellBorder">CellBorder</see>).
            </summary>
            <example> Following code demonstrates various cell style properties:
<code lang="vbnet">
    Sub StylesSample(ByVal ws As ExcelWorksheet)
        ws.Cells(0, 0).Value = "Cell style examples:"

        Dim row As Integer = 0

        <font color="Green">' Column width of 4, 30 and 35 characters.</font>
        ws.Columns(0).Width = 4 * 256
        ws.Columns(1).Width = 30 * 256
        ws.Columns(2).Width = 35 * 256

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Borders.SetBorders(...)"
        ws.Cells(row, 2).Style.Borders.SetBorders(MultipleBorders.All, Color.FromArgb(252, 1, 1), LineStyle.Thin)

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.FillPattern.SetPattern(...)"
        ws.Cells(row, 2).Style.FillPattern.SetPattern(FillPatternStyle.ThinHorizontalCrosshatch, Color.Green, Color.Yellow)

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Color ="
        ws.Cells(row, 2).Value = "Color.Blue"
        ws.Cells(row, 2).Style.Font.Color = Color.Blue

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Italic ="
        ws.Cells(row, 2).Value = "true"
        ws.Cells(row, 2).Style.Font.Italic = True

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Name ="
        ws.Cells(row, 2).Value = "Comic Sans MS"
        ws.Cells(row, 2).Style.Font.Name = "Comic Sans MS"

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.ScriptPosition ="
        ws.Cells(row, 2).Value = "ScriptPosition.Superscript"
        ws.Cells(row, 2).Style.Font.ScriptPosition = ScriptPosition.Superscript

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Size ="
        ws.Cells(row, 2).Value = "18 * 20"
        ws.Cells(row, 2).Style.Font.Size = 18 * 20

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Strikeout ="
        ws.Cells(row, 2).Value = "true"
        ws.Cells(row, 2).Style.Font.Strikeout = True

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.UnderlineStyle ="
        ws.Cells(row, 2).Value = "UnderlineStyle.Double"
        ws.Cells(row, 2).Style.Font.UnderlineStyle = UnderlineStyle.Double

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Font.Weight ="
        ws.Cells(row, 2).Value = "ExcelFont.BoldWeight"
        ws.Cells(row, 2).Style.Font.Weight = ExcelFont.BoldWeight

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.HorizontalAlignment ="
        ws.Cells(row, 2).Value = "HorizontalAlignmentStyle.Center"
        ws.Cells(row, 2).Style.HorizontalAlignment = HorizontalAlignmentStyle.Center

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Indent"
        ws.Cells(row, 2).Value = "five"
        ws.Cells(row, 2).Style.HorizontalAlignment = HorizontalAlignmentStyle.Left
        ws.Cells(row, 2).Style.Indent = 5

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.IsTextVertical = "
        ws.Cells(row, 2).Value = "true"
        <font color="Green">' Set row height to 50 points.</font>
        ws.Rows(row).Height = 50 * 20
        ws.Cells(row, 2).Style.IsTextVertical = True

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.NumberFormat"
        ws.Cells(row, 2).Value = 1234
        ws.Cells(row, 2).Style.NumberFormat = "#.##0,00 [$Krakozhian Money Units]"

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.Rotation"
        ws.Cells(row, 2).Value = "35 degrees up"
        ws.Cells(row, 2).Style.Rotation = 35

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.ShrinkToFit"
        ws.Cells(row, 2).Value = "This property is set to true so this text appears shrunk."
        ws.Cells(row, 2).Style.ShrinkToFit = True

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.VerticalAlignment ="
        ws.Cells(row, 2).Value = "VerticalAlignmentStyle.Top"
        <font color="Green">' Set row height to 30 points.</font>
        ws.Rows(row).Height = 30 * 20
        ws.Cells(row, 2).Style.VerticalAlignment = VerticalAlignmentStyle.Top

        row = row + 2
        ws.Cells(row, 1).Value = ".Style.WrapText"
        ws.Cells(row, 2).Value = "This property is set to true so this text appears broken into multiple lines."
        ws.Cells(row, 2).Style.WrapText = True
    End Sub
</code>
<code lang="C#">
	static void StylesSample(ExcelWorksheet ws)
	{
		ws.Cells[0,0].Value = "Cell style examples:";

		int row = 0;

		// Column width of 4, 30 and 35 characters.
		ws.Columns[0].Width = 4 * 256;
		ws.Columns[1].Width = 30 * 256;
		ws.Columns[2].Width = 35 * 256;

		ws.Cells[row+=2,1].Value = ".Style.Borders.SetBorders(...)";
		ws.Cells[row,2].Style.Borders.SetBorders(MultipleBorders.All, Color.FromArgb(252, 1, 1), LineStyle.Thin);

		ws.Cells[row+=2,1].Value = ".Style.FillPattern.SetPattern(...)";
		ws.Cells[row,2].Style.FillPattern.SetPattern(FillPatternStyle.ThinHorizontalCrosshatch, Color.Green, Color.Yellow);

		ws.Cells[row+=2,1].Value = ".Style.Font.Color =";
		ws.Cells[row,2].Value = "Color.Blue";
		ws.Cells[row,2].Style.Font.Color = Color.Blue;

		ws.Cells[row+=2,1].Value = ".Style.Font.Italic =";
		ws.Cells[row,2].Value = "true";
		ws.Cells[row,2].Style.Font.Italic = true;

		ws.Cells[row+=2,1].Value = ".Style.Font.Name =";
		ws.Cells[row,2].Value = "Comic Sans MS";
		ws.Cells[row,2].Style.Font.Name = "Comic Sans MS";

		ws.Cells[row+=2,1].Value = ".Style.Font.ScriptPosition =";
		ws.Cells[row,2].Value = "ScriptPosition.Superscript";
		ws.Cells[row,2].Style.Font.ScriptPosition = ScriptPosition.Superscript;

		ws.Cells[row+=2,1].Value = ".Style.Font.Size =";
		ws.Cells[row,2].Value = "18 * 20";
		ws.Cells[row,2].Style.Font.Size = 18 * 20;

		ws.Cells[row+=2,1].Value = ".Style.Font.Strikeout =";
		ws.Cells[row,2].Value = "true";
		ws.Cells[row,2].Style.Font.Strikeout = true;

		ws.Cells[row+=2,1].Value = ".Style.Font.UnderlineStyle =";
		ws.Cells[row,2].Value = "UnderlineStyle.Double";
		ws.Cells[row,2].Style.Font.UnderlineStyle = UnderlineStyle.Double;

		ws.Cells[row+=2,1].Value = ".Style.Font.Weight =";
		ws.Cells[row,2].Value = "ExcelFont.BoldWeight";
		ws.Cells[row,2].Style.Font.Weight = ExcelFont.BoldWeight;

		ws.Cells[row+=2,1].Value = ".Style.HorizontalAlignment =";
		ws.Cells[row,2].Value = "HorizontalAlignmentStyle.Center";
		ws.Cells[row,2].Style.HorizontalAlignment = HorizontalAlignmentStyle.Center;

		ws.Cells[row+=2,1].Value = ".Style.Indent";
		ws.Cells[row,2].Value = "five";
		ws.Cells[row,2].Style.HorizontalAlignment = HorizontalAlignmentStyle.Left;
		ws.Cells[row,2].Style.Indent = 5;

		ws.Cells[row+=2,1].Value = ".Style.IsTextVertical = ";
		ws.Cells[row,2].Value = "true";
		// Set row height to 50 points.
		ws.Rows[row].Height = 50 * 20;
		ws.Cells[row,2].Style.IsTextVertical = true;

		ws.Cells[row+=2,1].Value = ".Style.NumberFormat";
		ws.Cells[row,2].Value = 1234;
		ws.Cells[row,2].Style.NumberFormat = "#.##0,00 [$Krakozhian Money Units]";

		ws.Cells[row+=2,1].Value = ".Style.Rotation";
		ws.Cells[row,2].Value = "35 degrees up";
		ws.Cells[row,2].Style.Rotation = 35;

		ws.Cells[row+=2,1].Value = ".Style.ShrinkToFit";
		ws.Cells[row,2].Value = "This property is set to true so this text appears shrunk.";
		ws.Cells[row,2].Style.ShrinkToFit = true;

		ws.Cells[row+=2,1].Value = ".Style.VerticalAlignment =";
		ws.Cells[row,2].Value = "VerticalAlignmentStyle.Top";
		// Set row height to 30 points.
		ws.Rows[row].Height = 30 * 20;
		ws.Cells[row,2].Style.VerticalAlignment = VerticalAlignmentStyle.Top;

		ws.Cells[row+=2,1].Value = ".Style.WrapText";
		ws.Cells[row,2].Value = "This property is set to true so this text appears broken into multiple lines.";
		ws.Cells[row,2].Style.WrapText = true;
	}
</code> 
</example>
        </member>
        <member name="T:GemBox.Spreadsheet.HashtableElement">
            <summary>
            HashtableElement. All derived classes MUST implement:
            1) HashtableElement Clone()
            2) int GetHashCode()
            3) bool Equals(object obj)
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.HorizontalAlignmentStyle">
            <summary>
            Horizontal alignment styles used for <see cref="P:GemBox.Spreadsheet.CellStyle.HorizontalAlignment">
            CellStyle.HorizontalAlignment</see>.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.HorizontalAlignmentStyle.General">
            <summary>
            Aligns data depending on the data type (text, number, etc.). Consult Microsoft Excel documentation.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.HorizontalAlignmentStyle.Left">
            <summary>
            Left alignment.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.HorizontalAlignmentStyle.Center">
            <summary>
            Center alignment.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.HorizontalAlignmentStyle.Right">
            <summary>
            Right alignment.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.HorizontalAlignmentStyle.Fill">
            <summary>
            Fill alignment repeats cell data to fill the whole cell.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.HorizontalAlignmentStyle.Justify">
            <summary>
            Justify alignment.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.HorizontalAlignmentStyle.CenterAcross">
            <summary>
            Centered across selection. Multiple cells can be selected but only one should have value for this alignment to have effect.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.HorizontalAlignmentStyle.Distributed">
            <summary>
            Distributed alignment.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.VerticalAlignmentStyle">
            <summary>
            Vertical alignment styles used for <see cref="P:GemBox.Spreadsheet.CellStyle.VerticalAlignment">
            CellStyle.VerticalAlignment</see>.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.VerticalAlignmentStyle.Top">
            <summary>
            Top alignment.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.VerticalAlignmentStyle.Center">
            <summary>
            Center alignment.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.VerticalAlignmentStyle.Bottom">
            <summary>
            Bottom alignment.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.VerticalAlignmentStyle.Justify">
            <summary>
            Justify alignment.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.VerticalAlignmentStyle.Distributed">
            <summary>
            Distributed alignment.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.CellBorder">
            <summary>
            Contains settings for a single cell border.
            </summary>
            <remarks>
Note that although diagonal-up (<see cref="F:GemBox.Spreadsheet.IndividualBorder.DiagonalUp">IndividualBorder.DiagonalUp</see> 
or <see cref="F:GemBox.Spreadsheet.MultipleBorders.DiagonalUp">MultipleBorders.DiagonalUp</see>) and diagonal-down 
(<see cref="F:GemBox.Spreadsheet.IndividualBorder.DiagonalDown">IndividualBorder.DiagonalDown</see> or
<see cref="F:GemBox.Spreadsheet.MultipleBorders.DiagonalDown">MultipleBorders.DiagonalDown</see>) can be individually set, 
they share the same color and the same line style. This is a Microsoft Excel limitation.
</remarks>
            <seealso cref="T:GemBox.Spreadsheet.CellBorders"/>
        </member>
        <member name="M:GemBox.Spreadsheet.CellBorder.SetBorder(System.Drawing.Color,GemBox.Spreadsheet.LineStyle)">
            <summary>
            Sets both border line color and line style.
            </summary>
            <param name="lineColor">Border line color.</param>
            <param name="lineStyle">Border line style.</param>
            <remarks>
Note that although diagonal-up (<see cref="F:GemBox.Spreadsheet.IndividualBorder.DiagonalUp">IndividualBorder.DiagonalUp</see> 
or <see cref="F:GemBox.Spreadsheet.MultipleBorders.DiagonalUp">MultipleBorders.DiagonalUp</see>) and diagonal-down 
(<see cref="F:GemBox.Spreadsheet.IndividualBorder.DiagonalDown">IndividualBorder.DiagonalDown</see> or
<see cref="F:GemBox.Spreadsheet.MultipleBorders.DiagonalDown">MultipleBorders.DiagonalDown</see>) can be individually set, 
they share the same color and the same line style. This is a Microsoft Excel limitation.
</remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.CellBorder.LineColor">
            <summary>
            Gets or sets border line color.
            </summary>
            <remarks>
Note that although diagonal-up (<see cref="F:GemBox.Spreadsheet.IndividualBorder.DiagonalUp">IndividualBorder.DiagonalUp</see> 
or <see cref="F:GemBox.Spreadsheet.MultipleBorders.DiagonalUp">MultipleBorders.DiagonalUp</see>) and diagonal-down 
(<see cref="F:GemBox.Spreadsheet.IndividualBorder.DiagonalDown">IndividualBorder.DiagonalDown</see> or
<see cref="F:GemBox.Spreadsheet.MultipleBorders.DiagonalDown">MultipleBorders.DiagonalDown</see>) can be individually set, 
they share the same color and the same line style. This is a Microsoft Excel limitation.
</remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.CellBorder.LineStyle">
            <summary>
            Gets or sets border line style.
            </summary>
            <remarks>
Note that although diagonal-up (<see cref="F:GemBox.Spreadsheet.IndividualBorder.DiagonalUp">IndividualBorder.DiagonalUp</see> 
or <see cref="F:GemBox.Spreadsheet.MultipleBorders.DiagonalUp">MultipleBorders.DiagonalUp</see>) and diagonal-down 
(<see cref="F:GemBox.Spreadsheet.IndividualBorder.DiagonalDown">IndividualBorder.DiagonalDown</see> or
<see cref="F:GemBox.Spreadsheet.MultipleBorders.DiagonalDown">MultipleBorders.DiagonalDown</see>) can be individually set, 
they share the same color and the same line style. This is a Microsoft Excel limitation.
</remarks>
        </member>
        <member name="T:GemBox.Spreadsheet.CellBorders">
            <summary>
            Collection of cell borders (<see cref="T:GemBox.Spreadsheet.CellBorder">CellBorder</see>).
            </summary>
            <seealso cref="T:GemBox.Spreadsheet.CellBorder"/>
        </member>
        <member name="M:GemBox.Spreadsheet.CellBorders.SetBorders(GemBox.Spreadsheet.MultipleBorders,System.Drawing.Color,GemBox.Spreadsheet.LineStyle)">
            <summary>
            Sets specific line color and line style on multiple borders.
            </summary>
            <param name="multipleBorders">Borders to set.</param>
            <param name="lineColor">Border line color.</param>
            <param name="lineStyle">Border line style.</param>
        </member>
        <member name="P:GemBox.Spreadsheet.CellBorders.Item(GemBox.Spreadsheet.IndividualBorder)">
            <summary>
            Gets specific border.
            </summary>
            <param name="individualBorder">Border to get.</param>
        </member>
        <member name="T:GemBox.Spreadsheet.LineStyle">
            <summary>
            Line styles used for 
            <see cref="P:GemBox.Spreadsheet.CellBorder.LineStyle">CellBorder.LineStyle</see>.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.LineStyle.None">
            <summary>
            No line.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.LineStyle.Thin">
            <summary>
            Thin line.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.LineStyle.Medium">
            <summary>
            Medium line.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.LineStyle.Dashed">
            <summary>
            Dashed line.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.LineStyle.Dotted">
            <summary>
            Dotted line.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.LineStyle.Thick">
            <summary>
            Thick line.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.LineStyle.DoubleLine">
            <summary>
            Obsolete. Use Double instead.
            </summary>
            <exclude/>
        </member>
        <member name="F:GemBox.Spreadsheet.LineStyle.Double">
            <summary>
            Double line.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.LineStyle.Hair">
            <summary>
            Hair line.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.LineStyle.MediumDashed">
            <summary>
            Medium dashed line.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.LineStyle.DashDot">
            <summary>
            Dash-dot line.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.LineStyle.MediumDashDot">
            <summary>
            Medium dash-dot line.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.LineStyle.DashDotDot">
            <summary>
            Dash-dot-dot line.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.LineStyle.MediumDashDotDot">
            <summary>
            Medium dash-dot-dot line.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.LineStyle.SlantedDashDot">
            <summary>
            Obsolete. Use SlantDashDot instead.
            </summary>
            <exclude/>
        </member>
        <member name="F:GemBox.Spreadsheet.LineStyle.SlantDashDot">
            <summary>
            Slanted dash-dot line.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.IndividualBorder">
            <summary>
            Different borders that can be set on excel cell. Members of this enumeration can't be combined.
            </summary>
            <seealso cref="T:GemBox.Spreadsheet.MultipleBorders"/>
        </member>
        <member name="F:GemBox.Spreadsheet.IndividualBorder.Top">
            <summary>
            Top border.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.IndividualBorder.Bottom">
            <summary>
            Bottom border.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.IndividualBorder.Left">
            <summary>
            Left border.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.IndividualBorder.Right">
            <summary>
            Right border.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.IndividualBorder.DiagonalUp">
            <summary>
            Diagonal-up border.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.IndividualBorder.DiagonalDown">
            <summary>
            Diagonal-down border.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.MultipleBorders">
            <summary>
            Flags for borders and border groups that can be set on the excel cell. 
            </summary>
            <seealso cref="T:GemBox.Spreadsheet.IndividualBorder"/>
        </member>
        <member name="F:GemBox.Spreadsheet.MultipleBorders.None">
            <summary>
            None of the borders are used.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.MultipleBorders.Top">
            <summary>
            Top border.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.MultipleBorders.Bottom">
            <summary>
            Bottom border.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.MultipleBorders.Left">
            <summary>
            Left border.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.MultipleBorders.Right">
            <summary>
            Right border.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.MultipleBorders.DiagonalUp">
            <summary>
            Diagonal-up border.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.MultipleBorders.DiagonalDown">
            <summary>
            Diagonal-down border.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.MultipleBorders.Horizontal">
            <summary>
            Horizontal borders.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.MultipleBorders.Vertical">
            <summary>
            Vertical borders.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.MultipleBorders.Diagonal">
            <summary>
            Diagonal borders.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.MultipleBorders.Outside">
            <summary>
            Outside borders.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.MultipleBorders.All">
            <summary>
            All borders are used.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.ExcelFillPattern">
            <summary>
            Contains fill pattern settings.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelFillPattern.SetSolid(System.Drawing.Color)">
            <summary>
            Sets solid pattern using specified fill color.
            </summary>
            <param name="fillColor">Fill color.</param>
            <remarks>
            This will set <see cref="P:GemBox.Spreadsheet.ExcelFillPattern.PatternStyle">PatternStyle</see> to 
            <see cref="F:GemBox.Spreadsheet.FillPatternStyle.Solid">FillPatternStyle.Solid</see> and 
            <see cref="P:GemBox.Spreadsheet.ExcelFillPattern.PatternForegroundColor">PatternForegroundColor</see> 
            to <i>fillColor</i>.
            </remarks>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelFillPattern.SetPattern(GemBox.Spreadsheet.FillPatternStyle,System.Drawing.Color,System.Drawing.Color)">
            <summary>
            Sets complex (non-empty and non-solid) pattern.
            </summary>
            <param name="patternStyle">Pattern style.</param>
            <param name="foregroundColor">Foreground color.</param>
            <param name="backgroundColor">Background color.</param>
            <remarks>
            <p>For solid pattern, just use <see cref="M:GemBox.Spreadsheet.ExcelFillPattern.SetSolid(System.Drawing.Color)">SetSolid</see> method.</p>
            <p>To clear fill pattern, just set <see cref="P:GemBox.Spreadsheet.ExcelFillPattern.PatternStyle">PatternStyle</see> 
            to <see cref="F:GemBox.Spreadsheet.FillPatternStyle.None">FillPatternStyle.None</see></p>
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelFillPattern.PatternStyle">
            <summary>
            Gets or sets fill pattern style.
            </summary>
            <remarks>
            If you set this property to anything else than <see cref="F:GemBox.Spreadsheet.FillPatternStyle.None">
            FillPatternStyle.None</see>, <see cref="P:GemBox.Spreadsheet.ExcelFillPattern.PatternForegroundColor">
            PatternForegroundColor</see> and/or <see cref="P:GemBox.Spreadsheet.ExcelFillPattern.PatternBackgroundColor">
            PatternBackgroundColor</see> should also be set (if color is 
            different from default <see cref="P:System.Drawing.Color.Black">Color.Black</see>.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelFillPattern.PatternForegroundColor">
            <summary>
            Get or sets fill pattern foreground color.
            </summary>
            <seealso cref="T:GemBox.Spreadsheet.FillPatternStyle"/>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelFillPattern.PatternBackgroundColor">
            <summary>
            Get or sets fill pattern background color.
            </summary>
            <seealso cref="T:GemBox.Spreadsheet.FillPatternStyle"/>
        </member>
        <member name="T:GemBox.Spreadsheet.FillPatternStyle">
            <summary>
            Fill pattern styles used for 
            <see cref="P:GemBox.Spreadsheet.ExcelFillPattern.PatternStyle">ExcelFillPattern.PatternStyle</see>.
            </summary>
            <remarks>
            <p>To see names of Microsoft Excel patterns, start Microsoft Excel and go to "Format" menu &gt; "Cells..." submenu &gt; 
            "Patterns" tab &gt; "Pattern" drop-down. When hovering over a pattern, Microsoft Excel name is displayed in tooltip
            text.</p>
            <p><b>None</b> fill pattern uses no colors.</p>
            <p><b>Solid</b> fill pattern uses <see cref="P:GemBox.Spreadsheet.ExcelFillPattern.PatternForegroundColor">
            ExcelFillPattern.PatternForegroundColor</see>.</p>
            <p>All other paterns use both <see cref="P:GemBox.Spreadsheet.ExcelFillPattern.PatternForegroundColor">
            ExcelFillPattern.PatternForegroundColor</see> and 
            <see cref="P:GemBox.Spreadsheet.ExcelFillPattern.PatternBackgroundColor">ExcelFillPattern.PatternBackgroundColor</see></p>
            </remarks>
            <seealso cref="P:GemBox.Spreadsheet.ExcelFillPattern.PatternStyle">ExcelFillPattern.PatternStyle</seealso>
            <seealso cref="P:GemBox.Spreadsheet.ExcelFillPattern.PatternForegroundColor">ExcelFillPattern.PatternForegroundColor</seealso>
            <seealso cref="P:GemBox.Spreadsheet.ExcelFillPattern.PatternBackgroundColor">ExcelFillPattern.PatternBackgroundColor</seealso>
        </member>
        <member name="F:GemBox.Spreadsheet.FillPatternStyle.None">
            <summary>
            No fill pattern.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.FillPatternStyle.Solid">
            <summary>
            "Solid" fill pattern using foreground color.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.FillPatternStyle.Gray6">
            <summary>
            "6% Gray" is Microsoft Excel pattern name, but any color can be used instead of black as a foreground color.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.FillPatternStyle.Gray12">
            <summary>
            "12% Gray" is Microsoft Excel pattern name, but any color can be used instead of black as a foreground color.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.FillPatternStyle.Gray25">
            <summary>
            "25% Gray" is Microsoft Excel pattern name, but any color can be used instead of black as a foreground color.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.FillPatternStyle.Gray50">
            <summary>
            "50% Gray" is Microsoft Excel pattern name, but any color can be used instead of black as a foreground color.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.FillPatternStyle.Gray75">
            <summary>
            "75% Gray" is Microsoft Excel pattern name, but any color can be used instead of black as a foreground color.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.FillPatternStyle.HorizontalStripe">
            <summary>
            "Horizontal Stripe" pattern.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.FillPatternStyle.VerticalStripe">
            <summary>
            "Vertical Stripe" pattern.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.FillPatternStyle.DiagonalStripe">
            <summary>
            "Diagonal Stripe" pattern.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.FillPatternStyle.ReverseDiagonalStripe">
            <summary>
            "Reverse Diagonal Stripe" pattern.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.FillPatternStyle.DiagonalCrosshatch">
            <summary>
            "Diagonal Crosshatch" pattern.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.FillPatternStyle.ThickDiagonalCrosshatch">
            <summary>
            "Thick Diagonal Crosshatch" pattern.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.FillPatternStyle.ThinHorizontalStripe">
            <summary>
            "Thin Horizontal Stripe" pattern.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.FillPatternStyle.ThinVerticalStripe">
            <summary>
            "Thin Vertical Stripe" pattern.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.FillPatternStyle.ThinDiagonalStripe">
            <summary>
            "Thin Diagonal Stripe" pattern.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.FillPatternStyle.ThinReverseDiagonalStripe">
            <summary>
            "Thin Reverse Diagonal Stripe" pattern.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.FillPatternStyle.ThinHorizontalCrosshatch">
            <summary>
            "Thin Horizontal Crosshatch" pattern.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.FillPatternStyle.ThinDiagonalCrosshatch">
            <summary>
            "Thin Diagonal Crosshatch" pattern.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.ExcelFont">
            <summary>
            Contains font related settings.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ExcelFont.MinWeight">
            <summary>
            Minimum font weight.
            </summary>
            <seealso cref="P:GemBox.Spreadsheet.ExcelFont.Weight"/>
        </member>
        <member name="F:GemBox.Spreadsheet.ExcelFont.NormalWeight">
            <summary>
            Normal font weight.
            </summary>
            <seealso cref="P:GemBox.Spreadsheet.ExcelFont.Weight"/>
        </member>
        <member name="F:GemBox.Spreadsheet.ExcelFont.BoldWeight">
            <summary>
            Default bold font weight.
            </summary>
            <seealso cref="P:GemBox.Spreadsheet.ExcelFont.Weight"/>
        </member>
        <member name="F:GemBox.Spreadsheet.ExcelFont.MaxWeight">
            <summary>
            Maximum font weight.
            </summary>
            <seealso cref="P:GemBox.Spreadsheet.ExcelFont.Weight"/>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelFont.Name">
            <summary>
            Gets or sets name of the font.
            </summary>
            <remarks>
            Default value for this property is determined by
            <see cref="P:GemBox.Spreadsheet.ExcelFile.DefaultFontName">
            GemBox.Spreadsheet.ExcelFile.DefaultFontName</see>.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelFont.Color">
            <summary>
            Gets or sets font color.
            </summary>
            <remarks>
            Default value for this property is <see cref="P:System.Drawing.Color.Black">Color.Black</see>.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelFont.Weight">
            <summary>
            Gets or sets font weight (font boldness).
            </summary>
            <remarks>
            <p>Font weight is an integer value between <see cref="F:GemBox.Spreadsheet.ExcelFont.MinWeight">
            MinWeight</see> and <see cref="F:GemBox.Spreadsheet.ExcelFont.MaxWeight">MaxWeight</see>.</p>
            <p>If you want font to have standard boldness, set this property to
            <see cref="F:GemBox.Spreadsheet.ExcelFont.BoldWeight">BoldWeight</see>.</p>
            <p>Default value of this property is <see cref="F:GemBox.Spreadsheet.ExcelFont.NormalWeight">NormalWeight</see>.</p>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if font weight is out of allowed range.</exception>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelFont.Size">
            <summary>
            Gets or sets font size.
            </summary>
            <remarks>
            <p>Unit is twip (1/20th of a point).</p>
            <p>Default value of this property is determined by
            <see cref="P:GemBox.Spreadsheet.ExcelFile.DefaultFontSize">
            GemBox.Spreadsheet.ExcelFile.DefaultFontSize</see></p>
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelFont.Italic">
            <summary>
            Gets or sets if the font is italic.
            </summary>
            <remarks>
            Default value of this property is <b>false</b>.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelFont.Strikeout">
            <summary>
            Gets or sets if the font is struck out.
            </summary>
            <remarks>
            Default value of this property is <b>false</b>.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelFont.ScriptPosition">
            <summary>
            Gets or sets font script position.
            </summary>
            <remarks>
            Default value of this property is <see cref="F:GemBox.Spreadsheet.ScriptPosition.Normal">ScriptPosition.Normal</see>.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelFont.UnderlineStyle">
            <summary>
            Gets or sets font underlining.
            </summary>
            <remarks>
            Default value of this property is <see cref="F:GemBox.Spreadsheet.UnderlineStyle.None">UnderlineStyle.None</see>.
            </remarks>
        </member>
        <member name="T:GemBox.Spreadsheet.ScriptPosition">
            <summary>
            Script positions used in <see cref="P:GemBox.Spreadsheet.ExcelFont.ScriptPosition">ExcelFont.ScriptPosition</see>.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ScriptPosition.Normal">
            <summary>
            Normal script position.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ScriptPosition.Superscript">
            <summary>
            Displays script above normal position.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ScriptPosition.Subscript">
            <summary>
            Displays script below normal position.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.UnderlineStyle">
            <summary>
            Underline styles used in <see cref="P:GemBox.Spreadsheet.ExcelFont.UnderlineStyle">ExcelFont.UnderlineStyle</see>.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.UnderlineStyle.None">
            <summary>
            No underline.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.UnderlineStyle.Single">
            <summary>
            Single underline. Underlines only cell data.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.UnderlineStyle.Double">
            <summary>
            Double underline. Underlines only cell data.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.UnderlineStyle.SingleAccounting">
            <summary>
            Single accounting underline. Underlines whole cell.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.UnderlineStyle.DoubleAccounting">
            <summary>
            Double accounting underline. Underlines whole cell.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.BadPasswordException">
            <summary>
            Issued when an <c>ZipEntry.ExtractWithPassword()</c> method is invoked
            with an incorrect password.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.ZipException">
            <summary>
            Base class for all exceptions defined by and throw by the Zip library.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.ZipException.#ctor">
            <summary>
            Default ctor.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.ZipException.#ctor(System.String)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ZipException.#ctor(System.String,System.Exception)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
            <param name="innerException">The innerException for this exception.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ZipException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="serializationInfo">The serialization info for the exception.</param>
            <param name="streamingContext">The streaming context from which to deserialize.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.BadPasswordException.#ctor">
            <summary>
            Default ctor.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.BadPasswordException.#ctor(System.String)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.BadPasswordException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="serializationInfo">The serialization info for the exception.</param>
            <param name="streamingContext">The streaming context from which to deserialize.</param>
        </member>
        <member name="T:GemBox.Spreadsheet.BadReadException">
            <summary>
            Indicates that a read was attempted on a stream, and bad or incomplete data was
            received.  
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.BadReadException.#ctor">
            <summary>
            Default ctor.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.BadReadException.#ctor(System.String)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.BadReadException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="serializationInfo">The serialization info for the exception.</param>
            <param name="streamingContext">The streaming context from which to deserialize.</param>
        </member>
        <member name="T:GemBox.Spreadsheet.BadCrcException">
            <summary>
            Issued when an CRC check fails upon extracting an entry from a zip archive.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.BadCrcException.#ctor">
            <summary>
            Default ctor.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.BadCrcException.#ctor(System.String)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.BadCrcException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="serializationInfo">The serialization info for the exception.</param>
            <param name="streamingContext">The streaming context from which to deserialize.</param>
        </member>
        <member name="T:GemBox.Spreadsheet.SfxGenerationException">
            <summary>
            Issued when errors occur saving a self-extracting archive.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.SfxGenerationException.#ctor">
            <summary>
            Default ctor.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.SfxGenerationException.#ctor(System.String)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.SfxGenerationException.#ctor(System.String,System.Exception)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
            <param name="innerException">The innerException for this exception.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.SfxGenerationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="serializationInfo">The serialization info for the exception.</param>
            <param name="streamingContext">The streaming context from which to deserialize.</param>
        </member>
        <member name="T:GemBox.Spreadsheet.BadStateException">
            <summary>
            Indicates that an operation was attempted on a ZipFile which was not possible
            given the state of the instance. For example, if you call <c>Save()</c> on a ZipFile 
            which has no filename set, you can get this exception. 
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.BadStateException.#ctor">
            <summary>
            Default ctor.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.BadStateException.#ctor(System.String)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.BadStateException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="serializationInfo">The serialization info for the exception.</param>
            <param name="streamingContext">The streaming context from which to deserialize.</param>
        </member>
        <member name="T:GemBox.Spreadsheet.NameRecord">
            <summary>
            Name record for holding information about name which can be used in named cell\range
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.NameRecord.#ctor(System.Int32,System.IO.BinaryReader,GemBox.Spreadsheet.AbsXLSRec,GemBox.Spreadsheet.IoOperationInfo)">
            <summary>
            Initializes a new instance of the <see cref="T:GemBox.Spreadsheet.NameRecord"/> class.
            </summary>
            <param name="bodyLength">Length of the body.</param>
            <param name="br">The binary readed to read from.</param>
            <param name="previousRecord">The previous record.</param>
            <param name="operationInfo">Current operation information.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.NameRecord.#ctor(GemBox.Spreadsheet.ExcelWorksheet)">
            <summary>
            Initializes a new instance of the <see cref="T:GemBox.Spreadsheet.NameRecord"/> class.
            </summary>
            <param name="worksheet">The worksheet.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.NameRecord.ConvertNameRecordRangeToRpnBytes(GemBox.Spreadsheet.ExcelWorksheet,GemBox.Spreadsheet.CellRange,System.String,GemBox.Spreadsheet.ExcelWorksheetCollection)">
            <summary>
            Converts the name record range to RPN bytes.
            </summary>
            <param name="sheet"></param>
            <param name="range">The range to be converted.</param>
            <param name="sheetName">Sheet' name.</param>
            <param name="worksheets">The worksheets collection.</param>		
        </member>
        <member name="P:GemBox.Spreadsheet.NameRecord.NameValue">
            <summary>
            Gets or sets the name value.
            </summary>
            <value>The name value.</value>
        </member>
        <member name="P:GemBox.Spreadsheet.NameRecord.SheetIndex">
            <summary>
            Gets or sets the index for the sheet which contain named cell\range.
            </summary>
            <value>The index for the sheet which contain named cell\range.</value>
        </member>
        <member name="P:GemBox.Spreadsheet.NameRecord.Worksheets">
            <summary>
            Gets or sets the workbook\worksheets collection.
            </summary>
            <value>The workbook\worksheets collection.</value>
        </member>
        <member name="P:GemBox.Spreadsheet.NameRecord.Range">
            <summary>
            Gets or sets the range to be associated with the user-defined name.
            </summary>
            <value>The range to be associated with the user-defined name.</value>
        </member>
        <member name="P:GemBox.Spreadsheet.NameRecord.RpnBytes">
            <summary>
            Gets or sets the RPN bytes of formula used for referencing 3d cell or area.
            </summary>
            <value>The RPN bytes of formula used for referencing 3d cell or area.</value>
        </member>
        <member name="P:GemBox.Spreadsheet.NameRecord.Options">
            <summary>
            Gets or sets the options.
            </summary>
            <value>The options.</value>
        </member>
        <member name="T:GemBox.Spreadsheet.ExternsheetRecord">
            <summary>
            Externsheet record for holding information REF' structures
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.ExternsheetRecord.#ctor(System.Int32,System.IO.BinaryReader,GemBox.Spreadsheet.AbsXLSRec,GemBox.Spreadsheet.IoOperationInfo)">
            <summary>
            Initializes a new instance of the <see cref="T:GemBox.Spreadsheet.ExternsheetRecord"/> class.
            </summary>
            <param name="bodyLength">Length of the body.</param>
            <param name="br">The binary reader to read from.</param>
            <param name="previousRecord">The previous record.</param>
            <param name="operationInfo">Current operation information.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ExternsheetRecord.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:GemBox.Spreadsheet.ExternsheetRecord"/> class.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.ExternsheetRecord.SheetIndexes">
            <summary>
            Gets the sheet indexes.
            </summary>
            <value>The sheet indexes.</value>
        </member>
        <member name="T:GemBox.Spreadsheet.SheetIndexes">
            <summary>
            SheetIndexes structure for storing index to SupBook record
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.SheetIndexes.sheetIndex">
            <summary>
            Index to first/last sheet
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.SheetIndexes.#ctor(System.UInt16)">
            <summary>
            Initializes a new instance of the <see cref="T:GemBox.Spreadsheet.SheetIndexes"/> class.
            </summary>		
            <param name="sheetIndex">The first/last sheet index.</param>				
        </member>
        <member name="M:GemBox.Spreadsheet.SheetIndexes.#ctor(System.IO.BinaryReader)">
            <summary>
            Initializes a new instance of the <see cref="T:GemBox.Spreadsheet.SheetIndexes"/> class.
            </summary>
            <param name="br">The binary reader to read from.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.SheetIndexes.Write(System.IO.BinaryWriter)">
            <summary>
            Writes the REF' data to the specified binary writer.
            </summary>
            <param name="bw">The destination binary writer.</param>
        </member>
        <member name="P:GemBox.Spreadsheet.SheetIndexes.SheetIndex">
            <summary>
            Gets or sets the first/last sheet index.
            </summary>
            <value>The first/last sheet index.</value>
        </member>
        <member name="P:GemBox.Spreadsheet.SheetIndexes.Size">
            <summary>
            Gets the size of REF' storage.
            </summary>
            <value>The size of REF' storage.</value>
        </member>
        <member name="T:GemBox.Spreadsheet.ExcelFile">
            <summary>
            Excel file contains one or more worksheets (<see cref="T:GemBox.Spreadsheet.ExcelWorksheet">ExcelWorksheet</see>)
            and workbook related properties and methods.
            </summary>
            <seealso cref="T:GemBox.Spreadsheet.ExcelWorksheet"/>
        </member>
        <member name="F:GemBox.Spreadsheet.ExcelFile.MaxXlsColors">
            <summary>
            Maximum number of colors in XLS (BIFF8) file.
            </summary>
            <remarks>
            This number includes 8 default colors:
            <see cref="P:System.Drawing.Color.Black">Color.Black</see>, 
            <see cref="P:System.Drawing.Color.White">Color.White</see>,
            <see cref="P:System.Drawing.Color.Red">Color.Red</see>, 
            <see cref="P:System.Drawing.Color.Green">Color.Green</see>,
            <see cref="P:System.Drawing.Color.Blue">Color.Blue</see>, 
            <see cref="P:System.Drawing.Color.Yellow">Color.Yellow</see>,
            <see cref="P:System.Drawing.Color.Magenta">Color.Magenta</see> and
            <see cref="P:System.Drawing.Color.Cyan">Color.Cyan</see>.
            </remarks>
        </member>
        <member name="F:GemBox.Spreadsheet.ExcelFile.MaxXlsCellStyles">
            <summary>
            Maximum number of user-defined cell styles in XLS (BIFF8) file.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ExcelFile.MaxXlsRows">
            <summary>
            Maximum number of rows in XLS (BIFF8) file.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ExcelFile.MaxXlsColumns">
            <summary>
            Maximum number of columns in XLS (BIFF8) file.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ExcelFile.MaxRows">
            <summary>
            Maximum number of rows in <see cref="T:GemBox.Spreadsheet.ExcelWorksheet">ExcelWorksheet</see>.
            </summary>
            <remarks>
            If you read/write XLS files, you are also limited by
            <see cref="F:GemBox.Spreadsheet.ExcelFile.MaxXlsRows">ExcelFile.MaxXlsRows</see>.
            </remarks>
        </member>
        <member name="F:GemBox.Spreadsheet.ExcelFile.MaxColumns">
            <summary>
            Maximum number of columns in <see cref="T:GemBox.Spreadsheet.ExcelWorksheet">ExcelWorksheet</see>.
            </summary>
            <remarks>
            If you read/write XLS files, you are also limited by
            <see cref="F:GemBox.Spreadsheet.ExcelFile.MaxXlsColumns">ExcelFile.MaxXlsColumns</see>.
            </remarks>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelFile.#ctor">
            <summary>
            Initializes an empty (no worksheets) instance of the ExcelFile class.
            </summary>
            <remarks>
            <p>To add new worksheets to a blank file use <see cref="P:GemBox.Spreadsheet.ExcelFile.Worksheets">
            Worksheets</see> property, <see cref="M:GemBox.Spreadsheet.ExcelWorksheetCollection.Add(System.String)">Add</see> method.</p>
            <p>To save created file use <see cref="M:GemBox.Spreadsheet.ExcelFile.SaveXls(System.String)">SaveXls(string)</see> / 
            <see cref="M:GemBox.Spreadsheet.ExcelFile.SaveXls(System.IO.Stream)">SaveXls(Stream)</see> or 
            <see cref="M:GemBox.Spreadsheet.ExcelFile.SaveCsv(System.String,GemBox.Spreadsheet.CsvType)">SaveCsv</see> method.</p>
            <p>To read existing file or use existing file as a template use 
            <see cref="M:GemBox.Spreadsheet.ExcelFile.LoadXls(System.String,GemBox.Spreadsheet.XlsOptions)">LoadXls(string,XlsOptions)</see> /
            <see cref="M:GemBox.Spreadsheet.ExcelFile.LoadXls(System.IO.Stream,GemBox.Spreadsheet.XlsOptions)">LoadXls(Stream,XlsOptions)</see>
            or <see cref="M:GemBox.Spreadsheet.ExcelFile.LoadCsv(System.String,GemBox.Spreadsheet.CsvType)">LoadCsv</see> method.</p>
            </remarks>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelFile.ClosePreservedXlsx">
            <summary>
            Closes preserved XLSX file handle if needed 
            (<see cref="F:GemBox.Spreadsheet.XlsxOptions.PreserveKeepOpen">XlsxOptions.PreserveKeepOpen</see> was
            used with <see cref="M:GemBox.Spreadsheet.ExcelFile.LoadXlsx(System.String,GemBox.Spreadsheet.XlsxOptions)">
            ExcelFile.LoadXlsx(string,XlsxOptions)</see> method). <b>(NET30, NET35 and NET40 only)</b>
            </summary>
            <remarks>
            <p><b>This method is present only in build targeting .NET Framework 3.0, 3.5 and 4.0.</b></p>
            </remarks>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelFile.SaveXls(System.String)">
            <overloads>Saves all data to a file or stream in XLS format.</overloads>
            <summary>
            Saves all data to a new file in XLS format.
            </summary>
            <param name="fileName">File name.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelFile.SaveXls(System.IO.Stream)">
            <summary>
            Saves all data to an output stream in XLS format.
            </summary>
            <param name="stream">Output stream.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelFile.SaveCsv(System.IO.Stream,GemBox.Spreadsheet.CsvType)">
            <overloads>Saves all data to a new file or stream in CSV format.</overloads>
            <summary>
            Saves all data to a stream in a specified CSV format.
            </summary>
            <param name="stream">Output stream.</param>
            <param name="csvType">CSV type.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelFile.SaveCsv(System.IO.Stream,System.Char)">
            <summary>
            Saves all data to a stream, using specified character as a delimiter.
            </summary>
            <param name="stream">Output stream.</param>
            <param name="separator">Separator used for delimiting data values.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelFile.SaveCsv(System.IO.TextWriter,GemBox.Spreadsheet.CsvType)">
            <summary>
            Saves all data using specified TextWriter and CSV Type.
            </summary>
            <remarks>
            Use this overload if you want to use a TextWriter with non-default encoding. 
            Note that .NET Framework adds byte order mark (BOM) to files with non-default 
            encoding. MS Excel and other programs may fail to recognize CSV files with 
            non-default encoding.
            </remarks>
            <param name="tw">Text writer.</param>
            <param name="csvType">CSV type.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelFile.SaveCsv(System.IO.TextWriter,System.Char)">
            <summary>
            Saves all data using specified TextWriter and character delimiter.
            </summary>
            <remarks>
            Use this overload if you want to use a TextWriter with non-default encoding. 
            Note that .NET Framework adds byte order mark (BOM) to files with non-default 
            encoding. MS Excel and other programs may fail to recognize CSV files with 
            non-default encoding.
            </remarks>
            <param name="tw">Text writer.</param>
            <param name="separator">Separator used for delimiting data values.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelFile.SaveCsv(System.String,GemBox.Spreadsheet.CsvType)">
            <summary>
            Saves all data to a new file in a specified CSV format.
            </summary>
            <param name="fileName">File name.</param>
            <param name="csvType">CSV type.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelFile.SaveCsv(System.String,System.Char)">
            <summary>
            Saves all data to a new file, using specified character as a delimiter.
            </summary>
            <param name="fileName">File name.</param>
            <param name="separator">Separator used for delimiting data values.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelFile.SaveXlsx(System.String)">
            <overloads>Saves all data to a file or stream in XLSX format. <b>(NET30, NET35 and NET40 only)</b></overloads>
            <summary>
            Saves all data to a new file in XLSX format. <b>(NET30, NET35 and NET40 only)</b>
            </summary>
            <remarks>
            <p><b>This method is present only in build targeting .NET Framework 3.0, 3.5 and 4.0.</b></p>
            </remarks>
            <param name="fileName">File name.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelFile.SaveXlsx(System.IO.Stream)">
            <summary>
            Saves all data to an output stream in XLSX format. <b>(NET30, NET35 and NET40 only)</b>
            </summary>
            <remarks>
            <p><b>This method is present only in build targeting .NET Framework 3.0, 3.5 and 4.0.</b></p>
            </remarks>
            <param name="stream">Output stream.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelFile.SaveXlsx(System.String,GemBox.Spreadsheet.XlsxSaveOptions)">
            <summary>
            Saves all data to a new file in XLSX format. <b>(NET30, NET35 and NET40 only)</b>
            </summary>
            <remarks>
            <p><b>This method is present only in build targeting .NET Framework 3.0, 3.5 and 4.0.</b></p>
            </remarks>
            <param name="fileName">File name.</param>
            <param name="options">Advanced save options.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelFile.SaveXlsx(System.IO.Stream,GemBox.Spreadsheet.XlsxSaveOptions)">
            <summary>
            Saves all data to an output stream in XLSX format. <b>(NET30, NET35 and NET40 only)</b>
            </summary>
            <remarks>
            <p><b>This method is present only in build targeting .NET Framework 3.0, 3.5 and 4.0.</b></p>
            </remarks>
            <param name="stream">Output stream.</param>
            <param name="options">Advanced save options.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelFile.SaveOds(System.String)">
            <overloads>Saves all data to a new file in ODF format.</overloads>
            <summary>
            Saves all data to a new file in ODF format.
            </summary>
            <param name="fileName">File name.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelFile.SaveOds(System.IO.Stream)">
            <summary>
            Saves all data to an output stream in ODF format.
            </summary>
            <param name="stream">Output stream.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelFile.SaveOdsToDirectory(System.String)">
            <summary>
            Saves all parts of ODS file as separate files to output directory.
            </summary>
            <remarks>
            You need to use external ZIP library to package all created files to ODS file.
            </remarks>
            <param name="path">Path of output directory.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelFile.SaveXlsxToDirectory(System.String)">
            <summary>
            Saves all parts of XLSX file as separate files to output directory.
            </summary>
            <remarks>
            You need to use external ZIP library to package all created files to XLSX file.
            </remarks>
            <param name="path">Path of output directory.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelFile.SaveXlsxToDirectory(System.String,GemBox.Spreadsheet.XlsxSaveOptions)">
            <summary>
            Saves all parts of XLSX file as separate files to output directory.
            </summary>
            <remarks>
            You need to use external ZIP library to package all created files to XLSX file.
            </remarks>
            <param name="path">Path of output directory</param>
            <param name="options">Advanced save options.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelFile.LoadXlsx(System.String,GemBox.Spreadsheet.XlsxOptions)">
            <overloads>Loads the existing XLSX file or stream. <b>(NET30, NET35 and NET40 only)</b></overloads>
            <summary>
            Loads the existing XLSX file. <b>(NET30, NET35 and NET40 only)</b>
            </summary>
            <remarks>
            <p><b>This method is present only in build targeting .NET Framework 3.0, 3.5 and 4.0.</b></p>
            </remarks>
            <param name="fileName">Existing XLSX file name (opened for reading).</param>
            <param name="xlsxOptions">XLS options.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelFile.LoadXlsx(System.IO.Stream,GemBox.Spreadsheet.XlsxOptions)">
            <summary>
            Loads the existing XLSX file from the input stream. <b>(NET30, NET35 and NET40 only)</b>
            </summary>
            <remarks>
            <p><b>This method is present only in build targeting .NET Framework 3.0, 3.5 and 4.0.</b></p>
            </remarks>
            <param name="stream">Input stream.</param>
            <param name="xlsxOptions">XLS options.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelFile.LoadXlsxFromDirectory(System.String,GemBox.Spreadsheet.XlsxOptions)">
            <summary>
            Loads all parts of XLSX file as separate files from input directory.
            </summary>
            <remarks>
            You need to use external ZIP library to extract all parts from XLSX file.
            XlsxOptions.PreserveMakeCopy option does not work with LoadXlsxFromDirectory method.
            </remarks>
            <param name="path">Path of input directory.</param>
            <param name="xlsxOptions">XLS options.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelFile.LoadOds(System.String,GemBox.Spreadsheet.OdsOptions)">
            <overloads>Loads the existing ODS file.</overloads>
            <summary>
            Loads the existing ODS file.
            </summary>
            <param name="fileName">Existing ODS file name.</param>
            <param name="odsOptions">ODS options.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelFile.LoadOds(System.IO.Stream,GemBox.Spreadsheet.OdsOptions)">
            <summary>
            Loads the existing ODS file from the input stream.
            </summary>
            <param name="stream">Input stream (opened for reading).</param>
            <param name="odsOptions">ODS options.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelFile.LoadOdsFromDirectory(System.String,GemBox.Spreadsheet.OdsOptions)">
            <summary>
            Loads all parts of ODS file as separate files from input directory.
            </summary>
            <remarks>
            You need to use external ZIP library to extract all parts from ODS file.
            </remarks>
            <param name="path">Path of input directory.</param>
            <param name="odsOptions">ODS options.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelFile.LoadXls(System.String)">
            <overloads>Loads the existing XLS file or stream.</overloads>
            <summary>
            Loads the existing XLS file (preserving MS Excel records).
            </summary>
            <param name="fileName">Existing XLS file name (opened for reading).</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelFile.LoadXls(System.String,GemBox.Spreadsheet.XlsOptions)">
            <summary>
            Loads the existing XLS file (optionally preserving MS Excel records).
            </summary>
            <remarks>
            <p>If the only purpose of loading the file is to read data values and formatting using 
            GemBox.Spreadsheet API, you should use <i>xlsOptions</i> set to <see cref="F:GemBox.Spreadsheet.XlsOptions.None">XlsOptions.None</see>
            as this will speed up the loading process.</p>
            <p>If you load the existing file to use it as template for a new file, you can choose
            whether you want to preserve specific MS Excel records not recognized by GemBox.Spreadsheet API.</p>
            </remarks>
            <param name="fileName">Existing XLS file name (opened for reading).</param>
            <param name="xlsOptions">XLS options.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelFile.LoadXls(System.IO.Stream)">
            <summary>
            Loads the existing XLS file from the input stream (preserving MS Excel records).
            </summary>
            <param name="stream">Input stream.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelFile.LoadXls(System.IO.Stream,GemBox.Spreadsheet.XlsOptions)">
            <summary>
            Loads the existing XLS file from the input stream (optionally preserving MS Excel records).
            </summary>
            <remarks>
            <p>If the only purpose of loading the file is to read data values and formatting using 
            GemBox.Spreadsheet API, you should use <i>xlsOptions</i> set to <see cref="F:GemBox.Spreadsheet.XlsOptions.None">XlsOptions.None</see>
            as this will speed up the loading process.</p>
            <p>If you load the existing file to use it as template for a new file, you can choose
            whether you want to preserve specific MS Excel records not recognized by GemBox.Spreadsheet API.</p>
            </remarks>
            <param name="stream">Input stream.</param>
            <param name="xlsOptions">XLS options.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelFile.LoadCsv(System.IO.Stream,GemBox.Spreadsheet.CsvType)">
            <overloads>Loads the existing CSV file or stream.</overloads>
            <summary>
            Loads the existing stream with specified CSV format.
            </summary>
            <param name="stream">Input stream.</param>
            <param name="csvType">CSV type.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelFile.LoadCsv(System.IO.Stream,System.Char)">
            <summary>
            Loads the existing stream, using specified character as a delimiter.
            </summary>
            <param name="stream">Input stream.</param>
            <param name="separator">Separator used for delimiting data values.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelFile.LoadCsv(System.IO.StreamReader,GemBox.Spreadsheet.CsvType)">
            <summary>
            Loads all data using specified StreamReader and CSV Type.
            </summary>
            <remarks>
            Use this overload if you want to use a StreamReader with non-default encoding. 
            </remarks>
            <param name="sr">Stream reader.</param>
            <param name="csvType">CSV type.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelFile.LoadCsv(System.IO.StreamReader,System.Char)">
            <summary>
            Loads all data using specified StreamReader and character delimiter.
            </summary>
            <remarks>
            Use this overload if you want to use a StreamReader with non-default encoding. 
            </remarks>
            <param name="sr">Stream reader.</param>
            <param name="separator">Separator used for delimiting data values.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelFile.LoadCsv(System.String,GemBox.Spreadsheet.CsvType)">
            <summary>
            Loads the existing file with specified CSV format.
            </summary>
            <param name="fileName">Existing CSV file name (opened for reading).</param>
            <param name="csvType">CSV type.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelFile.LoadCsv(System.String,System.Char)">
            <summary>
            Loads the existing file, using specified character as a delimiter.
            </summary>
            <param name="fileName">File name.</param>
            <param name="separator">Separator used for delimiting data values.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelFile.DumpToLowLevelXml(System.String,System.String)">
            <summary>
            Internal.  
            </summary>
            <param name="sourceFileName">Source file name.</param>
            <param name="destinationFileName">Destination file name.</param>
            <exclude/>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelFile.SupportsType(System.Type)">
            <summary>
            Gets a value indicating whether the objects of specified type can be assigned 
            to <see cref="P:GemBox.Spreadsheet.ExcelCell.Value">ExcelCell.Value</see> property.
            </summary>
            <param name="type">Queried type.</param>
            <remarks>
            Currently supported types are:
            <list type="bullet">
            <item><description>System.DBNull</description></item>
            <item><description>System.Byte</description></item>
            <item><description>System.SByte</description></item>
            <item><description>System.Int16</description></item>
            <item><description>System.UInt16</description></item>
            <item><description>System.Int64</description></item>
            <item><description>System.UInt64</description></item>
            <item><description>System.UInt32</description></item>
            <item><description>System.Int32</description></item>
            <item><description>System.Single</description></item>
            <item><description>System.Double</description></item>
            <item><description>System.Boolean</description></item>
            <item><description>System.Char</description></item>
            <item><description>System.Text.StringBuilder</description></item>
            <item><description>System.Decimal</description></item>
            <item><description>System.DateTime</description></item>
            <item><description>System.String</description></item>
            </list>
            </remarks>
            <returns><b>true</b> if the specified type is supported; otherwise, <b>false</b>.</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelFile.SaveHtml(System.String,GemBox.Spreadsheet.HtmlExporterOptions,System.Boolean)">
            <overloads>Saves the data from used range of the active worksheet to a new file or XmlTextWriter in HTML format.</overloads>
            <summary>
            Saves the data from used range of the active worksheet to a new file in HTML format.
            </summary>
            <remarks>For HTML export <see cref="M:GemBox.Spreadsheet.DefaultHtmlExporter.DefaultPageToHtml(GemBox.Spreadsheet.HtmlExporterOptions,GemBox.Spreadsheet.CellRange)">DefaultHtmlExporter.DefaultPageToHtml</see> or <see cref="M:GemBox.Spreadsheet.CellRange.ExportToHtml(System.String,GemBox.Spreadsheet.HtmlExporterOptions,System.Boolean)">CellRange.ExportToHtml</see> metods can be used.</remarks>
            <param name="filePath">File path.</param>
            <param name="options">Options that describe exporting process. 
            If the value is null, new HtmlExporterOptions is created with <see cref="P:GemBox.Spreadsheet.HtmlExporterOptions.ShowColumnLetters">HtmlExporterOptions.ShowColumnLetters</see> and <see cref="P:GemBox.Spreadsheet.HtmlExporterOptions.ShowRowNumbers">HtmlExporterOptions.ShowRowNumbers</see> set to true.</param>
            <param name="indented">Saved file will use XmlTextWriter with Formatting property set to Formatting.Indented.</param>
            <example>
    GemBox.Spreadsheet has <see cref="P:GemBox.Spreadsheet.ExcelCell.Value">Value</see> property that holds value and <see cref="P:GemBox.Spreadsheet.CellStyle.NumberFormat">NumberFormat</see> property that holds information about format of that value.
    GemBox.Spreadsheet doesn’t have code that combines these two things (value and number format). To get display text that MS Excel shows to the user, user needs to make custom method that combines ExcelCell.Value and CellStyle.NumberFormat.
    This sample shows implementation that will work for most cases.
    <code lang="vbnet">
      Sub Main()
        Dim ef = New ExcelFile()

        ef.LoadXlsx("Book1.xlsx", XlsxOptions.None)

        ef.SaveHtml("out.html", New HtmlExporterOptions() With {
          .MethodCellValueToHtml = Function(cell, position)
              Return TryGetDisplayString(cell)
            End Function
        }, True)
      End Sub

      ' This method works for most number formats.
      Private Function TryGetDisplayString(cell As ExcelCell) As String

        If cell Is Nothing Or cell.Value Is Nothing Then
          Return String.Empty
        End If

        Dim val = cell.Value
        Dim numberFormat = cell.Style.NumberFormat

        Dim cultureInfo = System.Globalization.CultureInfo.CurrentCulture

        If val.GetType() Is GetType(Integer) Then
          Dim i = DirectCast(val, Integer)
          Return i.ToString(numberFormat, cultureInfo)
        End If
        If val.GetType() Is GetType(Double) Then
          Dim d = DirectCast(val, Double)
          Return d.ToString(numberFormat, cultureInfo)
        End If

        Return Convert.ToString(val, cultureInfo)

      End Function
    </code>
    <code lang="C#">
      private static void Main(string[] args)
      {
        ExcelFile ef = new ExcelFile();

        ef.LoadXlsx("Book1.xlsx", XlsxOptions.None);

        ef.SaveHtml("out.html", new HtmlExporterOptions()
        {
          MethodCellValueToHtml = (cell, position) =&gt; TryGetDisplayString(cell)
        }, true);
      }

      // This method works for most number formats.
      private static string TryGetDisplayString(ExcelCell cell)
      {
        if (cell == null || cell.Value == null)
          return string.Empty;

        object val = cell.Value;
        string numberFormat = cell.Style.NumberFormat;

        CultureInfo cultureInfo = CultureInfo.CurrentCulture;

        if (val is int)
        {
          int i = (int)val;
          return i.ToString(numberFormat, cultureInfo);
        }
        if (val is double)
        {
          double d = (double)val;
          return d.ToString(numberFormat, cultureInfo);
        }
        return Convert.ToString(val, cultureInfo);
      }
    </code>
  </example>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelFile.SaveHtml(System.Xml.XmlTextWriter,GemBox.Spreadsheet.HtmlExporterOptions,System.Boolean)">
            <summary>
            Saves the data from used range of the active worksheet to a XmlTextWriter in HTML format.
            </summary>
            <remarks>For HTML export <see cref="M:GemBox.Spreadsheet.DefaultHtmlExporter.DefaultPageToHtml(GemBox.Spreadsheet.HtmlExporterOptions,GemBox.Spreadsheet.CellRange)">DefaultHtmlExporter.DefaultPageToHtml</see> or <see cref="M:GemBox.Spreadsheet.CellRange.ExportToHtml(System.String,GemBox.Spreadsheet.HtmlExporterOptions,System.Boolean)">CellRange.ExportToHtml</see> metods can be used.</remarks>
            <param name="writer">Xml text writer.</param>
            <param name="options">Options that describe exporting process. 
            If the value is null, new HtmlExporterOptions is created with <see cref="P:GemBox.Spreadsheet.HtmlExporterOptions.ShowColumnLetters">HtmlExporterOptions.ShowColumnLetters</see> and <see cref="P:GemBox.Spreadsheet.HtmlExporterOptions.ShowRowNumbers">HtmlExporterOptions.ShowRowNumbers</see> set to true.</param>
            <param name="entirePage">If true, entire page will be exported. If false, only table will be exported.</param>
            <example>
    GemBox.Spreadsheet has <see cref="P:GemBox.Spreadsheet.ExcelCell.Value">Value</see> property that holds value and <see cref="P:GemBox.Spreadsheet.CellStyle.NumberFormat">NumberFormat</see> property that holds information about format of that value.
    GemBox.Spreadsheet doesn’t have code that combines these two things (value and number format). To get display text that MS Excel shows to the user, user needs to make custom method that combines ExcelCell.Value and CellStyle.NumberFormat.
    This sample shows implementation that will work for most cases.
    <code lang="vbnet">
      Sub Main()
        Dim ef = New ExcelFile()

        ef.LoadXlsx("Book1.xlsx", XlsxOptions.None)

        ef.SaveHtml("out.html", New HtmlExporterOptions() With {
          .MethodCellValueToHtml = Function(cell, position)
              Return TryGetDisplayString(cell)
            End Function
        }, True)
      End Sub

      ' This method works for most number formats.
      Private Function TryGetDisplayString(cell As ExcelCell) As String

        If cell Is Nothing Or cell.Value Is Nothing Then
          Return String.Empty
        End If

        Dim val = cell.Value
        Dim numberFormat = cell.Style.NumberFormat

        Dim cultureInfo = System.Globalization.CultureInfo.CurrentCulture

        If val.GetType() Is GetType(Integer) Then
          Dim i = DirectCast(val, Integer)
          Return i.ToString(numberFormat, cultureInfo)
        End If
        If val.GetType() Is GetType(Double) Then
          Dim d = DirectCast(val, Double)
          Return d.ToString(numberFormat, cultureInfo)
        End If

        Return Convert.ToString(val, cultureInfo)

      End Function
    </code>
    <code lang="C#">
      private static void Main(string[] args)
      {
        ExcelFile ef = new ExcelFile();

        ef.LoadXlsx("Book1.xlsx", XlsxOptions.None);

        ef.SaveHtml("out.html", new HtmlExporterOptions()
        {
          MethodCellValueToHtml = (cell, position) =&gt; TryGetDisplayString(cell)
        }, true);
      }

      // This method works for most number formats.
      private static string TryGetDisplayString(ExcelCell cell)
      {
        if (cell == null || cell.Value == null)
          return string.Empty;

        object val = cell.Value;
        string numberFormat = cell.Style.NumberFormat;

        CultureInfo cultureInfo = CultureInfo.CurrentCulture;

        if (val is int)
        {
          int i = (int)val;
          return i.ToString(numberFormat, cultureInfo);
        }
        if (val is double)
        {
          double d = (double)val;
          return d.ToString(numberFormat, cultureInfo);
        }
        return Convert.ToString(val, cultureInfo);
      }
    </code>
  </example>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelFile.AutoDetectCsvSeparator(System.IO.Stream)">
            <summary>
            Autodetects CSV separator. If there's no separators in the input stream returns (char)0. 
            </summary>
            <remarks>
            This method counts the number of occurrences of most common separtors (',', ';', '\t')
            and returns one that has occurred the most times in first 5 rows. 
            </remarks>
            <param name="stream">Input Stream.</param>
            <returns>Char that is CSV separator. If there's no separators in the input StreamReader returns (char)0, 
            and if there are two with equal number of occurance, returns first of them.</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelFile.AutoDetectCsvSeparator(System.IO.StreamReader,System.Int32,System.Char[])">
            <summary>
            Autodetects CSV separator. If there's no separators in the input stream returns (char)0. 
            </summary>
            <remarks>
            This method counts the number of occurrences of chars that are specified in the 
            array possibleSeparators, and returns one that has occurred the most times in first rowsToTest rows of StreamReader sr. 
            </remarks>
            <param name="sr">Input StreamReader.</param>
            <param name="rowsToTest">Number of rows to test.</param>
            <param name="possibleSeparators">Chars that can be CSV separators.</param>
            <returns>Char that is CSV separator. If there's no separators in the input StreamReader returns (char)0, 
            and if there are two with equal number of occurance, returns first of them.</returns>
        </member>
        <member name="E:GemBox.Spreadsheet.ExcelFile.LimitNear">
            <summary>
            Occurs when the size of XLS / CSV file in reading / writing is near 
            <b>GemBox.Spreadsheet Free</b> limit. <b>(Free version only)</b>
            </summary>
            <remarks>
            <p><b>This event is present only in Free version.</b></p>
            <p>This event is fired when 80% of maximum row count per worksheet is reached (150 * 0.8 = 120 rows) or 
            when 5 worksheets are used.</p>
            <p>This event is not fired if <see cref="E:GemBox.Spreadsheet.ExcelFile.LimitReached">LimitReached</see> 
            event is fired.</p>
            <p>You can use this event to detect when your application is close to <b>GemBox.Spreadsheet Free</b> limit. 
            For example, you can write number of used rows to a log file or send a notification e-mail.</p>
            </remarks>
            <example> Following code demonstrates how to handle <see cref="E:GemBox.Spreadsheet.ExcelFile.LimitNear">LimitNear</see> 
and <see cref="E:GemBox.Spreadsheet.ExcelFile.LimitReached">LimitReached</see> events in <b>GemBox.Spreadsheet Free</b>. 
This sample disables warning worksheet in <see cref="E:GemBox.Spreadsheet.ExcelFile.LimitNear">LimitNear</see> event 
handler and displays console messages in 
<see cref="E:GemBox.Spreadsheet.ExcelFile.LimitReached">LimitReached</see> event handler.
<code lang="vbnet">
    Sub Main()
        Dim ef As ExcelFile = New ExcelFile

        AddHandler ef.LimitNear, AddressOf ef_LimitNear
        AddHandler ef.LimitReached, AddressOf ef_LimitReached

        Dim ws As ExcelWorksheet = ef.Worksheets.Add("Sheet1")

        Dim i As Integer
        For i = 0 To 172 - 1 Step i + 1
            ws.Cells(i, 0).Value = i
        Next

        ef.SaveXls("Test.xls")
    End Sub

    Private Sub ef_LimitNear(ByVal sender As Object, ByVal e As LimitEventArgs)
        e.WriteWarningWorksheet = False
    End Sub

    Private Sub ef_LimitReached(ByVal sender As Object, ByVal e As LimitEventArgs)
        Select Case e.Operation
            Case IoOperation.XlsReading
                Console.WriteLine("Data truncated while reading XLS file: " + e.FileName)

            Case IoOperation.CsvReading
                Console.WriteLine("Data truncated while reading CSV file: " + e.FileName)

            Case IoOperation.XlsWriting
                Console.WriteLine("Data truncated while writing XLS file: " + e.FileName)
                e.WriteWarningWorksheet = False

            Case IoOperation.CsvWriting
                Console.WriteLine("Data truncated while writing CSV file: " + e.FileName)

        End Select
    End Sub
</code>
<code lang="C#">
	static void Main(string[] args)
	{
		ExcelFile ef = new ExcelFile();

		ef.LimitNear += new LimitEventHandler(ef_LimitNear);
		ef.LimitReached += new LimitEventHandler(ef_LimitReached);

		ExcelWorksheet ws = ef.Worksheets.Add("Sheet1");

		for(int i=0; i!=172; i++)
			ws.Cells[i, 0].Value = i;

		ef.SaveXls("Test.xls");
	}

	private static void ef_LimitNear(object sender, LimitEventArgs e)
	{
		e.WriteWarningWorksheet = false;
	}

	private static void ef_LimitReached(object sender, LimitEventArgs e)
	{
		switch(e.Operation)
		{
			case IoOperation.XlsReading:
				Console.WriteLine("Data truncated while reading XLS file: " + e.FileName);
				break;

			case IoOperation.CsvReading:
				Console.WriteLine("Data truncated while reading CSV file: " + e.FileName);
				break;

			case IoOperation.XlsWriting:
				Console.WriteLine("Data truncated while writing XLS file: " + e.FileName);
				e.WriteWarningWorksheet = false;
				break;

			case IoOperation.CsvWriting:
				Console.WriteLine("Data truncated while writing CSV file: " + e.FileName);
				break;
		}
	}
</code> 
</example>
            <seealso cref="E:GemBox.Spreadsheet.ExcelFile.LimitReached"/>
        </member>
        <member name="E:GemBox.Spreadsheet.ExcelFile.LimitReached">
            <summary>
            Occurs when the size of XLS / CSV file in reading / writing is above 
            <b>GemBox.Spreadsheet Free</b> limit. <b>(Free version only)</b>
            </summary>
            <remarks>
            <p><b>This event is present only in Free version.</b></p>
            <p>This event is fired when maximum row count per worksheet is reached (150 rows) or 
            when more than 5 worksheets are used.</p>
            <p>You can use this event to notify a user of your application that data is 
            only partially read / written.</p>
            </remarks>
            <example> Following code demonstrates how to handle <see cref="E:GemBox.Spreadsheet.ExcelFile.LimitNear">LimitNear</see> 
and <see cref="E:GemBox.Spreadsheet.ExcelFile.LimitReached">LimitReached</see> events in <b>GemBox.Spreadsheet Free</b>. 
This sample disables warning worksheet in <see cref="E:GemBox.Spreadsheet.ExcelFile.LimitNear">LimitNear</see> event 
handler and displays console messages in 
<see cref="E:GemBox.Spreadsheet.ExcelFile.LimitReached">LimitReached</see> event handler.
<code lang="vbnet">
    Sub Main()
        Dim ef As ExcelFile = New ExcelFile

        AddHandler ef.LimitNear, AddressOf ef_LimitNear
        AddHandler ef.LimitReached, AddressOf ef_LimitReached

        Dim ws As ExcelWorksheet = ef.Worksheets.Add("Sheet1")

        Dim i As Integer
        For i = 0 To 172 - 1 Step i + 1
            ws.Cells(i, 0).Value = i
        Next

        ef.SaveXls("Test.xls")
    End Sub

    Private Sub ef_LimitNear(ByVal sender As Object, ByVal e As LimitEventArgs)
        e.WriteWarningWorksheet = False
    End Sub

    Private Sub ef_LimitReached(ByVal sender As Object, ByVal e As LimitEventArgs)
        Select Case e.Operation
            Case IoOperation.XlsReading
                Console.WriteLine("Data truncated while reading XLS file: " + e.FileName)

            Case IoOperation.CsvReading
                Console.WriteLine("Data truncated while reading CSV file: " + e.FileName)

            Case IoOperation.XlsWriting
                Console.WriteLine("Data truncated while writing XLS file: " + e.FileName)
                e.WriteWarningWorksheet = False

            Case IoOperation.CsvWriting
                Console.WriteLine("Data truncated while writing CSV file: " + e.FileName)

        End Select
    End Sub
</code>
<code lang="C#">
	static void Main(string[] args)
	{
		ExcelFile ef = new ExcelFile();

		ef.LimitNear += new LimitEventHandler(ef_LimitNear);
		ef.LimitReached += new LimitEventHandler(ef_LimitReached);

		ExcelWorksheet ws = ef.Worksheets.Add("Sheet1");

		for(int i=0; i!=172; i++)
			ws.Cells[i, 0].Value = i;

		ef.SaveXls("Test.xls");
	}

	private static void ef_LimitNear(object sender, LimitEventArgs e)
	{
		e.WriteWarningWorksheet = false;
	}

	private static void ef_LimitReached(object sender, LimitEventArgs e)
	{
		switch(e.Operation)
		{
			case IoOperation.XlsReading:
				Console.WriteLine("Data truncated while reading XLS file: " + e.FileName);
				break;

			case IoOperation.CsvReading:
				Console.WriteLine("Data truncated while reading CSV file: " + e.FileName);
				break;

			case IoOperation.XlsWriting:
				Console.WriteLine("Data truncated while writing XLS file: " + e.FileName);
				e.WriteWarningWorksheet = false;
				break;

			case IoOperation.CsvWriting:
				Console.WriteLine("Data truncated while writing CSV file: " + e.FileName);
				break;
		}
	}
</code> 
</example>
            <seealso cref="E:GemBox.Spreadsheet.ExcelFile.LimitNear"/>
        </member>
        <member name="E:GemBox.Spreadsheet.ExcelFile.IoWarning">
            <summary>
            Fired for unexpected situations when reading or writing XLS / CSV files.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelFile.Worksheets">
            <summary>
            Collection of all worksheets (<see cref="T:GemBox.Spreadsheet.ExcelWorksheet">ExcelWorksheet</see>) in a workbook. 
            </summary>
            <seealso cref="T:GemBox.Spreadsheet.ExcelWorksheet"/>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelFile.RowColumnResolutionMethod">
            <summary>
            Gets or sets the <see cref="T:GemBox.Spreadsheet.CellStyle">CellStyle</see> resolution method.
            </summary>
            <remarks>
            <p>
            Because of limitations of Microsoft Excel file format, every cell must be written to file with
            resolved <see cref="T:GemBox.Spreadsheet.CellStyle">CellStyle</see>. In the case where a cell doesn't 
            have specific property set on its <see cref="P:GemBox.Spreadsheet.ExcelCell.Style">Style</see> and that 
            property is set on both row and column that contain that cell, a cell will inherit property value 
            from row or column <see cref="P:GemBox.Spreadsheet.ExcelColumnRowBase.Style">Style</see>, depending 
            on the resolution method.
            </p>
            <p>
            Default value for this property is <see cref="F:GemBox.Spreadsheet.RowColumnResolutionMethod.RowOverColumn">
            RowOverColumn</see>.
            </p>
            </remarks>
            <example> Following code will result in a file where cell will have right alignment because same column cell 
style property takes precedence over row cell style property. Note that resolution is property based, in 
other words if column in this case had <see cref="P:GemBox.Spreadsheet.CellStyle.VerticalAlignment">
VerticalAlignment</see> set cell would inherit both <see cref="P:GemBox.Spreadsheet.CellStyle.HorizontalAlignment">
HorizontalAlignment</see> and <see cref="P:GemBox.Spreadsheet.CellStyle.VerticalAlignment">VerticalAlignment</see> 
from row and column. 
<code lang="vbnet">
	excelFile.RowColumnResolutionMethod = RowColumnResolutionMethod.ColumnOverRow
	excelFile.Worksheets(0).Cells("B2").Value = "B2"
	excelFile.Worksheets(0).Rows("2").Style.HorizontalAlignment = HorizontalAlignmentStyle.Center
	excelFile.Worksheets(0).Columns("B").Style.HorizontalAlignment = HorizontalAlignmentStyle.Right
</code>
<code lang="C#">
	excelFile.RowColumnResolutionMethod = RowColumnResolutionMethod.ColumnOverRow;
	excelFile.Worksheets[0].Cells["B2"].Value = "B2";
	excelFile.Worksheets[0].Rows["2"].Style.HorizontalAlignment = HorizontalAlignmentStyle.Center;
	excelFile.Worksheets[0].Columns["B"].Style.HorizontalAlignment = HorizontalAlignmentStyle.Right;
</code> 
</example>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelFile.Protected">
            <summary>
            Gets or sets the workbook protection flag.
            </summary>
            <remarks>
            This property is simply written to Excel file and has no effect on the behavior of this library.
            For more information on workbook protection, consult Microsoft Excel documentation.
            </remarks>
            <seealso cref="P:GemBox.Spreadsheet.ExcelWorksheet.Protected">ExcelWorksheet.Protected</seealso>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelFile.GroupMethodsAffectedCellsLimit">
            <summary>
            Maximum number of affected cells in group set methods.
            </summary>
            <remarks>
            If user tries to modify all cells in a group which has more cells than specified limit, exception
            will be thrown. This property was introduced to prevent users from accidentally modifying millions
            of cells which results in a long delay, a large memory allocation and a big resulting file. You can 
            set this limit to value which suits your needs (minimum is 5).
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelFile.Use1904DateSystem">
            <summary>
            Gets or sets whether 1904 date system is used.
            </summary>
            <remarks>
            Default value for this property is <b>false</b>.
            For more information on 1904 date system, consult Microsoft Excel documentation.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelFile.CsvParseNumbersDuringLoad">
            <summary>
            Gets or sets whether LoadCsv() methods will try to convert text values to numbers.
            </summary>
            <remarks>
            <p>Default value for this property is <b>true</b>.</p>
            <p>All values (including numbers) in CSV files are stored as text. By default, 
            any of <see cref="M:GemBox.Spreadsheet.ExcelFile.LoadCsv(System.String,System.Char)">LoadCsv()</see> 
            overloads will try to parse text values as numbers and if successful
            cell will be filled with <see cref="T:System.Double">Double</see> value. If
            you don't want such behaviour (for example, you want IDs like "00935" to remain
            strings), set this property to <b>false</b>.</p>
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelFile.CsvAlwaysQuoteValues">
            <summary>
            Gets or sets whether SaveCsv() methods will always put values in quotes.
            </summary>
            <remarks>
            <p>Default value for this property is <b>true</b>.</p>
            <p>All values (including numbers) in CSV files are stored as text. If this property is
            <b>true</b>, any of <see cref="M:GemBox.Spreadsheet.ExcelFile.SaveCsv(System.String,System.Char)">SaveCsv()</see> 
            overloads will always put values in quotes. If this propery is <b>false</b>, only values that
            contain special characters (quotes or CSV separator) will be quoted.</p>
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelFile.CsvAllowNewlineInQuotes">
            <summary>
            Gets or sets whether SaveCsv() methods will allow newline in quotes.
            </summary>
            <remarks>
            <p>Default value for this property is <b>true</b>.</p>
            <p>If this property is <b>true</b>, newline in quoted value will be threated as part of that value. 
            If this propery is <b>false</b>, newline in quoted value will be threated as the beginning of the new row.</p>
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelFile.DefaultFontName">
            <summary>
            Gets or sets name of the default font used in the workbook.
            </summary>
            <remarks>
            Default value for this property is "Arial".
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelFile.DefaultFontSize">
            <summary>
            Gets or sets default font size.
            </summary>
            <remarks>
            <p>Unit is twip (1/20th of a point).</p>
            <p>Default value of this property is 200.</p>
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelFile.DelayFormulaParse">
            <summary>
            Delays formula parsing until one of SaveXls methods is called.
            </summary>
            <remarks>
            <p>Old XLS format requires all formulas to be parsed and saved to XLS files as special
            tokens in RPN (Reverse Polish notation). GemBox.Spreadsheet only knows how to parse limited
            set of formulas listed at <see cref="P:GemBox.Spreadsheet.ExcelCell.Formula">ExcelCell.Formula</see>
            page. Only listed formulas can be saved to XLS file.</p>
            <p>New XLSX (Open XML) format stores formulas as strings and leaves formula parsing to applications
            that read XLSX documents. Therefore, ALL formulas are supported when writing/reading XLSX files.</p>
            <p>If this property is true, each set of <see cref="P:GemBox.Spreadsheet.ExcelCell.Formula">
            ExcelCell.Formula</see> property will just store formula string. When one of
            <see cref="M:GemBox.Spreadsheet.ExcelFile.SaveXls(System.String)">ExcelFile.SaveXls</see> methods is called
            formulas are parsed and exception is thrown if formula is not supported or in bad format.
            When XLSX is saved, formulas are not parsed, they are just saved as strings.
            If the formula is in bad format, MS Excel or other application will report an error in formula.
            </p>
            <p>If this property is false, formula string is parsed every time you set 
            <see cref="P:GemBox.Spreadsheet.ExcelCell.Formula">ExcelCell.Formula</see> property. You will
            limit formulas to the ones supported by GemBox.Spreadsheet parser and the exception will be
            thrown immediately if the formula is not supported or in bad format.</p>
            <p>Default value of this property is <b>true</b>.</p>
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelFile.DocumentProperties">
            <summary>
            Gets <see cref="P:GemBox.Spreadsheet.ExcelFile.DocumentProperties"/> of this <see cref="T:GemBox.Spreadsheet.ExcelFile"/>.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelFile.DefinedNames">
            <summary>
            Gets the collection of defined names that are not directly related with one cell range.
            Supported in XLSX only.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.BuiltInDocumentProperties">
            <summary>
            Enumeration of available built-in document properties.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.BuiltInDocumentProperties.Title">
            <summary>
            Title of the document.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.BuiltInDocumentProperties.Author">
            <summary>
            Name of the document's author.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.BuiltInDocumentProperties.Subject">
            <summary>
            Subject of the document.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.BuiltInDocumentProperties.Comments">
            <summary>
            Document comments.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.BuiltInDocumentProperties.Category">
            <summary>
            Category of the document.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.BuiltInDocumentProperties.Status">
            <summary>
            Status of the document.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.BuiltInDocumentProperties.Keywords">
            <summary>
            Document keywords.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.BuiltInDocumentProperties.LastSavedBy">
            <summary>
            Name of the last author.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.BuiltInDocumentProperties.Manager">
            <summary>
            Manager.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.BuiltInDocumentProperties.Company">
            <summary>
            Company.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.BuiltInDocumentProperties.HyperlinkBase">
            <summary>
            Base hyperlink.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.DocumentProperties">
            <summary>
            Contains a collection of built-in and custom document properties.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.DocumentProperties.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:GemBox.Spreadsheet.DocumentProperties"/>.
            </summary>
            <returns>A <see cref="T:System.String"/> that represents the current <see cref="T:GemBox.Spreadsheet.DocumentProperties"/>.</returns>
        </member>
        <member name="P:GemBox.Spreadsheet.DocumentProperties.BuiltIn">
            <summary>
            Gets a collection of built-in document properties.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.DocumentProperties.Custom">
            <summary>
            Gets a collection of custom document properties.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.NumberFormatCollection.SetNumberFormat(System.Int32,System.String)">
            <summary>
            This method is designed to be used ONLY for Excel file reading.
            </summary>
            <param name="index"></param>
            <param name="formatString"></param>
        </member>
        <member name="T:GemBox.Spreadsheet.XlsOptions">
            <summary>
            Options specified when reading XLS files.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.XlsOptions.None">
            <summary>
            Do not preserve records. Only records fully supported by GemBox.Spreadsheet API will be loaded.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.XlsOptions.PreserveGlobalRecords">
            <summary>
            Preserve global (workbook) records.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.XlsOptions.PreserveWorksheetRecords">
            <summary>
            Preserve worksheet records.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.XlsOptions.PreserveSummaries">
            <summary>
            Preserve summaries.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.XlsOptions.PreserveMacros">
            <summary>
            Preserve macros and VBA code.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.XlsOptions.PreserveAll">
            <summary>
            Preserve all possible information.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.XlsxOptions">
            <summary>
            Options specified when reading XLSX files.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.XlsxOptions.None">
            <summary>
            Do not preserve XLSX parts. Only parts recognized by GemBox.Spreadsheet API will be loaded.
            Use this if you are just loading XLSX file or you don't want to preserve unrecognized 
            XLSX parts for next save.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.XlsxOptions.PreserveKeepOpen">
            <summary>
            Preserves unrecognized XLSX parts in a way it keeps loaded file open. Use if locking of input file
            for reading is not a problem and you want to save RAM/CPU when working with large files.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.XlsxOptions.PreserveMakeCopy">
            <summary>
            Preserves unrecognized XLSX parts in a way it makes a copy of input file in memory. Use if 
            locking of input file presents a problem or you are not working with large files.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.OdsOptions">
            <summary>
            Options specified when loading ODS files.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.OdsOptions.None">
            <summary>
            Do not preserve ODS parts and ignore display values (display strings). Only parts recognized 
            by GemBox.Spreadsheet API will be loaded.
            Use this if you are just loading ODS file or you don't want to preserve unrecognized 
            ODS parts for next save.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.OdsOptions.PreserveKeepOpen">
            <summary>
            Preserves unrecognized ODS parts in a way it keeps loaded file open. Use if locking of input file
            for reading is not a problem and you want to save RAM/CPU when working with large files.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.OdsOptions.PreserveMakeCopy">
            <summary>
            Preserves unrecognized ODS parts in a way it makes a copy of input file in memory. Use if 
            locking of input file presents a problem or you are not working with large files.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.OdsOptions.ReadDisplayValues">
            <summary>
            Reads display values instead of stored values. Values in ODS are stored as value - display string pairs.
            Normally stored value is read but that looses number formatting. If you want to read value as
            formatted display string (for example, date as "Wednesday, May 5th, 2009" string), set this flag.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.CsvType">
            <summary>
            Formatting type for CSV files.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.CsvType.CommaDelimited">
            <summary>
            Comma delimited CSV (most frequently used). 
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.CsvType.SemicolonDelimited">
            <summary>
            Semicolon delimited CSV (used by Excel if current culture specifies comma as decimal separator).
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.CsvType.TabDelimited">
            <summary>
            Tab delimited CSV.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.RowColumnResolutionMethod">
            <summary>
            Defines different methods of <see cref="T:GemBox.Spreadsheet.CellStyle">CellStyle</see> resolution.
            </summary>
            <seealso cref="P:GemBox.Spreadsheet.ExcelFile.RowColumnResolutionMethod">ExcelFile.RowColumnResolutionMethod</seealso>
        </member>
        <member name="F:GemBox.Spreadsheet.RowColumnResolutionMethod.RowOverColumn">
            <summary>
            Row has precedence over column.
            </summary>
            <seealso cref="P:GemBox.Spreadsheet.ExcelFile.RowColumnResolutionMethod">ExcelFile.RowColumnResolutionMethod</seealso>
        </member>
        <member name="F:GemBox.Spreadsheet.RowColumnResolutionMethod.ColumnOverRow">
            <summary>
            Column has precedence over row.
            </summary>
            <seealso cref="P:GemBox.Spreadsheet.ExcelFile.RowColumnResolutionMethod">ExcelFile.RowColumnResolutionMethod</seealso>
        </member>
        <member name="T:GemBox.Spreadsheet.LimitEventHandler">
            <summary>
            Delegate for handling the <see cref="E:GemBox.Spreadsheet.ExcelFile.LimitNear">ExcelFile.LimitNear</see>
            and <see cref="E:GemBox.Spreadsheet.ExcelFile.LimitReached">ExcelFile.LimitReached</see> 
            events. <b>(Free version only)</b>
            </summary>
            <remarks>
            <p><b>This delegate is present only in Free version.</b></p>
            </remarks>
        </member>
        <member name="T:GemBox.Spreadsheet.LimitEventArgs">
            <summary>
            Event parameters used for the <see cref="E:GemBox.Spreadsheet.ExcelFile.LimitNear">ExcelFile.LimitNear</see>
            and <see cref="E:GemBox.Spreadsheet.ExcelFile.LimitReached">ExcelFile.LimitReached</see> 
            events. <b>(Free version only)</b>
            </summary>
            <remarks>
            <p><b>This class is present only in Free version.</b></p>
            </remarks>
            <example> Following code demonstrates how to handle <see cref="E:GemBox.Spreadsheet.ExcelFile.LimitNear">LimitNear</see> 
and <see cref="E:GemBox.Spreadsheet.ExcelFile.LimitReached">LimitReached</see> events in <b>GemBox.Spreadsheet Free</b>. 
This sample disables warning worksheet in <see cref="E:GemBox.Spreadsheet.ExcelFile.LimitNear">LimitNear</see> event 
handler and displays console messages in 
<see cref="E:GemBox.Spreadsheet.ExcelFile.LimitReached">LimitReached</see> event handler.
<code lang="vbnet">
    Sub Main()
        Dim ef As ExcelFile = New ExcelFile

        AddHandler ef.LimitNear, AddressOf ef_LimitNear
        AddHandler ef.LimitReached, AddressOf ef_LimitReached

        Dim ws As ExcelWorksheet = ef.Worksheets.Add("Sheet1")

        Dim i As Integer
        For i = 0 To 172 - 1 Step i + 1
            ws.Cells(i, 0).Value = i
        Next

        ef.SaveXls("Test.xls")
    End Sub

    Private Sub ef_LimitNear(ByVal sender As Object, ByVal e As LimitEventArgs)
        e.WriteWarningWorksheet = False
    End Sub

    Private Sub ef_LimitReached(ByVal sender As Object, ByVal e As LimitEventArgs)
        Select Case e.Operation
            Case IoOperation.XlsReading
                Console.WriteLine("Data truncated while reading XLS file: " + e.FileName)

            Case IoOperation.CsvReading
                Console.WriteLine("Data truncated while reading CSV file: " + e.FileName)

            Case IoOperation.XlsWriting
                Console.WriteLine("Data truncated while writing XLS file: " + e.FileName)
                e.WriteWarningWorksheet = False

            Case IoOperation.CsvWriting
                Console.WriteLine("Data truncated while writing CSV file: " + e.FileName)

        End Select
    End Sub
</code>
<code lang="C#">
	static void Main(string[] args)
	{
		ExcelFile ef = new ExcelFile();

		ef.LimitNear += new LimitEventHandler(ef_LimitNear);
		ef.LimitReached += new LimitEventHandler(ef_LimitReached);

		ExcelWorksheet ws = ef.Worksheets.Add("Sheet1");

		for(int i=0; i!=172; i++)
			ws.Cells[i, 0].Value = i;

		ef.SaveXls("Test.xls");
	}

	private static void ef_LimitNear(object sender, LimitEventArgs e)
	{
		e.WriteWarningWorksheet = false;
	}

	private static void ef_LimitReached(object sender, LimitEventArgs e)
	{
		switch(e.Operation)
		{
			case IoOperation.XlsReading:
				Console.WriteLine("Data truncated while reading XLS file: " + e.FileName);
				break;

			case IoOperation.CsvReading:
				Console.WriteLine("Data truncated while reading CSV file: " + e.FileName);
				break;

			case IoOperation.XlsWriting:
				Console.WriteLine("Data truncated while writing XLS file: " + e.FileName);
				e.WriteWarningWorksheet = false;
				break;

			case IoOperation.CsvWriting:
				Console.WriteLine("Data truncated while writing CSV file: " + e.FileName);
				break;
		}
	}
</code> 
</example>
        </member>
        <member name="P:GemBox.Spreadsheet.LimitEventArgs.FileName">
            <summary>
            Gets the file name passed to the XLS / CSV file reading / writing method.
            </summary>
            <remarks>
            You can use this property to handle different files in a different way inside your event handlers.
            </remarks>
            <example> Following code demonstrates how to handle <see cref="E:GemBox.Spreadsheet.ExcelFile.LimitNear">LimitNear</see> 
and <see cref="E:GemBox.Spreadsheet.ExcelFile.LimitReached">LimitReached</see> events in <b>GemBox.Spreadsheet Free</b>. 
This sample disables warning worksheet in <see cref="E:GemBox.Spreadsheet.ExcelFile.LimitNear">LimitNear</see> event 
handler and displays console messages in 
<see cref="E:GemBox.Spreadsheet.ExcelFile.LimitReached">LimitReached</see> event handler.
<code lang="vbnet">
    Sub Main()
        Dim ef As ExcelFile = New ExcelFile

        AddHandler ef.LimitNear, AddressOf ef_LimitNear
        AddHandler ef.LimitReached, AddressOf ef_LimitReached

        Dim ws As ExcelWorksheet = ef.Worksheets.Add("Sheet1")

        Dim i As Integer
        For i = 0 To 172 - 1 Step i + 1
            ws.Cells(i, 0).Value = i
        Next

        ef.SaveXls("Test.xls")
    End Sub

    Private Sub ef_LimitNear(ByVal sender As Object, ByVal e As LimitEventArgs)
        e.WriteWarningWorksheet = False
    End Sub

    Private Sub ef_LimitReached(ByVal sender As Object, ByVal e As LimitEventArgs)
        Select Case e.Operation
            Case IoOperation.XlsReading
                Console.WriteLine("Data truncated while reading XLS file: " + e.FileName)

            Case IoOperation.CsvReading
                Console.WriteLine("Data truncated while reading CSV file: " + e.FileName)

            Case IoOperation.XlsWriting
                Console.WriteLine("Data truncated while writing XLS file: " + e.FileName)
                e.WriteWarningWorksheet = False

            Case IoOperation.CsvWriting
                Console.WriteLine("Data truncated while writing CSV file: " + e.FileName)

        End Select
    End Sub
</code>
<code lang="C#">
	static void Main(string[] args)
	{
		ExcelFile ef = new ExcelFile();

		ef.LimitNear += new LimitEventHandler(ef_LimitNear);
		ef.LimitReached += new LimitEventHandler(ef_LimitReached);

		ExcelWorksheet ws = ef.Worksheets.Add("Sheet1");

		for(int i=0; i!=172; i++)
			ws.Cells[i, 0].Value = i;

		ef.SaveXls("Test.xls");
	}

	private static void ef_LimitNear(object sender, LimitEventArgs e)
	{
		e.WriteWarningWorksheet = false;
	}

	private static void ef_LimitReached(object sender, LimitEventArgs e)
	{
		switch(e.Operation)
		{
			case IoOperation.XlsReading:
				Console.WriteLine("Data truncated while reading XLS file: " + e.FileName);
				break;

			case IoOperation.CsvReading:
				Console.WriteLine("Data truncated while reading CSV file: " + e.FileName);
				break;

			case IoOperation.XlsWriting:
				Console.WriteLine("Data truncated while writing XLS file: " + e.FileName);
				e.WriteWarningWorksheet = false;
				break;

			case IoOperation.CsvWriting:
				Console.WriteLine("Data truncated while writing CSV file: " + e.FileName);
				break;
		}
	}
</code> 
</example>
        </member>
        <member name="P:GemBox.Spreadsheet.LimitEventArgs.Operation">
            <summary>
            Indicates which operation caused this event to fire.
            </summary>
            <remarks>
            You can use this property to handle XLS / CSV or reading / writing operations differently 
            inside your event handlers.
            </remarks>
            <example> Following code demonstrates how to handle <see cref="E:GemBox.Spreadsheet.ExcelFile.LimitNear">LimitNear</see> 
and <see cref="E:GemBox.Spreadsheet.ExcelFile.LimitReached">LimitReached</see> events in <b>GemBox.Spreadsheet Free</b>. 
This sample disables warning worksheet in <see cref="E:GemBox.Spreadsheet.ExcelFile.LimitNear">LimitNear</see> event 
handler and displays console messages in 
<see cref="E:GemBox.Spreadsheet.ExcelFile.LimitReached">LimitReached</see> event handler.
<code lang="vbnet">
    Sub Main()
        Dim ef As ExcelFile = New ExcelFile

        AddHandler ef.LimitNear, AddressOf ef_LimitNear
        AddHandler ef.LimitReached, AddressOf ef_LimitReached

        Dim ws As ExcelWorksheet = ef.Worksheets.Add("Sheet1")

        Dim i As Integer
        For i = 0 To 172 - 1 Step i + 1
            ws.Cells(i, 0).Value = i
        Next

        ef.SaveXls("Test.xls")
    End Sub

    Private Sub ef_LimitNear(ByVal sender As Object, ByVal e As LimitEventArgs)
        e.WriteWarningWorksheet = False
    End Sub

    Private Sub ef_LimitReached(ByVal sender As Object, ByVal e As LimitEventArgs)
        Select Case e.Operation
            Case IoOperation.XlsReading
                Console.WriteLine("Data truncated while reading XLS file: " + e.FileName)

            Case IoOperation.CsvReading
                Console.WriteLine("Data truncated while reading CSV file: " + e.FileName)

            Case IoOperation.XlsWriting
                Console.WriteLine("Data truncated while writing XLS file: " + e.FileName)
                e.WriteWarningWorksheet = False

            Case IoOperation.CsvWriting
                Console.WriteLine("Data truncated while writing CSV file: " + e.FileName)

        End Select
    End Sub
</code>
<code lang="C#">
	static void Main(string[] args)
	{
		ExcelFile ef = new ExcelFile();

		ef.LimitNear += new LimitEventHandler(ef_LimitNear);
		ef.LimitReached += new LimitEventHandler(ef_LimitReached);

		ExcelWorksheet ws = ef.Worksheets.Add("Sheet1");

		for(int i=0; i!=172; i++)
			ws.Cells[i, 0].Value = i;

		ef.SaveXls("Test.xls");
	}

	private static void ef_LimitNear(object sender, LimitEventArgs e)
	{
		e.WriteWarningWorksheet = false;
	}

	private static void ef_LimitReached(object sender, LimitEventArgs e)
	{
		switch(e.Operation)
		{
			case IoOperation.XlsReading:
				Console.WriteLine("Data truncated while reading XLS file: " + e.FileName);
				break;

			case IoOperation.CsvReading:
				Console.WriteLine("Data truncated while reading CSV file: " + e.FileName);
				break;

			case IoOperation.XlsWriting:
				Console.WriteLine("Data truncated while writing XLS file: " + e.FileName);
				e.WriteWarningWorksheet = false;
				break;

			case IoOperation.CsvWriting:
				Console.WriteLine("Data truncated while writing CSV file: " + e.FileName);
				break;
		}
	}
</code> 
</example>
        </member>
        <member name="P:GemBox.Spreadsheet.LimitEventArgs.MaxRowCount">
            <summary>
            Gets the maximum number of rows used.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.LimitEventArgs.WorksheetCount">
            <summary>
            Gets the number of worksheets used.
            </summary>
            <remarks>
            <p>For CSV files, this is always 1 (as only 
            <see cref="P:GemBox.Spreadsheet.ExcelWorksheetCollection.ActiveWorksheet">ActiveWorksheet</see> is used).</p>
            <p>When writing XLS files, warning worksheet is not counted.</p>
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.LimitEventArgs.WriteWarningWorksheet">
            <summary>
            Gets or sets whether the warning worksheet should be created when writing XLS file.
            </summary>
            <remarks>
            This property is ignored for CSV files and when reading XLS files.
            </remarks>
            <example> Following code demonstrates how to handle <see cref="E:GemBox.Spreadsheet.ExcelFile.LimitNear">LimitNear</see> 
and <see cref="E:GemBox.Spreadsheet.ExcelFile.LimitReached">LimitReached</see> events in <b>GemBox.Spreadsheet Free</b>. 
This sample disables warning worksheet in <see cref="E:GemBox.Spreadsheet.ExcelFile.LimitNear">LimitNear</see> event 
handler and displays console messages in 
<see cref="E:GemBox.Spreadsheet.ExcelFile.LimitReached">LimitReached</see> event handler.
<code lang="vbnet">
    Sub Main()
        Dim ef As ExcelFile = New ExcelFile

        AddHandler ef.LimitNear, AddressOf ef_LimitNear
        AddHandler ef.LimitReached, AddressOf ef_LimitReached

        Dim ws As ExcelWorksheet = ef.Worksheets.Add("Sheet1")

        Dim i As Integer
        For i = 0 To 172 - 1 Step i + 1
            ws.Cells(i, 0).Value = i
        Next

        ef.SaveXls("Test.xls")
    End Sub

    Private Sub ef_LimitNear(ByVal sender As Object, ByVal e As LimitEventArgs)
        e.WriteWarningWorksheet = False
    End Sub

    Private Sub ef_LimitReached(ByVal sender As Object, ByVal e As LimitEventArgs)
        Select Case e.Operation
            Case IoOperation.XlsReading
                Console.WriteLine("Data truncated while reading XLS file: " + e.FileName)

            Case IoOperation.CsvReading
                Console.WriteLine("Data truncated while reading CSV file: " + e.FileName)

            Case IoOperation.XlsWriting
                Console.WriteLine("Data truncated while writing XLS file: " + e.FileName)
                e.WriteWarningWorksheet = False

            Case IoOperation.CsvWriting
                Console.WriteLine("Data truncated while writing CSV file: " + e.FileName)

        End Select
    End Sub
</code>
<code lang="C#">
	static void Main(string[] args)
	{
		ExcelFile ef = new ExcelFile();

		ef.LimitNear += new LimitEventHandler(ef_LimitNear);
		ef.LimitReached += new LimitEventHandler(ef_LimitReached);

		ExcelWorksheet ws = ef.Worksheets.Add("Sheet1");

		for(int i=0; i!=172; i++)
			ws.Cells[i, 0].Value = i;

		ef.SaveXls("Test.xls");
	}

	private static void ef_LimitNear(object sender, LimitEventArgs e)
	{
		e.WriteWarningWorksheet = false;
	}

	private static void ef_LimitReached(object sender, LimitEventArgs e)
	{
		switch(e.Operation)
		{
			case IoOperation.XlsReading:
				Console.WriteLine("Data truncated while reading XLS file: " + e.FileName);
				break;

			case IoOperation.CsvReading:
				Console.WriteLine("Data truncated while reading CSV file: " + e.FileName);
				break;

			case IoOperation.XlsWriting:
				Console.WriteLine("Data truncated while writing XLS file: " + e.FileName);
				e.WriteWarningWorksheet = false;
				break;

			case IoOperation.CsvWriting:
				Console.WriteLine("Data truncated while writing CSV file: " + e.FileName);
				break;
		}
	}
</code> 
</example>
        </member>
        <member name="T:GemBox.Spreadsheet.IoWarningEventHandler">
            <summary>
            Delegate for handling the notification events.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.IoOperation">
            <summary>
            Possible operations that can fire notification events.
            </summary>
            <remarks>
            This enumeration is used as event argument in notification events.
            </remarks>
        </member>
        <member name="F:GemBox.Spreadsheet.IoOperation.XlsReading">
            <summary>
            XLS reading methods.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.IoOperation.CsvReading">
            <summary>
            CSV reading methods.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.IoOperation.XlsWriting">
            <summary>
            XLS writing methods.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.IoOperation.CsvWriting">
            <summary>
            CSV writing methods.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.IoOperation.XlsxReading">
            <summary>
            XLSX reading methods.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.IoOperation.XlsxWriting">
            <summary>
            XLSX writing methods.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.IoOperation.OdsReading">
            <summary>
            ODS reading methods.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.IoOperation.OdsWriting">
            <summary>
            ODS writing methods.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.IoWarningEventArgs">
            <summary>
            Warning event arguments class used by the event which is raised on warning happens in the excel lite library
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.IoWarningEventArgs.FileName">
            <summary>
            Gets the file name passed to the XLS / CSV file reading / writing method.
            </summary>
            <remarks>
            You can use this property to handle different files in a different way inside your event handlers.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.IoWarningEventArgs.Operation">
            <summary>
            Indicates which operation caused this event to fire.
            </summary>
            <remarks>
            You can use this property to handle XLS / CSV or reading / writing operations differently 
            inside your event handlers.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.IoWarningEventArgs.WarningMsg">
            <summary>
            Gets the message explaining the specific warning.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.DefinedName">
            <summary>
            Defined name class describes defined name that is not directly related with one cell range.
            Supported in XLSX only.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.DefinedName.Name">
            <summary>
            Gets or sets the name of the defined name object.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.DefinedName.Value">
            <summary>
            Gets or sets the value of the defined name.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.DefinedName.LocalSheetIndex">
            <summary>
            Gets or sets the local sheet index of the defined name.
            If the local sheet index is -1, defined name is global.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.DefinedNameCollection">
            <summary>
            Collection of defined names that are not directly related with one cell range.
            Supported in XLSX only.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.DefinedNameCollection.AddDefinedName(System.String,System.String,System.Int32)">
            <summary>
            Adds defined name to collection and returns index of that defined name.
            </summary>
            <param name="name">Name of the defined name.</param>
            <param name="value">Range string.</param>
            <param name="localSheetIndex">Local sheet index. If the value is -1, defined name is global.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.DefinedNameCollection.RemoveDefinedName(System.String)">
            <summary>
            Removes the defined name described by name from collection.
            </summary>
            <param name="definedName">Name of the defined name.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.DefinedNameCollection.RemoveDefinedNameAt(System.Int32)">
            <summary>
            Removes the defined name described by index from collection.
            </summary>
            <param name="index">Index of the defined name.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.DefinedNameCollection.Clear">
            <summary>
            Removes all elements from defined names collection.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.DefinedNameCollection.GetEnumerator">
            <summary>
            Returns an <see cref="T:System.Collections.Generic.IEnumerator`1"/> for the collection. 
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.DefinedNameCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an <see cref="T:System.Collections.IEnumerator"/> for the collection. 
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.DefinedNameCollection.Count">
            <summary>
            Returns the number of defined names in collection.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.DefinedNameCollection.Item(System.Int32)">
            <summary>
            Gets or sets defined name described by index from collection.
            </summary>
            <param name="index">Index of the defined name.</param>
        </member>
        <member name="P:GemBox.Spreadsheet.DefinedNameCollection.Item(System.String)">
            <summary>
            Gets defined name described by name from collection.
            </summary>
            <param name="definedName">Name of the defined name.</param>
        </member>
        <member name="T:GemBox.Spreadsheet.ZlibCodec">
            <summary>
            Encoder and Decoder for ZLIB (IETF RFC1950 and RFC1951).
            </summary>
            <remarks>
            This class compresses and decompresses data according to the Deflate algorithm documented in RFC1950 and RFC1951. 
            </remarks>
        </member>
        <member name="F:GemBox.Spreadsheet.ZlibCodec.InputBuffer">
            <summary>
            The buffer from which data is taken.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ZlibCodec.NextIn">
            <summary>
            An index into the InputBuffer array, indicating where to start reading. 
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ZlibCodec.AvailableBytesIn">
            <summary>
            The number of bytes available in the InputBuffer, starting at NextIn. 
            </summary>
            <remarks>
            Generally you should set this to InputBuffer.Length before the first Inflate() or Deflate() call. 
            The class will update this number as calls to Inflate/Deflate are made.
            </remarks>
        </member>
        <member name="F:GemBox.Spreadsheet.ZlibCodec.TotalBytesIn">
            <summary>
            Total number of bytes read so far, through all calls to Inflate()/Deflate().
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ZlibCodec.OutputBuffer">
            <summary>
            Buffer to store output data.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ZlibCodec.NextOut">
            <summary>
            An index into the OutputBuffer array, indicating where to start writing. 
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ZlibCodec.AvailableBytesOut">
            <summary>
            The number of bytes available in the OutputBuffer, starting at NextOut. 
            </summary>
            <remarks>
            Generally you should set this to OutputBuffer.Length before the first Inflate() or Deflate() call. 
            The class will update this number as calls to Inflate/Deflate are made.
            </remarks>
        </member>
        <member name="F:GemBox.Spreadsheet.ZlibCodec.TotalBytesOut">
            <summary>
            Total number of bytes written to the output so far, through all calls to Inflate()/Deflate().
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ZlibCodec.Message">
            <summary>
            used for diagnostics, when something goes wrong!
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.ZlibCodec.#ctor">
            <summary>
            Create a ZlibCodec.
            </summary>
            <remarks>
            If you use this default constructor, you will later have to explicitly call 
            InitializeInflate() or InitializeDeflate() before using the ZlibCodec to compress 
            or decompress. 
            </remarks>
        </member>
        <member name="M:GemBox.Spreadsheet.ZlibCodec.InitializeInflate(System.Boolean)">
            <summary>
            Initialize the inflation state with an explicit flag to govern the handling of RFC1950 header bytes. 
            </summary>
            <remarks>
            By default, the RFC1950 header is expected.  If you want to read a zlib stream 
            you should specify true for expectRfc1950Header.  If you have a deflate stream, you will
            want to specify false. It is only necessary to invoke this initializer explicitly if you want 
            to specify false.
            </remarks>
            <param name="expectRfc1950Header">whether to expect an RFC1950 header byte pair when reading the stream of data to be inflated.</param>
            <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.ZlibCodec.InitializeInflate(System.Int32,System.Boolean)">
            <summary>
            Initialize the inflation state with an explicit flag to govern the handling of RFC1950 header bytes. 
            </summary>
            <remarks>
            If you want to read a zlib stream 
            you should specify true for expectRfc1950Header.  If you have a deflate stream, you will
            want to specify false. 
            </remarks>
            <param name="expectRfc1950Header">whether to expect an RFC1950 header byte pair when reading 
            the stream of data to be inflated.</param>
            <param name="windowBits">The number of window bits to use. If you need to ask what that is, 
            then you shouldn't be calling this initializer.</param>
            <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.ZlibCodec.Inflate(System.Int32)">
             <summary>
             Inflate the data in the InputBuffer, placing the result in the OutputBuffer.
             </summary>
             <remarks>
             You must have set InputBuffer and OutputBuffer, NextIn and NextOut, and AvailableBytesIn and 
             AvailableBytesOut  before calling this method.
             </remarks>
             <example>
             <code>
             private void InflateBuffer()
             {
                 int bufferSize = 1024;
                 byte[] buffer = new byte[bufferSize];
                 ZlibCodec decompressor = new ZlibCodec();
             
                 Console.WriteLine("\n============================================");
                 Console.WriteLine("Size of Buffer to Inflate: {0} bytes.", CompressedBytes.Length);
                 MemoryStream ms = new MemoryStream(DecompressedBytes);
             
                 int rc = decompressor.InitializeInflate();
             
                 decompressor.InputBuffer = CompressedBytes;
                 decompressor.NextIn = 0;
                 decompressor.AvailableBytesIn = CompressedBytes.Length;
             
                 decompressor.OutputBuffer = buffer;
             
                 // pass 1: inflate 
                 do
                 {
                     decompressor.NextOut = 0;
                     decompressor.AvailableBytesOut = buffer.Length;
                     rc = decompressor.Inflate(ZlibConstants.Z_NO_FLUSH);
             
                     if (rc != ZlibConstants.Z_OK &amp;&amp; rc != ZlibConstants.Z_STREAM_END)
                         throw new Exception("inflating: " + decompressor.Message);
             
                     ms.Write(decompressor.OutputBuffer, 0, buffer.Length - decompressor.AvailableBytesOut);
                 }
                 while (decompressor.AvailableBytesIn &gt; 0 || decompressor.AvailableBytesOut == 0);
             
                 // pass 2: finish and flush
                 do
                 {
                     decompressor.NextOut = 0;
                     decompressor.AvailableBytesOut = buffer.Length;
                     rc = decompressor.Inflate(ZlibConstants.Z_FINISH);
             
                     if (rc != ZlibConstants.Z_STREAM_END &amp;&amp; rc != ZlibConstants.Z_OK)
                         throw new Exception("inflating: " + decompressor.Message);
             
                     if (buffer.Length - decompressor.AvailableBytesOut &gt; 0)
                         ms.Write(buffer, 0, buffer.Length - decompressor.AvailableBytesOut);
                 }
                 while (decompressor.AvailableBytesIn &gt; 0 || decompressor.AvailableBytesOut == 0);
             
                 decompressor.EndInflate();
             }
            
             </code>
             </example>
             <param name="f">I think you want to set this to Z_NO_FLUSH.</param>
             <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.ZlibCodec.EndInflate">
            <summary>
            Ends an inflation session. 
            </summary>
            <remarks>
            Call this after successively calling Inflate().  This will cause all buffers to be flushed. 
            After calling this you cannot call Inflate() without a intervening call to one of the
            InitializeInflate() overloads.
            </remarks>
            <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.ZlibCodec.InitializeDeflate(GemBox.Spreadsheet.CompressionLevel,System.Boolean)">
            <summary>
            Initialize the ZlibCodec for deflation operation, using the specified CompressionLevel, 
            and the explicit flag governing whether to emit an RFC1950 header byte pair.
            </summary>
            <remarks>
            The codec will use the MAX window bits and the specified CompressionLevel.
            </remarks>
            <param name="level">The compression level for the codec.</param>
            <param name="wantRfc1950Header">whether to emit an initial RFC1950 byte pair in the compressed stream.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.ZlibCodec.InitializeDeflate(GemBox.Spreadsheet.CompressionLevel,System.Int32,System.Boolean)">
            <summary>
            Initialize the ZlibCodec for deflation operation, using the specified CompressionLevel, 
            the specified number of window bits, and the explicit flag governing whether to emit an RFC1950 header byte pair.
            </summary>
            <param name="level">The compression level for the codec.</param>
            <param name="wantRfc1950Header">whether to emit an initial RFC1950 byte pair in the compressed stream.</param>
            <param name="bits">the number of window bits to use.  If you don't know what this means, don't use this method.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.ZlibCodec.Deflate(System.Int32)">
            <summary>
            Deflate one batch of data.
            </summary>
            <remarks>
            You must have set InputBuffer and OutputBuffer before calling this method.
            </remarks>
            <example>
            <code>
            private void DeflateBuffer(CompressionLevel level)
            {
                int bufferSize = 1024;
                byte[] buffer = new byte[bufferSize];
                ZlibCodec compressor = new ZlibCodec();
            
                Console.WriteLine("\n============================================");
                Console.WriteLine("Size of Buffer to Deflate: {0} bytes.", UncompressedBytes.Length);
                MemoryStream ms = new MemoryStream();
            
                int rc = compressor.InitializeDeflate(level);
            
                compressor.InputBuffer = UncompressedBytes;
                compressor.NextIn = 0;
                compressor.AvailableBytesIn = UncompressedBytes.Length;
            
                compressor.OutputBuffer = buffer;
            
                // pass 1: deflate 
                do
                {
                    compressor.NextOut = 0;
                    compressor.AvailableBytesOut = buffer.Length;
                    rc = compressor.Deflate(ZlibConstants.Z_NO_FLUSH);
            
                    if (rc != ZlibConstants.Z_OK &amp;&amp; rc != ZlibConstants.Z_STREAM_END)
                        throw new Exception("deflating: " + compressor.Message);
            
                    ms.Write(compressor.OutputBuffer, 0, buffer.Length - compressor.AvailableBytesOut);
                }
                while (compressor.AvailableBytesIn &gt; 0 || compressor.AvailableBytesOut == 0);
            
                // pass 2: finish and flush
                do
                {
                    compressor.NextOut = 0;
                    compressor.AvailableBytesOut = buffer.Length;
                    rc = compressor.Deflate(ZlibConstants.Z_FINISH);
            
                    if (rc != ZlibConstants.Z_STREAM_END &amp;&amp; rc != ZlibConstants.Z_OK)
                        throw new Exception("deflating: " + compressor.Message);
            
                    if (buffer.Length - compressor.AvailableBytesOut &gt; 0)
                        ms.Write(buffer, 0, buffer.Length - compressor.AvailableBytesOut);
                }
                while (compressor.AvailableBytesIn &gt; 0 || compressor.AvailableBytesOut == 0);
            
                compressor.EndDeflate();
            
                ms.Seek(0, SeekOrigin.Begin);
                CompressedBytes = new byte[compressor.TotalBytesOut];
                ms.Read(CompressedBytes, 0, CompressedBytes.Length);
            }
            </code>
            </example>
            <param name="flush">whether to flush all data as you deflate. Generally you will want to 
            use Z_NO_FLUSH here, in a series of calls to Deflate(), and then call EndDeflate() to 
            flush everything. 
            </param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.ZlibCodec.EndDeflate">
            <summary>
            End a deflation session.
            </summary>
            <remarks>
            Call this after making a series of one or more calls to Deflate(). All buffers are flushed.
            </remarks>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.XLSFileWriter.WriteMSODrawingIfNeeded(GemBox.Spreadsheet.AbsXLSRecords)">
            <summary>
            Writes the MSO drawing if needed.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.XLSFileWriter.HasShapes">
            <summary>
            Gets a value indicating whether this instance has shapes.
            </summary>
            <value>
            	<c>true</c> if this instance has shapes; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:GemBox.Spreadsheet.MsoBitmapPictureRecord.Read(System.IO.BinaryReader)">
            <summary>
            Reads data from the specified reader.
            </summary>
            <param name="reader">The source binary reader.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.MsoBitmapPictureRecord.SetData(GemBox.Spreadsheet.MsoDelayedRecords)">
            <summary>
            Sets the inner data( mso structure' data without header: atom, type, length ).
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.ImageRecordsFactory">
            <summary>
            Factory class for creation image records
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.ImageRecordsFactory.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:GemBox.Spreadsheet.ImageRecordsFactory"/> class.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.ImageRecordsFactory.CreateContainer(System.IO.BinaryReader,GemBox.Spreadsheet.MsoType)">
            <summary>
            Creates the mso container from specified mso type and reader.
            </summary>
            <param name="reader">The reader used to create appropriate container.</param>
            <param name="type">The type used to create appropriate container.</param>
            <returns></returns>
        </member>
        <member name="M:GemBox.Spreadsheet.ImageRecordsFactory.CreateContainer(GemBox.Spreadsheet.MsoType)">
            <summary>
            Creates the mso container from specified mso type.
            </summary>
            <param name="type">The type used to create appropriate container.</param>		
        </member>
        <member name="M:GemBox.Spreadsheet.ImageRecordsFactory.CreateFromReader(System.IO.BinaryReader)">
            <summary>
            Creates image record from reader.
            </summary>
            <param name="reader">The binary reader.</param>
            <returns>created image record</returns>
        </member>
        <member name="T:GemBox.Spreadsheet.AreaFormulaToken">
            <summary>
            Formula token for holding reference on cell range.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.AreaFormulaToken.regexOptions">
            <summary>
            Regular expression default settings
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.AreaFormulaToken.IsCellRangeRegex">
            <summary>
            Regula expression used to determinate whether the input string is cell range( area ) or not
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.AreaFormulaToken.firstRow">
            <summary>
            first row.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.AreaFormulaToken.#ctor(GemBox.Spreadsheet.FormulaTokenCode)">
            <summary>
            Initializes a new instance of the <see cref="T:GemBox.Spreadsheet.AreaFormulaToken"/> class.
            </summary>
            <param name="code">The FormulaTokenCode code.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.AreaFormulaToken.DelayInitialize(System.Object[])">
            <summary>
            Make custom delay initialize.
            </summary>
            <param name="data">The data for initialization which is unique for each formula token.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.AreaFormulaToken.Read(System.Byte[],System.Int32)">
            <summary>
            Initialize formula token by reading input data from array of bytes
            </summary>
            <param name="rpnBytes">input data, array of bytes</param>
            <param name="startIndex">start position for array of bytes to read from</param>
        </member>
        <member name="M:GemBox.Spreadsheet.AreaFormulaToken.ConvertToBytes">
            <summary>
            Convert formula token to array of byte representation.
            </summary>
            <returns>formula token' array of byte representation</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.AreaFormulaToken.ToString">
            <summary>
            Convert formula token to string representation.
            </summary>
            <returns>formula token string representation</returns>
        </member>
        <member name="P:GemBox.Spreadsheet.AreaFormulaToken.FirstRow">
            <summary>
            Gets the first row.
            </summary>
            <value>The first row.</value>
        </member>
        <member name="T:GemBox.Spreadsheet.CompressionLevel">
            <summary>
            The compression level to be used when using a DeflateStream or ZlibStream with CompressionMode.Compress.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.CompressionLevel.NONE">
            <summary>
            NONE means that the data will be simply stored, with no change at all.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.CompressionLevel.LEVEL0_NONE">
            <summary>
            Same as NONE.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.CompressionLevel.BEST_SPEED">
            <summary>
            The fastest but least effective compression.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.CompressionLevel.LEVEL1_BEST_SPEED">
            <summary>
            A synonym for BEST_SPEED.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.CompressionLevel.LEVEL2">
            <summary>
            A little slower, but better, than level 1.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.CompressionLevel.LEVEL3">
            <summary>
            A little slower, but better, than level 2.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.CompressionLevel.LEVEL4">
            <summary>
            A little slower, but better, than level 3.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.CompressionLevel.LEVEL5">
            <summary>
            A little slower, but better, than level 4.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.CompressionLevel.DEFAULT">
            <summary>
            The default compression level.  Do these levels even matter?  Do people even care?  
            I have never measured the speed difference.  
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.CompressionLevel.LEVEL6_DEFAULT">
            <summary>
            A synonym for DEFAULT.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.CompressionLevel.LEVEL7">
            <summary>
            Pretty good compression!
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.CompressionLevel.LEVEL8">
            <summary>
             Still better compression!
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.CompressionLevel.BEST_COMPRESSION">
            <summary>
            The "best" compression, where best means greatest reduction in size of the input data stream. 
            This is also the slowest compression.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.CompressionLevel.LEVEL9_BEST_COMPRESSION">
            <summary>
            A synonym for BEST_COMPRESSION.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.CompressionStrategy">
            <summary>
            I honestly don't know what this means, but it is possible to set it in the SetDeflateParameters() call.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.CompressionStrategy.DEFAULT">
            <summary>
            It's probably safest to just leave this alone, or select the default. 
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.CompressionStrategy.FILTERED">
            <summary>
            I don't know what this does. 
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.CompressionStrategy.HUFFMAN_ONLY">
            <summary>
            I don't know what this setting does either.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.CompressionMode">
            <summary>
            An enum to specify the direction of transcoding - whether to compress or decompress.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.CompressionMode.Compress">
            <summary>
            Used to specify that the stream should compress the data.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.CompressionMode.Decompress">
            <summary>
            Used to specify that the stream should decompress the data.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.ZlibException">
            <summary>
            A general purpose exception class for exceptions in the Zlib library.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.ZlibException.#ctor">
            <summary>
            The ZlibException class captures exception information generated
            by the Zlib library. 
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.ZlibException.#ctor(System.String)">
            <summary>
            This ctor collects a message attached to the exception.
            </summary>
            <param name="s"></param>
        </member>
        <member name="M:GemBox.Spreadsheet.SharedUtils.URShift(System.Int32,System.Int32)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.SharedUtils.URShift(System.Int32,System.Int64)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.SharedUtils.URShift(System.Int64,System.Int32)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.SharedUtils.URShift(System.Int64,System.Int64)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.SharedUtils.ReadInput(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
            <summary>Reads a number of characters from the current source Stream and writes the data to the target array at the specified index.</summary>
            <param name="sourceStream">The source Stream to read from.</param>
            <param name="target">Contains the array of characteres read from the source Stream.</param>
            <param name="start">The starting index of the target array.</param>
            <param name="count">The maximum number of characters to read from the source Stream.</param>
            <returns>The number of characters read. The number will be less than or equal to count depending on the data available in the source Stream. Returns -1 if the end of the stream is reached.</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.SharedUtils.ReadInput(System.IO.TextReader,System.Byte[],System.Int32,System.Int32)">
            <summary>Reads a number of characters from the current source TextReader and writes the data to the target array at the specified index.</summary>
            <param name="sourceTextReader">The source TextReader to read from</param>
            <param name="target">Contains the array of characteres read from the source TextReader.</param>
            <param name="start">The starting index of the target array.</param>
            <param name="count">The maximum number of characters to read from the source TextReader.</param>
            <returns>The number of characters read. The number will be less than or equal to count depending on the data available in the source TextReader. Returns -1 if the end of the stream is reached.</returns>
        </member>
        <member name="T:GemBox.Spreadsheet.Adler">
            <summary>
            Computes an Adler-32 checksum. 
            </summary>
            <remarks>
            The Adler checksum is similar to a CRC checksum, but faster to compute, though less reliable.  
            It is used in producing RFC1950 compressed streams.  The Adler checksum is a required part of the "ZLIB" standard.
            Applications will almost never need to use this class directly. 
            </remarks>
        </member>
        <member name="T:GemBox.Spreadsheet.ZipFile">
            <summary>
            The ZipFile type represents a zip archive file.  This is the main type in the 
            DotNetZip class library.  This class reads and writes zip files, as defined in the format
            for zip described by PKWare.  The compression for this implementation was, at one time, based on the
            System.IO.Compression.DeflateStream base class in the .NET Framework
            base class library, available in v2.0 and later of the .NET Framework. As of v1.7 of DotNetZip,
            the compression is provided by a managed-code version of Zlib, included with DotNetZip. 
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ZipFile.DefaultEncoding">
            <summary>
            The default text encoding used in zip archives.  It is numeric 437, also known as IBM437. 
            </summary>
            <seealso cref="P:GemBox.Spreadsheet.ZipFile.ProvisionalAlternateEncoding">ProvisionalAlternateEncoding</seealso>
        </member>
        <member name="M:GemBox.Spreadsheet.ZipFile.#ctor">
             <summary>
             Create a zip file, without specifying a target filename or stream to save to. 
             </summary>
             
             <remarks>
            
             <para>
             Instances of the ZipFile class are not multi-thread safe.  You may not party on a single
             instance with multiple threads.  You may have multiple threads that each use a distinct ZipFile 
             instance, or you can synchronize multi-thread access to a single instance.
             </para>
             
             </remarks>
             
             <example>
             This example creates a Zip archive called Backup.zip, containing all the files
             in the directory DirectoryToZip. Files within subdirectories are not zipped up.
             <code>
             using (ZipFile zip = new ZipFile())
             { 
               // Store all files found in the top level directory, into the zip archive.
               // note: this code does not recurse subdirectories!
               String[] filenames = System.IO.Directory.GetFiles(DirectoryToZip);
               foreach (String filename in filenames)
               {
                 Console.WriteLine("Adding {0}...", filename);
                 zip.AddFile(filename);
               }  
               zip.Save("Backup.zip");
             }
             </code>
            
             <code lang="VB">
             Using zip As New ZipFile
                 ' Store all files found in the top level directory, into the zip archive.
                 ' note: this code does not recurse subdirectories!
                 Dim filenames As String() = System.IO.Directory.GetFiles(DirectoryToZip)
                 Dim filename As String
                 For Each filename In filenames
                     Console.WriteLine("Adding {0}...", filename)
                     zip.AddFile(filename)
                 Next
                 zip.Save("Backup.zip")
             End Using
             </code>
             </example>
        </member>
        <member name="M:GemBox.Spreadsheet.ZipFile.AddFileStream(System.String,System.String,System.IO.Stream)">
             <summary>
             Uses the given stream as input to create an entry in the ZipFile, with the 
             given FileName and given Directory Path.  
             </summary>
            
             <remarks>
             <para>
             The stream must remain open and readable at least through the call to 
             <c>ZipFile.Save</c>.
             </para>
             <para>
             Encryption will be used on the stream data when saving the 
             ZipFile, if the Password is set on the ZipFile object prior to calling
             this method.</para>
             </remarks>
            
             <example>
             <code lang="C#">
             String ZipToCreate = "Content.zip";
             String FileNameInArchive = "Content-From-Stream.bin";
             using (ZipFile zip = new ZipFile())
             {
               ZipEntry entry= zip.AddFileStream(FileNameInArchive, "basedirectory", StreamToRead);
               entry.Comment = "The content for entry in the zip file was obtained from a stream";
               zip.AddFile("Readme.txt");
               zip.Save(ZipToCreate);
             }
             
             </code>
             <code lang="VB">
             Dim ZipToCreate As String = "Content.zip"
             Dim FileNameInArchive As String = "Content-From-Stream.bin"
             Using zip As ZipFile = New ZipFile()
               Dim entry as ZipEntry = zip.AddFileStream(FileNameInArchive, "basedirectory", Me.StreamToRead)
               entry.Comment = "The content for entry in the zip file was obtained from a stream"
               zip.AddFile("Readme.txt")
               zip.Save(ZipToCreate)
             End Using
             </code>
             </example>
            
             <param name="fileName">FileName which is shown in the ZIP File</param>
             <param name="directoryPathInArchive">
             Specifies a directory path to use to override any path in the ItemName.
             This path may, or may not, correspond to a real directory in the current filesystem.
             If the files within the zip are later extracted, this is the path used for the extracted file. 
             Passing null (nothing in VB) will use the path on the FileName, if any.  Passing the empty string ("")
             will insert the item at the root path within the archive. 
             </param>
             <param name="stream">the input stream from which to grab content for the file</param>
             <returns>The ZipEntry added.</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.ZipFile.Save">
             <summary>
             Saves the Zip archive, using the name given when the ZipFile was instantiated. 
             </summary>
            
             <remarks>
             <para>
             The zip file is written to storage only when the caller calls <c>Save</c>.  
             The Save operation writes the zip content to a temporary file. 
             Then, if the zip file already exists (for example when adding an item to a zip archive)
             this method will replace the existing zip file with this temporary file.
             If the zip file does not already exist, the temporary file is renamed 
             to the desired name.  
             </para>
            
             <para>
             When using a filesystem file for the Zip output, it is possible to call
             <c>Save</c> multiple times on the ZipFile instance. With each call the zip content
             is written to the output file. When saving to a <c>Stream</c>, after the initial
             call to <c>Save</c>, additional calls to <c>Save</c> will throw. This is because the
             stream is assumed to be a write-only stream, and after the initial <c>Save</c>, it
             is not possible to seek backwards and "unwrite" the zip file data.
             </para>
            
             <para>
             Data for entries that have been added to the <c>ZipFile</c> instance is written
             to the output when the <c>Save</c> method is called. This means that the input
             streams for those entries must be available at the time the application
             calls <c>Save</c>.  If, for example, the application adds entries with
             <c>AddFileStream</c> using a dynamically-allocated <c>MemoryStream</c>,
             the memory stream must not have been disposed before the call to <c>Save</c>.
             </para>
            
             <para>
             When using the zip library within an ASP.NET application, you may wish to set the
             <c>TempFileFolder</c> property on the <c>ZipFile</c> instance before calling Save().
             </para>
             </remarks>
            
             <seealso cref="M:GemBox.Spreadsheet.ZipFile.AddFileStream(System.String,System.String,System.IO.Stream)"/>
            
             <exception cref="T:GemBox.Spreadsheet.BadStateException">
             Thrown if you haven't specified a location or stream for saving the zip,
             either in the constructor or by setting the Name property. 
             </exception>
            
        </member>
        <member name="M:GemBox.Spreadsheet.ZipFile.Save(System.IO.Stream)">
            <summary>
            Save the zip archive to the specified stream.
            </summary>
            <param name="outputStream">The <c>System.IO.Stream</c> to write to. It must be writable.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ZipFile.Read(System.IO.Stream)">
             <summary>
             Reads a zip archive from a stream.
             </summary>
            
             <remarks>
             <para>
             This is useful when when the zip archive content is available from 
             an already-open stream. The stream must be open and readable when calling this
             method.  The stream is left open when the reading is completed. 
             </para>
             <para>
             The stream is read using the default <c>System.Text.Encoding</c>, which is the <c>IBM437</c> codepage.  
             </para>
             </remarks>
            
             <example>
             This example shows how to Read zip content from a stream, and extract
             one entry into a different stream. In this example, the filename
             "NameOfEntryInArchive.doc", refers only to the name of the entry
             within the zip archive.  A file by that name is not created in the
             filesystem.  The I/O is done strictly with the given streams.
             <code>
             using (ZipFile zip = ZipFile.Read(InputStream))
             {
               zip.Extract("NameOfEntryInArchive.doc", OutputStream);
             }
             </code>
             <code lang="VB">
             Using zip as ZipFile = ZipFile.Read(InputStream)
               zip.Extract("NameOfEntryInArchive.doc", OutputStream)
             End Using
             </code>
             </example>
            
             <param name="zipStream">the stream containing the zip data.</param>
            
             <returns>an instance of ZipFile</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.ZipFile.Read(System.IO.Stream,System.IO.TextWriter,System.Text.Encoding)">
             <summary>
             Reads a zip archive from a stream, using the specified text Encoding and the 
             specified TextWriter for status messages.
             </summary>
            
             <remarks>
             <para>
             This method is useful when when the zip archive content is available from 
             an already-open stream. The stream must be open and readable when calling this
             method.  The stream is left open when the reading is completed. 
             </para>
             </remarks>
            
             <exception cref="T:GemBox.Spreadsheet.ZipException">
             Thrown if zipStream is null.
             In this case, the inner exception is an ArgumentException.
             </exception>
            
             <param name="zipStream">the stream containing the zip data.</param>
            
             <param name="statusMessageWriter">
             The <c>System.IO.TextWriter</c> to which verbose status messages are written during
             operations on the ZipFile.  For example, in a console application,
             System.Console.Out works, and will get a message for each entry added to the
             ZipFile.  If the TextWriter is null, no verbose messages are written.
             </param>
            
             <param name="encoding">
             The text encoding to use when reading entries that do not have the UTF-8 encoding
             bit set.  Be careful specifying the encoding.  If the value you use here is not the
             same as the Encoding used when the zip archive was created (possibly by a different
             archiver) you will get unexpected results and possibly exceptions.  See the <see cref="P:GemBox.Spreadsheet.ZipFile.ProvisionalAlternateEncoding">ProvisionalAlternateEncoding</see>
             property for more information.
             </param>
             
             <returns>an instance of ZipFile</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.ZipFile.Read(System.IO.Stream,System.IO.TextWriter,System.Text.Encoding,System.EventHandler{GemBox.Spreadsheet.ReadProgressEventArgs})">
             <summary>
             Reads a zip archive from a stream, using the specified text Encoding, the 
             specified TextWriter for status messages, 
             and the specified ReadProgress event handler.
             </summary>
            
             <param name="zipStream">the stream containing the zip data.</param>
            
             <param name="statusMessageWriter">
             The <c>System.IO.TextWriter</c> to which verbose status messages are written during
             operations on the ZipFile.  For example, in a console application,
             System.Console.Out works, and will get a message for each entry added to the
             ZipFile.  If the TextWriter is null, no verbose messages are written.
             </param>
            
             <param name="encoding">
             The text encoding to use when reading entries that do not have the UTF-8 encoding
             bit set.  Be careful specifying the encoding.  If the value you use here is not the
             same as the Encoding used when the zip archive was created (possibly by a different
             archiver) you will get unexpected results and possibly exceptions.  See the <see cref="P:GemBox.Spreadsheet.ZipFile.ProvisionalAlternateEncoding">ProvisionalAlternateEncoding</see>
             property for more information.
             </param>
             
             <param name="readProgress">
             An event handler for Read operations.
             </param>
             
             <returns>an instance of ZipFile</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.ZipFile.GetEnumerator">
             <summary>
             Generic IEnumerator support, for use of a ZipFile in a foreach construct.  
             </summary>
            
             <remarks>
             You probably do not want to call <c>GetEnumerator</c> explicitly. Instead 
             it is implicitly called when you use a <c>foreach</c> loop in C#, or a 
             <c>For Each</c> loop in VB.
             </remarks>
            
             <example>
             This example reads a zipfile of a given name, then enumerates the 
             entries in that zip file, and displays the information about each 
             entry on the Console.
             <code>
             using (ZipFile zip = ZipFile.Read(zipfile))
             {
               bool header = true;
               foreach (ZipEntry e in zip)
               {
                 if (header)
                 {
                    System.Console.WriteLine("Zipfile: {0}", zip.Name);
                    System.Console.WriteLine("Version Needed: 0x{0:X2}", e.VersionNeeded);
                    System.Console.WriteLine("BitField: 0x{0:X2}", e.BitField);
                    System.Console.WriteLine("Compression Method: 0x{0:X2}", e.CompressionMethod);
                    System.Console.WriteLine("\n{1,-22} {2,-6} {3,4}   {4,-8}  {0}",
                                 "Filename", "Modified", "Size", "Ratio", "Packed");
                    System.Console.WriteLine(new System.String('-', 72));
                    header = false;
                 }
            
                 System.Console.WriteLine("{1,-22} {2,-6} {3,4:F0}%   {4,-8}  {0}",
                             e.FileName,
                             e.LastModified.ToString("yyyy-MM-dd HH:mm:ss"),
                             e.UncompressedSize,
                             e.CompressionRatio,
                             e.CompressedSize);
            
                 e.Extract();
               }
             }
             </code>
            
             <code lang="VB">
               Dim ZipFileToExtract As String = "c:\foo.zip"
               Using zip As ZipFile = ZipFile.Read(ZipFileToExtract)
                   Dim header As Boolean = True
                   Dim e As ZipEntry
                   For Each e In zip
                       If header Then
                           Console.WriteLine("Zipfile: {0}", zip.Name)
                           Console.WriteLine("Version Needed: 0x{0:X2}", e.VersionNeeded)
                           Console.WriteLine("BitField: 0x{0:X2}", e.BitField)
                           Console.WriteLine("Compression Method: 0x{0:X2}", e.CompressionMethod)
                           Console.WriteLine(ChrW(10) &amp; "{1,-22} {2,-6} {3,4}   {4,-8}  {0}", _
                             "Filename", "Modified", "Size", "Ratio", "Packed" )
                           Console.WriteLine(New String("-"c, 72))
                           header = False
                       End If
                       Console.WriteLine("{1,-22} {2,-6} {3,4:F0}%   {4,-8}  {0}", _
                         e.FileName, _
                         e.LastModified.ToString("yyyy-MM-dd HH:mm:ss"), _
                         e.UncompressedSize, _
                         e.CompressionRatio, _
                         e.CompressedSize )
                       e.Extract
                   Next
               End Using
             </code>
             </example>
             
             <returns>A generic enumerator suitable for use  within a foreach loop.</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.ZipFile.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            IEnumerator support, for use of a ZipFile in a foreach construct.  
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.ZipFile.Finalize">
            <summary>
            This is the class Destructor, which gets called implicitly when the instance is destroyed.  
            Because the ZipFile type implements IDisposable, this method calls Dispose(false).  
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.ZipFile.Dispose">
            <summary>
            Handles closing of the read and write streams associated
            to the ZipFile, if necessary.  The Dispose() method is generally 
            employed implicitly, via a using() {} statement. 
            </summary>
            <example>
            <code>
            using (ZipFile zip = ZipFile.Read(zipfile))
            {
              foreach (ZipEntry e in zip)
              {
                if (WantThisEntry(e.FileName)) 
                  zip.Extract(e.FileName, Console.OpenStandardOutput());
              }
            } // Dispose() is called implicitly here.
            </code>
            </example>
        </member>
        <member name="M:GemBox.Spreadsheet.ZipFile.Dispose(System.Boolean)">
            <summary>
            The Dispose() method.  It disposes any managed resources, 
            if the flag is set, then marks the instance disposed.
            This method is typically not called from application code.
            </summary>
            <param name="disposeManagedResources">indicates whether the method should dispose streams or not.</param>
        </member>
        <member name="P:GemBox.Spreadsheet.ZipFile.CompressionLevel">
            <summary>
            Sets the compression level to be used for entries when saving the zip archive.
            </summary>
            <remarks>
            The compression level setting is used at the time of Save(). The
            same level is applied to all ZipEntry instances contained in the ZipFile during the save.  
            If you do not set this property, the default compression level is used, which normally gives 
            a good balance of compression efficiency and compression speed.  In some tests, using 
            BEST_COMPRESSION can double the time it takes to compress, while delivering just a small
            increase in compression efficiency.  This behavior will vary with the type of data you 
            compress.  If you are in doubt, just leave this setting alone, and accept the default.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ZipFile.Comment">
             <summary>
             A comment attached to the zip archive.
             </summary>
            
             <remarks>
            
             <para>
             This property is read/write for the zipfile. It allows the application to
             specify a comment for the zipfile, or read the comment for the zipfile. 
             After setting this property, changes are only made permanent when you call a
             <c>Save()</c> method.
             </para>
            
             <para>
             According to the zip specification, the comment is not encrypted, even if there is a password
             set on the zip archive. 
             </para>
            
             <para>
             The zip spec does not describe how to encode the comment string in a code page other than IBM437. 
             Therefore, for "compliant" zip tools and libraries, comments will use IBM437.  However, there are
             situations where you want an encoded Comment, for example using code page 950 "Big-5 Chinese".
             DotNetZip will encode the comment in the code page specified by <see cref="P:GemBox.Spreadsheet.ZipFile.ProvisionalAlternateEncoding"/>,
             at the time of the call to ZipFile.Save().
             </para>
            
             <para>
             When creating a zip archive using this library, it is possible to change the value of 
             <see cref="P:GemBox.Spreadsheet.ZipFile.ProvisionalAlternateEncoding"/> between each entry you add, and between adding entries and the 
             call to Save(). Don't do this.  It will likely result in a zipfile that is not readable by 
             any tool or application. 
             For best interoperability, leave <see cref="P:GemBox.Spreadsheet.ZipFile.ProvisionalAlternateEncoding"/> alone, or 
             specify it only once, before adding any entries to the ZipFile instance.
             </para>
            
             </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ZipFile.Verbose">
            <summary>
            Indicates whether verbose output is sent to the StatusMessageWriter
            during <c>AddXxx()</c> and <c>ReadXxx()</c> operations. 
            </summary>
            <remarks>
            This is a synthetic property.  It returns true if the <see cref="P:GemBox.Spreadsheet.ZipFile.StatusMessageTextWriter">StatusMessageTextWriter</see> is non-null. 
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ZipFile.CaseSensitiveRetrieval">
            <summary>
            Indicates whether to perform case-sensitive matching on the filename when retrieving
            entries in the zipfile via the string-based indexer.  
            </summary>
            <remarks>
            The default value is <c>false</c>,
            which means DON'T do case-sensitive matching. In other words, retrieving
            zip["ReadMe.Txt"] is the same as zip["readme.txt"].
            It really makes sense to set this to <c>true</c> only if you are not running on
            Windows, which has case-insensitive filenames. But since this library is not built for
            non-Windows platforms, in most cases you should just leave this property alone. 
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ZipFile.UseZip64WhenSaving">
             <summary>
             Specify whether to use ZIP64 extensions when saving a zip archive. 
             </summary>
             <remarks>
            
             <para>
             Designed many years ago, the original zip specification from PKWARE allowed for 32-bit
             quantities for the compressed and uncompressed sizes of zip entries, as well as a
             32-bit quantity for specifying the length of the zip archive itself, and a maximum of
             65535 entries.  These limits are now regularly exceeded in many backup and archival
             scenarios.  Recently, PKWare added extensions to the original zip spec, called "ZIP64
             extensions", to raise those limitations.  This property governs whether the ZipFile
             instance will use those extensions when writing zip archives within a call to one of
             the Save() methods.  The use of these extensions is optional and explicit in DotNetZip
             because, despite the status of ZIP64 as a bona fide standard, not all other zip tools
             support ZIP64.
             </para>
             
             <para>
             Set this property to <see cref="F:GemBox.Spreadsheet.Zip64Option.Always"/> to always use ZIP64 extensions
             when saving, regardless of whether your zip archive needs it.  Suppose you add 5 files,
             each under 100k, to a ZipFile.  If you specify Always for this flag before calling the
             Save() method, you will get a ZIP64 archive, though you do not need to use ZIP64
             because none of the original zip limits had been exceeded.
             </para>
            
             <para>
             Set this property to <see cref="F:GemBox.Spreadsheet.Zip64Option.Never"/> to tell the DotNetZip library to
             never use ZIP64 extensions.  This is useful for maximum compatibility and
             interoperability, at the expense of the capability of handling large files or large
             archives.  NB: Windows Explorer in Windows XP and Windows Vista cannot currently
             extract files from a zip64 archive, so if you want to guarantee that a zip archive
             produced by this library will work in Windows Explorer, use <c>Never</c>. If you set
             this property to <see cref="F:GemBox.Spreadsheet.Zip64Option.Never"/>, and your application creates a zip
             that would exceed one of the ZIP limits, the library will throw an exception during the
             Save().
             </para>
            
             <para>
             Set this property to <see cref="F:GemBox.Spreadsheet.Zip64Option.AsNecessary"/> to tell the DotNetZip
             library to use the zip64 extensions when required by the entry. After the file is
             compressed, the original and compressed sizes are checked, and if they exceed the
             limits described above, then zip64 can be used. That is the general idea, but there is
             an additional wrinkle when saving to a non-seekable device, like the ASP.NET
             <c>Response.OutputStream</c>, or <c>Console.Out</c>.  When using non-seekable streams
             for output, the entry header - which indicates whether zip64 is in use - is emitted
             before it is known if zip64 is necessary.  It is only after all entries have been saved
             that it can be known if ZIP64 will be required.  On seekable output streams, after
             saving all entries, the library can seek backward and re-emit the zip file header to be
             consistent with the actual ZIP64 requirement.  But using a non-seekable output stream,
             the library cannot seek backward, so the header can never be changed. In other words,
             the archive's use of ZIP64 extensions is not alterable after the header is emitted.
             Therefore, when saving to non-seekable streams, using <see cref="F:GemBox.Spreadsheet.Zip64Option.AsNecessary"/> is the same as using <see cref="F:GemBox.Spreadsheet.Zip64Option.Always"/>:
             it will always produce a zip archive that uses zip64 extensions.
             </para>
            
             <para>
             The default value for the property is <see cref="F:GemBox.Spreadsheet.Zip64Option.Never"/>. <see cref="F:GemBox.Spreadsheet.Zip64Option.AsNecessary"/> is safest, in the sense that you will not get an
             Exception if a pre-ZIP64 limit is exceeded.
             </para>
            
             <para>
             You may set the property at any time before calling Save(). 
             </para>
            
             <para>
             The ZipFile.Read() method will properly read ZIP64-endowed zip archives, regardless of the value of this 
             property.  ZIP64 archives can always be read, but this property governs whether they can be written. 
             Therefore, when updating archives, be careful about setting this property after reading an archive that
             may use ZIP64 extensions.
             </para>
            
             <para>
             Have you thought about donating? http://cheeso.members.winisp.net/DotNetZipDonate.aspx
             </para>
            
             </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ZipFile.ProvisionalAlternateEncoding">
             <summary>
             The text encoding to use when writing new entries to the ZipFile, for those
             entries that cannot be encoded with the default (IBM437) encoding; or, the
             text encoding that was used when reading the entries from the ZipFile.
             </summary>
             
             <remarks>
             <para>
             In its AppNote.txt document, PKWare describes how to specify in the zip entry
             header that a filename or comment containing non-ANSI characters is encoded with
             UTF-8.  But, some archivers do not follow the specification, and instead encode
             super-ANSI characters using the system default code page.  For example, WinRAR
             when run on a machine in Shanghai may encode filenames with the Big-5 Chinese
             (950) code page.  This behavior is contrary to the Zip specification, but it
             occurs anyway.
             </para>
            
             <para>
             When using DotNetZip to write zip archives that will be read by one of these other
             archivers, set this property to specify the code page to use when encoding the <see cref="P:GemBox.Spreadsheet.ZipEntry.FileName"/> and <see cref="P:GemBox.Spreadsheet.ZipEntry.Comment"/> for each ZipEntry in the zip file,
             for values that cannot be encoded with the default codepage for zip files, IBM437.
             This is why this property is "provisional".  In all cases, IBM437 is used where
             possible, in other words, where no loss of data would result. It is possible, therefore, to have a given 
             entry with a Comment encoded in IBM437 and a FileName encoded with the specified "provisional" codepage. 
             </para>
            
             <para>
             Be aware that a zip file created after you've explicitly set the <see cref="P:GemBox.Spreadsheet.ZipFile.ProvisionalAlternateEncoding"/> property to a value other than IBM437 may not be
             compliant to the PKWare specification, and may not be readable by compliant archivers.
             On the other hand, many (most?) archivers are non-compliant and can read zip files
             created in arbitrary code pages.  The trick is to use or specify the proper codepage
             when reading the zip.
             </para>
            
             <para>
             When creating a zip archive using this library, it is possible to change the value of
             <see cref="P:GemBox.Spreadsheet.ZipFile.ProvisionalAlternateEncoding"/> between each entry you add, and between
             adding entries and the call to Save(). Don't do this. It will likely result in a
             zipfile that is not readable.  For best interoperability, either leave <see cref="P:GemBox.Spreadsheet.ZipFile.ProvisionalAlternateEncoding"/> alone, or specify it only once, before adding
             any entries to the ZipFile instance.  There is one exception to this recommendation,
             described later.
             </para>
            
             <para>
             When using an arbitrary, non-UTF8 code page for encoding, there is no standard way for
             the creator application - whether DotNetZip, WinZip, WinRar, or something else - to
             formally specify in the zip file which codepage has been used for the entries. As a
             result, readers of zip files are not able to inspect the zip file and determine the
             codepage that was used for the entries contained within it.  It is left to the
             application or user to determine the necessary codepage when reading zipfiles encoded
             this way.  If you use an incorrect codepage when reading a zipfile, you will get
             entries with filenames that are incorrect, and the incorrect filenames may even contain
             characters that are not legal for use within filenames in Windows. Extracting entries
             with illegal characters in the filenames will lead to exceptions. It's too bad, but
             this is just the way things are with code pages in zip files. Caveat Emptor.
             </para>
            
             <para>
             When using DotNetZip to read a zip archive, and the zip archive uses an arbitrary code
             page, you must specify the encoding to use before or when the zipfile is READ.  This
             means you must use a ZipFile.Read() method that allows you to specify a
             System.Text.Encoding parameter.  Setting the ProvisionalAlternateEncoding property
             after your application has read in the zip archive will not affect the entry names of
             entries that have already been read in, and is probably not what you want.
             </para>
            	
             <para>
             And now, the exception to the rule described above.  One strategy for specifying the
             code page for a given zip file is to describe the code page in a human-readable form in
             the Zip comment. For example, the comment may read "Entries in this archive are encoded
             in the Big5 code page".  For maximum interoperability, the Zip comment in this case
             should be encoded in the default, IBM437 code page.  In this case, the zip comment is
             encoded using a different page than the filenames.  To do this, specify
             ProvisionalAlternateEncoding to your desired region-specific code page, once before
             adding any entries, and then reset ProvisionalAlternateEncoding to IBM437 before
             setting the <see cref="P:GemBox.Spreadsheet.ZipFile.Comment"/> property and calling Save().
             </para>
             </remarks>
             
             <seealso cref="F:GemBox.Spreadsheet.ZipFile.DefaultEncoding">DefaultEncoding</seealso>
        </member>
        <member name="P:GemBox.Spreadsheet.ZipFile.StatusMessageTextWriter">
             <summary>
             Gets or sets the <c>TextWriter</c> to which status messages are delivered 
             for the instance. 
             </summary>
            
             <remarks>
             If the TextWriter is set to a non-null value, then 
             verbose output is sent to the <c>TextWriter</c> during <c>Add</c><c>, Read</c><c>, Save</c> and
             <c>Extract</c> operations.  Typically, console applications might use <c>Console.Out</c> and 
             graphical or headless applications might use a <c>System.IO.StringWriter</c>.
             </remarks>
            
             <example>
             <para>
             In this example, a console application instantiates a ZipFile, then sets
             the StatusMessageTextWriter to Console.Out.  At that point, all verbose
             status messages for that ZipFile are sent to the console. 
             </para>
            
             <code lang="C#">
             using (ZipFile zip= ZipFile.Read(FilePath))
             {
               zip.StatusMessageTextWriter= System.Console.Out;
               // messages are sent to the console during extraction
               zip.ExtractAll();
             }
             </code>
            
             <code lang="VB">
             Using zip As ZipFile = ZipFile.Read(FilePath)
               zip.StatusMessageTextWriter= System.Console.Out
               'Status Messages will be sent to the console during extraction
               zip.ExtractAll()
             End Using
             </code>
             </example>
        </member>
        <member name="P:GemBox.Spreadsheet.ZipFile.ForceNoCompression">
             <summary>
             Gets or sets the flag that indicates whether the ZipFile should use
             compression for subsequently added entries in the ZipFile instance.
             </summary>
            
             <remarks>
             <para> 
             When saving an entry into a zip archive, the DotNetZip by default compresses
             the file. That's what a ZIP archive is all about, isn't it?  
             For files that are already compressed, like MP3's or JPGs,
             the deflate algorithm can actually slightly expand the size of the data.  Setting this
             property to trye allows you to specify that compression should not be used. 
             The default value is false.
             </para> 
            
             <para>
             Do not construe setting this flag to false as "Force Compression".  Setting it
             to false merely does NOT force No compression.  
             If you want to force the use of the deflate algorithm when
             storing each entry into the zip archive, define a <see cref="P:GemBox.Spreadsheet.ZipFile.WillReadTwiceOnInflation"/> callback, which always returns false, and a 
             <see cref="P:GemBox.Spreadsheet.ZipFile.WantCompression"/> callback that always returns true.  This is
             probably the wrong thing to do, but you could do it. Forcing the use of the
             Deflate algorithm when storing an entry does not guarantee that the data size
             will get smaller. It could increase, as described above.  
             </para>
            
             <para>
             Changes to this flag apply to all entries subsequently added to the archive. 
             The application can also set the <see cref="P:GemBox.Spreadsheet.ZipEntry.CompressionMethod"/>
             property on each ZipEntry, for more granular control of this capability.
             </para>
            
             </remarks>
            
             <seealso cref="P:GemBox.Spreadsheet.ZipEntry.CompressionMethod"/>
             <seealso cref="P:GemBox.Spreadsheet.ZipFile.CompressionLevel"/>
             <seealso cref="P:GemBox.Spreadsheet.ZipFile.WantCompression"/>
            
             <example>
             This example shows how to specify that Compression will not be used when adding files 
             to the zip archive. None of the files added to the archive in this example will use
             compression.
             <code>
             using (ZipFile zip = new ZipFile())
             {
               zip.ForceNoCompression = true;
               zip.AddDirectory(@"c:\temp\Foo");
               zip.Comment = "All files in this archive will be uncompressed.";
               zip.Save(ZipFileToCreate);
             }
             </code>
            
             <code lang="VB">
             Using zip As New ZipFile()
               zip.ForceNoCompression = true
               zip.AddDirectory("c:\temp\Foo")
               zip.Comment = "All files in this archive will be uncompressed."
               zip.Save(ZipFileToCreate)
             End Using
             </code>
            
             </example>
        </member>
        <member name="P:GemBox.Spreadsheet.ZipFile.TempFileFolder">
             <summary>
             Gets or sets the name for the folder to store the temporary file
             this library writes when saving a zip archive. 
             </summary>
            
             <remarks>
             <para>
             This library will create a temporary file when saving a Zip archive.
             By default, the library uses the value of <see cref="M:System.IO.Path.GetTempPath"/>
             as the location in which to store temporary files. For some scenarios, such as ASP.NET
             applications, the application may wish to explicitly override this default behavior.
             </para>
             <para>
             The temporary file is written when calling one of the
             <c>Save()</c> methods, or the <c>SaveSelfExtractor()</c> method.
             </para>
             <para>
             The folder specified must exist; if it does not an exception is thrown.
             The application should have write and delete permissions on the folder. 
             The permissions are 
             never explicitly checked; if the application does not have the appropriate rights, an exception
             will be thrown at the time <c>Save()</c> is called. 
             </para>
             <para>
             There is no temporary file created when reading a zip archive. 
             When saving to a Stream, there is no temporary file created.  For example, if the application 
             is an ASP.NET application and calls <c>Save()</c> specifying the Response.OutStream as the output 
             stream, there is no temporary file created. 
             </para>
             </remarks>
            
             <exception cref="T:System.IO.FileNotFoundException">
             Thrown when setting the property if the directory does not exist. 
             </exception>
            
        </member>
        <member name="P:GemBox.Spreadsheet.ZipFile.Encryption">
             <summary>
             The Encryption to use for entries added to the ZipFile.
             </summary>
            
             <remarks>
             <para>
             The specified Encryption is applied to the entries subsequently added to the ZipFile instance.  
             </para>
            
             </remarks>
            
             <example>
             <code>
                try
                {
                  using (ZipFile zip = new ZipFile())
                  {
                    zip.Encryption= EncryptionAlgorithm.WinZipAes256;
                    zip.Password= "Some.Like.It.Hot.1959!";
                    zip.AddFile("ReadMe.txt");
                    zip.AddFile("7440-N49th.png");
                    zip.AddFile("2005_Annual_Report.pdf");
                    zip.Save("EncryptedArchive.zip");
                  }
                }
                catch (System.Exception ex1)
                {
                  System.Console.Error.WriteLine("exception: {0}", ex1);
                }
             </code>
            
             <code lang="VB">
              Try 
                Using zip As New ZipFile()
                  zip.Encryption= EncryptionAlgorithm.WinZipAes256
                  zip.Password= "Some.Like.It.Hot.1959!"
                  zip.AddFile("ReadMe.txt")
                  zip.AddFile("7440-N49th.png")
                  zip.AddFile("2005_Annual_Report.pdf")
                  zip.Save("EncryptedArchive.zip")
                End Using
              Catch ex1 As System.Exception
                System.Console.Error.WriteLine("exception: {0}", ex1)
              End Try
             </code>
            
             </example>
        </member>
        <member name="P:GemBox.Spreadsheet.ZipFile.WillReadTwiceOnInflation">
             <summary>
             A callback that allows the application to specify whether multiple reads of the
             stream should be performed, in the case that a compression operation actually
             inflates the size of the file data.  
             </summary>
            
             <remarks>
             <para>
             In some cases, applying the Deflate compression algorithm in <c>DeflateStream</c> can
             result an increase in the size of the data.  This "inflation" can happen with
             previously compressed files, such as a zip, jpg, png, mp3, and so on.  In a few
             tests, inflation on zip files can be as large as 60%!  Inflation can also happen
             with very small files.  In these cases, by default, the DotNetZip library
             discards the compressed bytes, and stores the uncompressed file data into the
             zip archive.  This is an optimization where smaller size is preferred over
             longer run times.
             </para>
            
             <para>
             The application can specify that compression is not even tried, by setting the
             ForceNoCompression flag.  In this case, the compress-and-check-sizes process as
             decribed above, is not done.
             </para>
            
             <para>
             In some cases, neither choice is optimal.  The application wants compression,
             but in some cases also wants to avoid reading the stream more than once.  This
             may happen when the stream is very large, or when the read is very expensive, or
             when the difference between the compressed and uncompressed sizes is not
             significant.
             </para>
            
             <para>
             To satisfy these applications, this delegate allows the DotNetZip library to ask
             the application to for approval for re-reading the stream, in the case where
             inflation occurs.  The callback is invoked only in the case of inflation; that
             is to say when the uncompressed stream is smaller than the compressed stream.
             </para>
            
             <para>
             Of course, if you want to have different callbacks for different entries, you may do so. 
             </para>
            
             </remarks>
             <example>
             <para>
             In this example, the application callback checks to see if the difference
             between the compressed and uncompressed data is greater than 25%.  If it is,
             then the callback returns true, and the application tells the library to re-read
             the stream.  If not, then the callback returns false, and the library just keeps
             the "inflated" file data.
             </para>
            
             <code>
            
             public bool ReadTwiceCallback(long uncompressed, long compressed, string filename)
             {
                 return ((uncompressed * 1.0/compressed) &gt; 1.25);
             }
             
             public void CreateTheZip()
             {
                 using (ZipFile zip = new ZipFile())
                 {
                     // set the callback before adding files to the zip
                     zip2.WillReadTwiceOnInflation = ReadTwiceCallback;
                     zip2.AddFile(filename1);
                     zip2.AddFile(filename2);
                     zip2.Save(ZipFileToCreate);
                 }
             }
             </code>
             </example>
             <seealso cref="P:GemBox.Spreadsheet.ZipFile.WantCompression"/>
             <seealso cref="T:GemBox.Spreadsheet.WantCompressionCallback"/>
             <seealso cref="P:GemBox.Spreadsheet.ZipEntry.WillReadTwiceOnInflation"/>
        </member>
        <member name="P:GemBox.Spreadsheet.ZipFile.WantCompression">
             <summary>
             A callback that allows the application to specify whether compression should
             be used for entries subsequently added to the zip archive.
             </summary>
            
             <remarks>
             <para>
             In some cases, applying the Deflate compression algorithm to an entry *may*
             result a slight increase in the size of the data.  This "inflation" can
             happen with previously compressed files, such as a zip, jpg, png, mp3, and
             so on; it results from adding DEFLATE framing data around incompressible data.
             Inflation can also happen with very small files. Applications may wish to
             avoid the use of compression in these cases. As well, applications may wish
             to avoid compression to save time.
             </para>
            
             <para>
             By default, the DotNetZip library takes this approach to decide whether to
             apply compression: first it applies a heuristic, to determine whether it
             should try to compress a file or not.  The library checks the extension of
             the entry, and if it is one of a known list of uncompressible file types
             (mp3, zip, docx, and others), the library will not attempt to compress the
             entry.  The library does not actually check the content of the entry.  If
             you name a text file "Text.mp3", and then attempt to add it to a zip
             archive, this library will, by default, not attempt to compress the entry,
             based on the extension of the filename.
             </para>
            
             <para>
             If this default behavior is not satisfactory, there are two options. First,
             the application can override it by setting this <see cref="P:GemBox.Spreadsheet.ZipFile.WantCompression"/> callback.  This affords maximum control to
             the application.  With this callback, the application can supply its own
             logic for determining whether to apply the Deflate algorithm or not.  For
             example, an application may desire that files over 40mb in size are never
             compressed, or always compressed.  An application may desire that the first
             7 entries added to an archive are compressed, and the remaining ones are
             not.  The WantCompression callback allows the application full control, on
             an entry-by-entry basis.
             </para>
            
             <para>
             The second option for overriding the default logic regarding whether to
             apply compression is the ForceNoCompression flag.  If this flag is set to
             true, the compress-and-check-sizes process as decribed above, is not done,
             nor is the callback invoked.  In other words, if you set ForceNoCompression
             to true, andalso set the WantCompression callback, only the
             ForceNoCompression flag is considered.
             </para>
            
             <para>
             This is how the library determines whether compression will be attempted for 
             an entry.  If it is to be attempted, the library reads the entry, runs it through
             the deflate algorithm, and then checks the size of the result.  If applying
             the Deflate algorithm increases the size of the data, then the library
             discards the compressed bytes, re-reads the raw entry data, and stores the
             uncompressed file data into the zip archive, in compliance with the zip
             spec.  This is an optimization where smaller size is preferred over longer
             run times. The re-reading is gated on the <see cref="P:GemBox.Spreadsheet.ZipFile.WillReadTwiceOnInflation"/> callback, if it is set. This callback applies
             independently of the WantCompression callback.
             </para>
            
             <para>
             If by the logic described above, compression is not to be attempted for an entry, 
             the library reads the entry, and simply stores the entry data uncompressed. 
             </para>
            
             <para>
             And, if you have read this far, I would like to point out that a single
             person wrote all the code that does what is described above, and also wrote
             the description.  Isn't it about time you donated $5 in appreciation?  The
             money goes to a charity. See
             http://cheeso.members.winisp.net/DotNetZipDonate.aspx.
             </para>
            
             </remarks>
             <seealso cref="P:GemBox.Spreadsheet.ZipFile.WillReadTwiceOnInflation"/>
        </member>
        <member name="E:GemBox.Spreadsheet.ZipFile.SaveProgress">
             <summary>
             An event handler invoked when a Save() starts, before and after each entry has been
             written to the archive, when a Save() completes, and during other Save events.
             </summary>
            
             <remarks>
             <para>
             Depending on the particular event, different properties on the
             SaveProgressEventArgs parameter are set.  The following table 
             summarizes the available EventTypes and the conditions under which this 
             event handler is invoked with a SaveProgressEventArgs with the given EventType.
             </para>
             
             <list type="table">
             <listheader>
             <term>value of EntryType</term>
             <description>Meaning and conditions</description>
             </listheader>
             
             <item>
             <term>ZipProgressEventType.Saving_Started</term>
             <description>Fired when ZipFile.Save() begins. 
             </description>
             </item>
             
             <item>
             <term>ZipProgressEventType.Saving_BeforeSaveEntry</term>
             <description>Fired within ZipFile.Save(), just before writing data for each particular entry. 
             </description>
             </item>
             
             <item>
             <term>ZipProgressEventType.Saving_AfterSaveEntry</term>
             <description>Fired within ZipFile.Save(), just after having finished writing data for each 
             particular entry. 
             </description>
             </item>
             
             <item>
             <term>ZipProgressEventType.Saving_Completed</term>
             <description>Fired when ZipFile.Save() has completed. 
             </description>
             </item>
             
             <item>
             <term>ZipProgressEventType.Saving_AfterSaveTempArchive</term>
             <description>Fired after the temporary file has been created.  This happens only
             when saving to a disk file.  This event will not be invoked when saving to a stream.
             </description>
             </item>
             
             <item>
             <term>ZipProgressEventType.Saving_BeforeRenameTempArchive</term>
             <description>Fired just before renaming the temporary file to the permanent location.  This 
             happens only when saving to a disk file.  This event will not be invoked when saving to a stream.
             </description>
             </item>
             
             <item>
             <term>ZipProgressEventType.Saving_AfterRenameTempArchive</term>
             <description>Fired just after renaming the temporary file to the permanent location.  This 
             happens only when saving to a disk file.  This event will not be invoked when saving to a stream.
             </description>
             </item>
             
             <item>
             <term>ZipProgressEventType.Saving_AfterCompileSelfExtractor</term>
             <description>Fired after a self-extracting archive has finished compiling. 
             This EventType is used only within SaveSelfExtractor().
             </description>
             </item>
             
             <item>
             <term>ZipProgressEventType.Saving_BytesRead</term>
             <description>Set during the save of a particular entry, to update progress of the Save(). 
             When this EventType is set, the BytesTransferred is the number of bytes that have been read from the 
             source stream.  The TotalBytesToTransfer is the number of bytes in the uncompressed file.
             </description>
             </item>
             
             </list>
             </remarks>
            
             <example>
             <code lang="C#">
             static bool justHadByteUpdate= false;
             public static void SaveProgress(object sender, SaveProgressEventArgs e)
             {
                 if (e.EventType == ZipProgressEventType.Saving_Started)
                     Console.WriteLine("Saving: {0}", e.ArchiveName);
             
                 else if (e.EventType == ZipProgressEventType.Saving_Completed)
                 {
                     justHadByteUpdate= false; 
                     Console.WriteLine();
                     Console.WriteLine("Done: {0}", e.ArchiveName);
                 }
             
                 else if (e.EventType == ZipProgressEventType.Saving_BeforeWriteEntry)
                 {
                     if (justHadByteUpdate) 
                         Console.WriteLine();
                     Console.WriteLine("  Writing: {0} ({1}/{2})",  
                                       e.NameOfLatestEntry, e.EntriesSaved, e.EntriesTotal);
                     justHadByteUpdate= false;
                 }
             
                 else if (e.EventType == ZipProgressEventType.Saving_EntryBytesWritten)
                 {
                     if (justHadByteUpdate)
                         Console.SetCursorPosition(0, Console.CursorTop);
                      Console.Write("     {0}/{1} ({2:N0}%)", e.BytesWritten, e.TotalBytesToWrite,
                                   e.BytesWritten / (0.01 * e.TotalBytesToWrite ));
                     justHadByteUpdate= true;
                 }
             }
             
             public static ZipUp(string targetZip, string directory)
             {
               using (var zip = new ZipFile()) {
                 zip.SaveProgress += SaveProgress; 
                 zip.AddDirectory(directory);
                 zip.Save(targetZip);
               }
             }
            
             </code>
             <para>
             This is an example of using the SaveProgress events in a WinForms app.
             </para>
             <code>
             delegate void SaveEntryProgress(SaveProgressEventArgs e);
             delegate void ButtonClick(object sender, EventArgs e);
            
             public class WorkerOptions
             {
                 public string ZipName;
                 public string Folder;
                 public string Encoding;
                 public string Comment;
                 public int ZipFlavor;
                 public Zip64Option Zip64;
             }
            
             private int _progress2MaxFactor;
             private bool _saveCanceled;
             private long _totalBytesBeforeCompress;
             private long _totalBytesAfterCompress;
             private Thread _workerThread;
            
            
             private void btnZipup_Click(object sender, EventArgs e)
             {
                 KickoffZipup();
             }
            
             private void btnCancel_Click(object sender, EventArgs e)
             {
                 if (this.lblStatus.InvokeRequired)
                 {
                     this.lblStatus.Invoke(new ButtonClick(this.btnCancel_Click), new object[] { sender, e });
                 }
                 else
                 {
                     _saveCanceled = true;
                     lblStatus.Text = "Canceled...";
                     ResetState();
                 }
             }
            
             private void KickoffZipup()
             {
                 _folderName = tbDirName.Text;
            
                 if (_folderName == null || _folderName == "") return;
                 if (this.tbZipName.Text == null || this.tbZipName.Text == "") return;
            
                 // check for existence of the zip file:
                 if (System.IO.File.Exists(this.tbZipName.Text))
                 {
                     var dlgResult = MessageBox.Show(String.Format("The file you have specified ({0}) already exists." + 
                                                                   "  Do you want to overwrite this file?", this.tbZipName.Text), 
                                                     "Confirmation is Required", MessageBoxButtons.YesNo, MessageBoxIcon.Question);
                     if (dlgResult != DialogResult.Yes) return;
                     System.IO.File.Delete(this.tbZipName.Text);
                 }
            
                  _saveCanceled = false;
                 _nFilesCompleted = 0;
                 _totalBytesAfterCompress = 0;
                 _totalBytesBeforeCompress = 0;
                 this.btnOk.Enabled = false;
                 this.btnOk.Text = "Zipping...";
                 this.btnCancel.Enabled = true;
                 lblStatus.Text = "Zipping...";
            
                 var options = new WorkerOptions
                 {
                     ZipName = this.tbZipName.Text,
                     Folder = _folderName,
                     Encoding = "ibm437"
                 };
            
                 if (this.comboBox1.SelectedIndex != 0)
                 {
                     options.Encoding = this.comboBox1.SelectedItem.ToString();
                 }
            
                 if (this.radioFlavorSfxCmd.Checked)
                     options.ZipFlavor = 2;
                 else if (this.radioFlavorSfxGui.Checked)
                     options.ZipFlavor = 1;
                 else options.ZipFlavor = 0;
            
                 if (this.radioZip64AsNecessary.Checked)
                     options.Zip64 = Zip64Option.AsNecessary;
                 else if (this.radioZip64Always.Checked)
                     options.Zip64 = Zip64Option.Always;
                 else options.Zip64 = Zip64Option.Never;
            
                 options.Comment = String.Format("Encoding:{0} || Flavor:{1} || ZIP64:{2}\r\nCreated at {3} || {4}\r\n",
                             options.Encoding,
                             FlavorToString(options.ZipFlavor),
                             options.Zip64.ToString(),
                             System.DateTime.Now.ToString("yyyy-MMM-dd HH:mm:ss"),
                             this.Text);
            
                 if (this.tbComment.Text != TB_COMMENT_NOTE)
                     options.Comment += this.tbComment.Text;
            
                 _workerThread = new Thread(this.DoSave);
                 _workerThread.Name = "Zip Saver thread";
                 _workerThread.Start(options);
                 this.Cursor = Cursors.WaitCursor;
              }
            
            
             private void DoSave(Object p)
             {
                 WorkerOptions options = p as WorkerOptions;
                 try
                 {
                     using (var zip1 = new ZipFile())
                     {
                         zip1.ProvisionalAlternateEncoding = System.Text.Encoding.GetEncoding(options.Encoding);
                         zip1.Comment = options.Comment;
                         zip1.AddDirectory(options.Folder);
                         _entriesToZip = zip1.EntryFileNames.Count;
                         SetProgressBars();
                         zip1.SaveProgress += this.zip1_SaveProgress;
            
                         zip1.UseZip64WhenSaving = options.Zip64;
            
                         if (options.ZipFlavor == 1)
                             zip1.SaveSelfExtractor(options.ZipName, SelfExtractorFlavor.WinFormsApplication);
                         else if (options.ZipFlavor == 2)
                             zip1.SaveSelfExtractor(options.ZipName, SelfExtractorFlavor.ConsoleApplication);
                         else
                             zip1.Save(options.ZipName);
                     }
                 }
                 catch (System.Exception exc1)
                 {
                     MessageBox.Show(String.Format("Exception while zipping: {0}", exc1.Message));
                     btnCancel_Click(null, null);
                 }
             }
            
            
            
             void zip1_SaveProgress(object sender, SaveProgressEventArgs e)
             {
                 switch (e.EventType)
                 {
                     case ZipProgressEventType.Saving_AfterWriteEntry:
                         StepArchiveProgress(e);
                         break;
                     case ZipProgressEventType.Saving_EntryBytesRead:
                         StepEntryProgress(e);
                         break;
                     case ZipProgressEventType.Saving_Completed:
                         SaveCompleted();
                         break;
                     case ZipProgressEventType.Saving_AfterSaveTempArchive:
                         // this event only occurs when saving an SFX file
                         TempArchiveSaved();
                         break;
                 }
                 if (_saveCanceled)
                     e.Cancel = true;
             }
            
            
            
             private void StepArchiveProgress(SaveProgressEventArgs e)
             {
                 if (this.progressBar1.InvokeRequired)
                 {
                     this.progressBar1.Invoke(new SaveEntryProgress(this.StepArchiveProgress), new object[] { e });
                 }
                 else
                 {
                     if (!_saveCanceled)
                     {
                         _nFilesCompleted++;
                         this.progressBar1.PerformStep();
                         _totalBytesAfterCompress += e.CurrentEntry.CompressedSize;
                         _totalBytesBeforeCompress += e.CurrentEntry.UncompressedSize;
            
                         // reset the progress bar for the entry:
                         this.progressBar2.Value = this.progressBar2.Maximum = 1;
            
                         this.Update();
                     }
                 }
             }
            
            
             private void StepEntryProgress(SaveProgressEventArgs e)
             {
                 if (this.progressBar2.InvokeRequired)
                 {
                     this.progressBar2.Invoke(new SaveEntryProgress(this.StepEntryProgress), new object[] { e });
                 }
                 else
                 {
                     if (!_saveCanceled)
                     {
                         if (this.progressBar2.Maximum == 1)
                         {
                             // reset
                             Int64 max = e.TotalBytesToTransfer;
                             _progress2MaxFactor = 0;
                             while (max > System.Int32.MaxValue)
                             {
                                 max /= 2;
                                 _progress2MaxFactor++;
                             }
                             this.progressBar2.Maximum = (int)max;
                             lblStatus.Text = String.Format("{0} of {1} files...({2})",
                                 _nFilesCompleted + 1, _entriesToZip, e.CurrentEntry.FileName);
                         }
            
                          int xferred = e.BytesTransferred >> _progress2MaxFactor;
            
                          this.progressBar2.Value = (xferred >= this.progressBar2.Maximum)
                             ? this.progressBar2.Maximum
                             : xferred;
            
                          this.Update();
                     }
                 }
             }
            
             private void SaveCompleted()
             {
                 if (this.lblStatus.InvokeRequired)
                 {
                     this.lblStatus.Invoke(new MethodInvoker(this.SaveCompleted));
                 }
                 else
                 {
                     lblStatus.Text = String.Format("Done, Compressed {0} files, {1:N0}% of original.",
                         _nFilesCompleted, (100.00 * _totalBytesAfterCompress) / _totalBytesBeforeCompress);
                      ResetState();
                 }
             }
            
             private void ResetState()
             {
                 this.btnCancel.Enabled = false;
                 this.btnOk.Enabled = true;
                 this.btnOk.Text = "Zip it!";
                 this.progressBar1.Value = 0;
                 this.progressBar2.Value = 0;
                 this.Cursor = Cursors.Default;
                 if (!_workerThread.IsAlive)
                     _workerThread.Join();
             }
             </code>
            
             <code lang="VB">
             Public Sub ZipUp(ByVal targetZip As String, ByVal directory As String)
             	Try 
             	    Using zip As ZipFile = New ZipFile
             		AddHandler zip.SaveProgress, AddressOf MySaveProgress
             		zip.AddDirectory(directory)
             		zip.Save(targetZip)
             	    End Using
             	Catch ex1 As Exception
             	    Console.Error.WriteLine(("exception: " &amp; ex1.ToString))
             	End Try
             End Sub
             
             Private Shared justHadByteUpdate As Boolean = False
             
             Public Shared Sub MySaveProgress(ByVal sender As Object, ByVal e As SaveProgressEventArgs)
                 If (e.EventType Is ZipProgressEventType.Saving_Started) Then
                     Console.WriteLine("Saving: {0}", e.ArchiveName)
             
                 ElseIf (e.EventType Is ZipProgressEventType.Saving_Completed) Then
                     CreateLargeZip.justHadByteUpdate = False
                     Console.WriteLine
                     Console.WriteLine("Done: {0}", e.ArchiveName)
             
                 ElseIf (e.EventType Is ZipProgressEventType.Saving_BeforeWriteEntry) Then
                     If CreateLargeZip.justHadByteUpdate Then
                         Console.WriteLine
                     End If
                     Console.WriteLine("  Writing: {0} ({1}/{2})", e.NameOfLatestEntry, e.EntriesSaved, e.EntriesTotal)
                     CreateLargeZip.justHadByteUpdate = False
             
                 ElseIf (e.EventType Is ZipProgressEventType.Saving_EntryBytesWritten) Then
                     If CreateLargeZip.justHadByteUpdate Then
                         Console.SetCursorPosition(0, Console.CursorTop)
                     End If
                     Console.Write("     {0}/{1} ({2:N0}%)", e.BytesWritten, _
                                   e.TotalBytesToWrite, _
                                   (CDbl(e.BytesWritten) / (0.01 * e.TotalBytesToWrite)))
                     CreateLargeZip.justHadByteUpdate = True
                 End If
             End Sub
             </code>
             </example>
        </member>
        <member name="E:GemBox.Spreadsheet.ZipFile.ReadProgress">
             <summary>
             An event handler invoked before, during, and after the reading of a zip archive.
             </summary>
            
             <remarks>
             <para>
             Depending on the particular event being signaled, different properties on the
             ReadProgressEventArgs parameter are set.  The following table 
             summarizes the available EventTypes and the conditions under which this 
             event handler is invoked with a ReadProgressEventArgs with the given EventType.
             </para>
             
             <list type="table">
             <listheader>
             <term>value of EntryType</term>
             <description>Meaning and conditions</description>
             </listheader>
             
             <item>
             <term>ZipProgressEventType.Reading_Started</term>
             <description>Fired just as ZipFile.Read() begins. Meaningful properties: ArchiveName.
             </description>
             </item>
             
             <item>
             <term>ZipProgressEventType.Reading_Completed</term>
             <description>Fired when ZipFile.Read() has completed. Meaningful properties: ArchiveName.
             </description>
             </item>
             
             <item>
             <term>ZipProgressEventType.Reading_ArchiveBytesRead</term>
             <description>Fired while reading, updates the number of bytes read for the entire archive. 
             Meaningful properties: ArchiveName, NameOfLatestEntry, BytesTransferred, TotalBytesToTransfer.
             </description>
             </item>
             
             <item>
             <term>ZipProgressEventType.Reading_BeforeReadEntry</term>
             <description>Indicates an entry is about to be read from the archive.
             Meaningful properties: ArchiveName, EntriesTotal.
             </description>
             </item>
             
             <item>
             <term>ZipProgressEventType.Reading_AfterReadEntry</term>
             <description>Indicates an entry has just been read from the archive.
             Meaningful properties: ArchiveName, EntriesTotal, NameOfLatestEntry.
             </description>
             </item>
            
             </list>
             </remarks>
        </member>
        <member name="E:GemBox.Spreadsheet.ZipFile.ExtractProgress">
             <summary>
             An event handler invoked before, during, and after extraction of entries 
             in the zip archive. 
             </summary>
            
             <remarks>
             <para>
             Depending on the particular event, different properties on the
             ExtractProgressEventArgs parameter are set.  The following table 
             summarizes the available EventTypes and the conditions under which this 
             event handler is invoked with a ExtractProgressEventArgs with the given EventType.
             </para>
             
             <list type="table">
             <listheader>
             <term>value of EntryType</term>
             <description>Meaning and conditions</description>
             </listheader>
             
             <item>
             <term>ZipProgressEventType.Extracting_BeforeExtractAll</term>
             <description>Set when ExtractAll() begins.  The ArchiveName, Overwrite,
             and ExtractLocation properties are meaningful.</description>
             </item>
             
             <item>
             <term>ZipProgressEventType.Extracting_AfterExtractAll</term>
             <description>Set when ExtractAll() has completed.  The ArchiveName, 
             Overwrite, and ExtractLocation properties are meaningful.
             </description>
             </item>
             
             <item>
             <term>ZipProgressEventType.Extracting_BeforeExtractEntry</term>
             <description>Set when an Extract() on an entry in the ZipFile has begun.  
             Properties that are meaningful:  ArchiveName, EntriesTotal, NameOfLatestEntry, Overwrite, 
             ExtractLocation, EntriesExtracted.
             </description>
             </item>
             
             <item>
             <term>ZipProgressEventType.Extracting_AfterExtractEntry</term>
             <description>Set when an Extract() on an entry in the ZipFile has completed.  
             Properties that are meaningful:  ArchiveName, EntriesTotal, NameOfLatestEntry, Overwrite, 
             ExtractLocation, EntriesExtracted.
             </description>
             </item>
             
             <item>
             <term>ZipProgressEventType.Extracting_EntryBytesWritten</term>
             <description>Set within a call to Extract() on an entry in the ZipFile, as
             data is extracted for the entry.  Properties that are meaningful:  ArchiveName, 
             NameOfLatestEntry, BytesWritten, TotalBytesToWrite. 
             </description>
             </item>
             
             </list>
             
             </remarks>
            
             <example>
             <code>
             private static bool justHadByteUpdate = false;
             public static void ExtractProgress(object sender, ExtractProgressEventArgs e)
             {
               if(e.EventType == ZipProgressEventType.Extracting_EntryBytesWritten)
               {
                 if (justHadByteUpdate)
                   Console.SetCursorPosition(0, Console.CursorTop);
            
                 Console.Write("   {0}/{1} ({2:N0}%)", e.BytesWritten, e.TotalBytesToWrite,
                               e.BytesWritten / (0.01 * e.TotalBytesToWrite ));
                 justHadByteUpdate = true;
               }
               else if(e.EventType == ZipProgressEventType.Extracting_BeforeExtractEntry)
               {
                 if (justHadByteUpdate) 
                   Console.WriteLine();
                 Console.WriteLine("Extracting: {0}", e.NameOfLatestEntry);
                 justHadByteUpdate= false;
               }
             }
            
             public static ExtractZip(string zipToExtract, string directory)
             {
               string TargetDirectory= "extract";
               using (var zip = ZipFile.Read(zipToExtract)) {
                 zip.ExtractProgress += ExtractProgress; 
                 foreach (var e in zip1)
                 {
                   e.Extract(TargetDirectory, true);
                 }
               }
             }
            
             </code>
             <code lang="VB">
             Public Shared Sub Main(ByVal args As String())
                 Dim ZipToUnpack As String = "C1P3SML.zip"
                 Dim TargetDir As String = "ExtractTest_Extract"
                 Console.WriteLine("Extracting file {0} to {1}", ZipToUnpack, TargetDir)
                 Using zip1 As ZipFile = ZipFile.Read(ZipToUnpack)
                     AddHandler zip1.ExtractProgress, AddressOf MyExtractProgress
                     Dim e As ZipEntry
                     For Each e In zip1
                         e.Extract(TargetDir, True)
                     Next
                 End Using
             End Sub
             
             Private Shared justHadByteUpdate As Boolean = False
             
             Public Shared Sub MyExtractProgress(ByVal sender As Object, ByVal e As ExtractProgressEventArgs)
                 If (e.EventType Is ZipProgressEventType.Extracting_EntryBytesWritten) Then
                     If ExtractTest.justHadByteUpdate Then
                         Console.SetCursorPosition(0, Console.CursorTop)
                     End If
                     Console.Write("   {0}/{1} ({2:N0}%)", e.BytesWritten, e.TotalBytesToWrite, (CDbl(e.BytesWritten) / (0.01 * e.TotalBytesToWrite)))
                     ExtractTest.justHadByteUpdate = True
                 ElseIf (e.EventType Is ZipProgressEventType.Extracting_BeforeExtractEntry) Then
                     If ExtractTest.justHadByteUpdate Then
                         Console.WriteLine
                     End If
                     Console.WriteLine("Extracting: {0}", e.NameOfLatestEntry)
                     ExtractTest.justHadByteUpdate = False
                 End If
             End Sub
             </code>
             </example>
        </member>
        <member name="P:GemBox.Spreadsheet.ZipFile.Item(System.String)">
             <summary>
             This is a name-based indexer into the Zip archive.  
             </summary>
             
             <remarks>
             <para>
             If you assign a non-null value
             (non Nothing in VB), the setter will throw an exception.
             </para>
             <para>
             It is not always the case that <c>this[value].FileName == value</c>.  In
             the case of directory entries in the archive, you may retrieve them with
             the name of the directory with no trailing slash, even though in the
             entry itself, the actual <see cref="P:GemBox.Spreadsheet.ZipEntry.FileName"/> property may
             include a trailing slash.  In other words, for a directory entry named
             "dir1", you may find <c>this["dir1"].FileName == "dir1/"</c>.
             </para>
             </remarks>
             
             <example>
             This example extracts only the entries in a zip file that are .txt files.
             <code>
             using (ZipFile zip = ZipFile.Read("PackedDocuments.zip"))
             {
               foreach (string s1 in zip.EntryFilenames)
               {
                 if (s1.EndsWith(".txt"))
                   zip[s1].Extract("textfiles");
               }
             }
             </code>
             <code lang="VB">
               Using zip As ZipFile = ZipFile.Read("PackedDocuments.zip")
                   Dim s1 As String
                   For Each s1 In zip.EntryFilenames
                       If s1.EndsWith(".txt") Then
                           zip(s1).Extract("textfiles")
                       End If
                   Next
               End Using
             </code>
             </example>
            
             <exception cref="T:System.ArgumentException">
             Thrown if the caller attempts to assign a non-null value to the indexer.
             </exception>
            
             <param name="fileName">
             The name of the file, including any directory path, to retrieve from the zip. 
             The filename match is not case-sensitive by default; you can use the
             <see cref="P:GemBox.Spreadsheet.ZipFile.CaseSensitiveRetrieval"/> property to change this behavior. The
             pathname can use forward-slashes or backward slashes.
             </param>
             
             <returns>
             The ZipEntry within the Zip archive, given by the specified filename. If the named
             entry does not exist in the archive, this indexer returns null.
             </returns>
             
        </member>
        <member name="T:GemBox.Spreadsheet.Zip64Option">
            <summary>
            Options for using ZIP64 extensions when saving zip archives. 
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.Zip64Option.Default">
            <summary>
            The default behavior, which is "Never".
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.Zip64Option.Never">
            <summary>
            Do not use ZIP64 extensions when writing zip archives.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.Zip64Option.AsNecessary">
            <summary>
            Use ZIP64 extensions when writing zip archives, as necessary. 
            For example, when a single entry exceeds 0xFFFFFFFF in size, or when the archive as a whole 
            exceeds 0xFFFFFFFF in size, or when there are more than 65535 entries in an archive.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.Zip64Option.Always">
            <summary>
            Always use ZIP64 extensions when writing zip archives, even when unnecessary.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.ZipCrypto">
            <summary> 
            This class implements the "traditional" or "classic" PKZip encryption,
            which today is considered to be weak. On the other hand it is
            ubiquitous. This class is intended for use only by the DotNetZip library.
            </summary>
            <remarks>
            Most uses of the DotNetZip library will not involve direct calls into the
            ZipCrypto class.  Instead, the ZipCrypto class is instantiated and used by
            the ZipEntry() class when encryption or decryption on an entry is employed.
            If for some reason you really wanted to use a weak encryption algorithm
            in some other application, you might use this library.  But you would be much
            better off using one of the built-in strong encryption libraries in the 
            .NET Framework, like the AES algorithm or SHA. 
            </remarks>
        </member>
        <member name="M:GemBox.Spreadsheet.ZipCrypto.#ctor">
             <summary>
             The default constructor for ZipCrypto.
             </summary>
            
             <remarks>
             This class is intended for internal use by the library only. It's probably not useful to you. Seriously.
             Stop reading this documentation.  It's a waste of your time.  Go do something else.
             Check the football scores. Go get an ice cream with a friend.  Seriously.
             </remarks>
             
        </member>
        <member name="M:GemBox.Spreadsheet.ZipCrypto.DecryptMessage(System.Byte[],System.Int32)">
            <summary> 
            Call this method on a cipher text to render the plaintext. You must
            first initialize the cipher with a call to InitCipher.
            </summary>		
            <example>
            <code>
            var cipher = new ZipCrypto();
            cipher.InitCipher(Password);
            // Decrypt the header.  This has a side effect of "further initializing the
            // encryption keys" in the traditional zip encryption. 
            byte[] DecryptedMessage = cipher.DecryptMessage(EncryptedMessage);
            </code>
            </example>
            <param name="cipherText">The encrypted buffer.</param>
            <param name="length">
            The number of bytes to encrypt.  
            Should be less than or equal to CipherText.Length.
            </param>
            <returns>The plaintext.</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.ZipCrypto.EncryptMessage(System.Byte[],System.Int32)">
            <summary>
            This is the converse of DecryptMessage.  It encrypts the plaintext
            and produces a ciphertext. 
            </summary>
            <param name="plaintext">The plain text buffer.</param>
            <param name="length">
            The number of bytes to encrypt.  
            Should be less than or equal to PlainText.Length.
            </param>
            <returns>The ciphertext.</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.ZipCrypto.InitCipher(System.String)">
             <summary>
             This initializes the cipher with the given password. 
             See AppNote.txt for details. 
             </summary>
             <param name="passphrase">The passphrase for encrypting or decrypting with this cipher.
             </param>
             <remarks>
             <code>
             Step 1 - Initializing the encryption keys
             -----------------------------------------
             Start with these keys:        
             Key(0) := 305419896 (0x12345678)
             Key(1) := 591751049 (0x23456789)
             Key(2) := 878082192 (0x34567890)
             
             Then, initialize the keys with a password:
             
             loop for i from 0 to length(password)-1
                 update_keys(password(i))
             end loop
             
             Where update_keys() is defined as:
             
             update_keys(char):
               Key(0) := crc32(key(0),char)
               Key(1) := Key(1) + (Key(0) bitwiseAND 000000ffH)
               Key(1) := Key(1) * 134775813 + 1
               Key(2) := crc32(key(2),key(1) rightshift 24)
             end update_keys
             
             Where crc32(old_crc,char) is a routine that given a CRC value and a
             character, returns an updated CRC value after applying the CRC-32
             algorithm described elsewhere in this document.
            
             </code>
             <para>
             After the keys are initialized, then you can use the cipher to encrypt
             the plaintext. 
             </para>
             <para>
             Essentially we encrypt the password with the keys, then discard the 
             ciphertext for the password. This initializes the keys for later use.
             </para>
             </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ZipCrypto.MagicByte">
            <summary> 
            From AppNote.txt:
            unsigned char decrypt_byte()
                local unsigned short temp
                temp :=- Key(2) | 2
                decrypt_byte := (temp * (temp ^ 1)) bitshift-right 8
            end decrypt_byte
            </summary>		
        </member>
        <member name="T:GemBox.Spreadsheet.ZipCipherStream">
            <summary>
            A Stream for reading and concurrently decrypting data from a zip file, 
            or for writing and concurrently encrypting data to a zip file.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.ZipCipherStream.#ctor(System.IO.Stream,GemBox.Spreadsheet.ZipCrypto,GemBox.Spreadsheet.CryptoMode)">
            <summary>
            The  constructor.
            </summary>
            <param name="s">The underlying stream</param>
            <param name="mode">To either encrypt or decrypt.</param>
            <param name="cipher">The pre-initialized ZipCrypto object.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.MsofbtDgRecord.Read(System.IO.BinaryReader)">
            <summary>
            Reads data from the specified reader.
            </summary>
            <param name="reader">The source binary reader.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.MsofbtDgRecord.SetData(GemBox.Spreadsheet.MsoDelayedRecords)">
            <summary>
            Sets the inner data( mso structure' data without header: atom, type, length ).
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.FunctionVarFormulaToken">
            <summary>
            Formula token for holding function with variable arguments count.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.FunctionVarFormulaToken.#ctor(GemBox.Spreadsheet.FormulaTokenCode)">
            <summary>
            Initializes a new instance of the <see cref="T:GemBox.Spreadsheet.FunctionVarFormulaToken"/> class.
            </summary>
            <param name="code">The code.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.FunctionVarFormulaToken.DelayInitialize(System.Object[])">
            <summary>
            Make custom delay initialize.
            </summary>
            <param name="data">The data for initialization which is unique for each formula token.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.FunctionVarFormulaToken.Read(System.Byte[],System.Int32)">
            <summary>
            Initialize formula token by reading input data from array of bytes
            </summary>
            <param name="rpnBytes">input data, array of bytes</param>
            <param name="startIndex">start position for array of bytes to read from</param>
        </member>
        <member name="M:GemBox.Spreadsheet.FunctionVarFormulaToken.ConvertToBytes">
            <summary>
            Convert formula token to array of byte representation.
            </summary>
            <returns>formula token' array of byte representation</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.FunctionVarFormulaToken.ToString">
            <summary>
            Convert formula token to string representation.
            </summary>
            <returns>formula token string representation</returns>
        </member>
        <member name="T:GemBox.Spreadsheet.ControlFormulaToken">
            <summary>
            Formula token for holding control value.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.ControlFormulaToken.#ctor(GemBox.Spreadsheet.FormulaTokenCode)">
            <summary>
            Initializes a new instance of the <see cref="T:GemBox.Spreadsheet.ControlFormulaToken"/> class.
            </summary>
            <param name="code">The FormulaTokenCode code.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ControlFormulaToken.Read(System.Byte[],System.Int32)">
            <summary>
            Initialize formula token by reading input data from array of bytes
            </summary>
            <param name="rpnBytes">input data, array of bytes</param>
            <param name="startIndex">start position for array of bytes to read from</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ControlFormulaToken.ConvertToBytes">
            <summary>
            Convert formula token to array of byte representation.
            </summary>
            <returns>formula token' array of byte representation</returns>
        </member>
        <member name="T:GemBox.Spreadsheet.FormulaTokenTypeEx">
            <summary>
            It is wrapper arodung FormulaTokenType enum to provide high-level bool methods
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.FormulaTokenTypeEx.#ctor(GemBox.Spreadsheet.FormulaTokenType)">
            <summary>
            Initializes a new instance of the <see cref="T:GemBox.Spreadsheet.FormulaTokenTypeEx"/> class.
            </summary>
            <param name="type">The type.</param>
        </member>
        <member name="P:GemBox.Spreadsheet.FormulaTokenTypeEx.Type">
            <summary>
            Gets the formula token type.
            </summary>
            <value>The formula token type.</value>
        </member>
        <member name="P:GemBox.Spreadsheet.FormulaTokenTypeEx.IsBinary">
            <summary>
            Gets a value indicating whether this instance is binary.
            </summary>
            <value><c>true</c> if this instance is binary; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:GemBox.Spreadsheet.FormulaTokenTypeEx.IsUnary">
            <summary>
            Gets a value indicating whether this instance is unary.
            </summary>
            <value><c>true</c> if this instance is unary; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:GemBox.Spreadsheet.FormulaTokenTypeEx.IsOperand">
            <summary>
            Gets a value indicating whether this instance is operand.
            </summary>
            <value>
            	<c>true</c> if this instance is operand; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:GemBox.Spreadsheet.FormulaTokenTypeEx.IsFunction">
            <summary>
            Gets a value indicating whether this instance is function.
            </summary>
            <value>
            	<c>true</c> if this instance is function; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:GemBox.Spreadsheet.FormulaTokenTypeEx.IsControl">
            <summary>
            Gets a value indicating whether this instance is control.
            </summary>
            <value>
            	<c>true</c> if this instance is control; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="T:GemBox.Spreadsheet.SpreadsheetInfo">
            <summary>
            Contains static licensing methods (GemBox.Spreadsheet Professional only) and diagnostic 
            information about executing GemBox.Spreadsheet assembly.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.SpreadsheetInfo.Title">
            <summary>
            GemBox.Spreadsheet assembly title.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.SpreadsheetInfo.FullVersion">
            <summary>
            GemBox.Spreadsheet assembly full version.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.SpreadsheetException">
            <summary>
            Represents errors that can occur in the GemBox.Spreadsheet component. 
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.SpreadsheetException.#ctor">
            <summary>
            Initializes a new instance of the Exception class. 
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.SpreadsheetException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the Exception class with a specified error message. 
            </summary>
            <param name="msg">Message string.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.SpreadsheetException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the Exception class with a specified error message 
            and a reference to the inner exception that is the cause of this exception. 
            </summary>
            <param name="msg">Message string.</param>
            <param name="inner">Inner exception.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.SpreadsheetException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the Exception class with serialized data. 
            </summary>
            <param name="info">Serialization info.</param>
            <param name="context">Serialization context.</param>
        </member>
        <member name="T:GemBox.Spreadsheet.WinZipAesCrypto">
            <summary> 
            This is a helper class supporting WinZip AES encryption.  
            This class is intended for use only by the DotNetZip library.
            </summary>
            <remarks>
            Most uses of the DotNetZip library will not involve direct calls into the
            WinZipAesCrypto class.  Instead, the WinZipAesCrypto class is instantiated and used by
            the ZipEntry() class when WinZip AES encryption or decryption on an entry is employed.
            </remarks>
        </member>
        <member name="T:GemBox.Spreadsheet.WinZipAesCipherStream">
            <summary>
            A stream that encrypts as it writes, or decrypts as it reads.  The Crypto is AES in 
            CTR (counter) mode, which is 
            compatible with the AES encryption employed by WinZip 12.0.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.WinZipAesCipherStream.#ctor(System.IO.Stream,GemBox.Spreadsheet.WinZipAesCrypto,System.Int64,GemBox.Spreadsheet.CryptoMode)">
            <summary>
            The constructor.
            </summary>
            <param name="s">The underlying stream</param>
            <param name="mode">To either encrypt or decrypt.</param>
            <param name="cryptoParams">The pre-initialized WinZipAesCrypto object.</param>
            <param name="length">The maximum number of bytes to read from the stream.</param>
        </member>
        <member name="P:GemBox.Spreadsheet.WinZipAesCipherStream.FinalAuthentication">
            <summary>
            Returns the final HMAC-SHA1-80 
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.MsoContainerRecord.Add(GemBox.Spreadsheet.MsoBaseRecord)">
            <summary>
            Adds the specified item to container.
            </summary>
            <param name="item">The item to be added.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.MsoContainerRecord.Read(System.IO.BinaryReader)">
            <summary>
            Reads data from the specified reader.
            </summary>
            <param name="reader">The source binary reader.</param>		
        </member>
        <member name="M:GemBox.Spreadsheet.MsoContainerRecord.SetData(GemBox.Spreadsheet.MsoDelayedRecords)">
            <summary>
            Sets the inner data( mso structure' data without header: atom, type, length ).
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelShapeCollection.DeleteInternal(System.Int32)">
            <summary>
            Deletes shape at specified index.
            </summary>
            <param name="index">The specified index.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelShapeCollection.DeleteInternal(GemBox.Spreadsheet.ExcelShape)">
            <summary>
            Deletes shape at specified index.
            </summary>
            <param name="shape">The shape.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelShapeCollection.ImageFormatToBlipType(System.Drawing.Imaging.ImageFormat)">
            <summary>
            Images the type of the format to blip.
            </summary>
            <param name="format">The image format.</param>
            <returns>MsoBlipType value</returns>
        </member>
        <member name="T:GemBox.Spreadsheet.ArrayFormulaToken">
            <summary>
            Formula token for holding array.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.ArrayFormulaToken.#ctor(GemBox.Spreadsheet.FormulaTokenCode)">
            <summary>
            Initializes a new instance of the <see cref="T:GemBox.Spreadsheet.ArrayFormulaToken"/> class.
            </summary>
            <param name="code">The FormulaTokenCode code.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ArrayFormulaToken.Read(System.Byte[],System.Int32)">
            <summary>
            Initialize formula token by reading input data from array of bytes
            </summary>
            <param name="rpnBytes">input data, array of bytes</param>
            <param name="startIndex">start position for array of bytes to read from</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ArrayFormulaToken.ConvertToBytes">
            <summary>
            Convert formula token to array of byte representation.
            </summary>
            <returns>formula token' array of byte representation</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.ArrayFormulaToken.ToString">
            <summary>
            Convert formula token to string representation.
            </summary>
            <returns>formula token string representation</returns>
        </member>
        <member name="T:GemBox.Spreadsheet.XlsxSaveOptions">
            <summary>
            Save options.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.XlsxSaveOptions.Type">
            <summary>
            Specifies type of generated file. Set this property only if you want to override default type.
            </summary>        
        </member>
        <member name="M:GemBox.Spreadsheet.MsoPreservedRecord.Read(System.IO.BinaryReader)">
            <summary>
            Reads data from the specified reader.
            </summary>
            <param name="reader">The source binary reader.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.MsoPreservedRecord.SetData(GemBox.Spreadsheet.MsoDelayedRecords)">
            <summary>
            Sets the inner data( mso structure' data without header: atom, type, length ).
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.NumFormulaToken">
            <summary>
            Formula token for holding integer.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.NumFormulaToken.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:GemBox.Spreadsheet.NumFormulaToken"/> class.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.NumFormulaToken.DelayInitialize(System.Object[])">
            <summary>
            Make custom delay initialize.
            </summary>
            <param name="data">The data for initialization which is unique for each formula token.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.NumFormulaToken.Read(System.Byte[],System.Int32)">
            <summary>
            Initialize formula token by reading input data from array of bytes
            </summary>
            <param name="rpnBytes">input data, array of bytes</param>
            <param name="startIndex">start position for array of bytes to read from</param>
        </member>
        <member name="M:GemBox.Spreadsheet.NumFormulaToken.ConvertToBytes">
            <summary>
            Convert formula token to array of byte representation.
            </summary>
            <returns>formula token' array of byte representation</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.NumFormulaToken.ToString">
            <summary>
            Convert formula token to string representation.
            </summary>
            <returns>formula token string representation</returns>
        </member>
        <member name="T:GemBox.Spreadsheet.IntFormulaToken">
            <summary>
            Formula token for holding integer.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.IntFormulaToken.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:GemBox.Spreadsheet.IntFormulaToken"/> class.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.IntFormulaToken.DelayInitialize(System.Object[])">
            <summary>
            Make custom delay initialize.
            </summary>
            <param name="data">The data for initialization which is unique for each formula token.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.IntFormulaToken.Read(System.Byte[],System.Int32)">
            <summary>
            Initialize formula token by reading input data from array of bytes
            </summary>
            <param name="rpnBytes">input data, array of bytes</param>
            <param name="startIndex">start position for array of bytes to read from</param>
        </member>
        <member name="M:GemBox.Spreadsheet.IntFormulaToken.ConvertToBytes">
            <summary>
            Convert formula token to bytes representation.
            </summary>
            <returns>bytes representation of the formula token</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.IntFormulaToken.ToString">
            <summary>
            Convert formula token to string representation.
            </summary>
            <returns>formula token string representation</returns>
        </member>
        <member name="T:GemBox.Spreadsheet.ExcelPicture">
            <summary>
            Represents a picture object used by <see cref="T:GemBox.Spreadsheet.ExcelPictureCollection">ExcelPictureCollection</see> in the worksheet.
            </summary>	
            <seealso cref="T:GemBox.Spreadsheet.ExcelPictureCollection">ExcelPictureCollection</seealso>				
            <example>
Following code demonstrates how to use images. It shows next features: 
<list type="number">
<item> bmp, jpeg loading </item>
<item> bmp, jpeg loading with custom coordinates and dimensions </item>
</list>
<code lang="vbnet">
	sheet.Pictures.Add( "Image.bmp" ) 
	sheet.Pictures.Add( "Image.bmp", New Rectangle(10, 50, 100, 100) )
</code>
<code lang="C#">
	sheet.Pictures.Add( "Image.bmp" );
	sheet.Pictures.Add( "Image.bmp", new Rectangle( 10, 50, 100, 100 ) );
</code>
</example>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelPicture.#ctor(GemBox.Spreadsheet.ExcelPictureCollection,System.Int32,System.Drawing.Image,System.Drawing.Rectangle)">
            <summary>
            Initializes a new instance of the <see cref="T:GemBox.Spreadsheet.ExcelPicture"/> class.
            </summary>
            <param name="parent">The workbook parent.</param>
            <param name="index">The index in picture collection.</param>
            <param name="image">The image to be added.</param>
            <param name="boundingRectangle">The bounding rectangle.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelPicture.Delete">
            <summary>
            Deletes this picture from picture collection.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelPicture.Image">
            <summary>
            Gets the image previously loaded.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelPicture.BoundingRectangle">
            <summary>
            Gets the image bounding rectangle.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelPicture.Index">
            <summary>
            Gets or sets the index in parent collection.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelPicture.Positioning">
            <summary>
            Gets or sets the positioning options of the pictue.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelPicture.TopLeftCell">
            <summary>
            Gets or sets the top left anchor cell for the picture.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelPicture.BottomRightCell">
            <summary>
            Gets or sets the bottom right anchor cell for the picture.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelPicture.PictureFormat">
            <summary>
            Gets the picture format.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelPicture.ImageStream">
            <summary>
            Gets the image stream.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.PositioningMode">
            <summary>
            Option that specify the behaviour of the picture in the worksheet. 
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.PositioningMode.FreeFloating">
            <summary>
            Picture will not move with any of the anchor cells.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.PositioningMode.Move">
            <summary>
            Picture will move with the top left anchor cell.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.PositioningMode.MoveAndSize">
            <summary>
            Picture will move and resize with both anchor cells.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.ExcelPictureFormat">
            <summary>
            Picture formats.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ExcelPictureFormat.Jpeg">
            <summary>
            Jpeg picture format.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ExcelPictureFormat.Png">
            <summary>
            Png picture format.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ExcelPictureFormat.Tiff">
            <summary>
            Tiff picture format.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ExcelPictureFormat.Gif">
            <summary>
            Gif picture format.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ExcelPictureFormat.Emf">
            <summary>
            Emf picture format.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ExcelPictureFormat.Wmf">
            <summary>
            Wmf picture format.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ExcelPictureFormat.Bmp">
            <summary>
            Bmp picture format.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ExcelPictureFormat.Exif">
            <summary>
            Exif picture format.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ExcelPictureFormat.Ico">
            <summary>
            Ico picture format.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.AnchorCell">
            <summary>
            Represents a anchor cell object used by <see cref="T:GemBox.Spreadsheet.ExcelPictureCollection">ExcelPictureCollection</see> in the worksheet.
            </summary>
            <seealso cref="T:GemBox.Spreadsheet.ExcelPictureCollection">ExcelPictureCollection</seealso>
        </member>
        <member name="M:GemBox.Spreadsheet.AnchorCell.#ctor(GemBox.Spreadsheet.ExcelColumn,GemBox.Spreadsheet.ExcelRow,System.Int64,System.Int64)">
            <overloads>Initializes a new instance of the <see cref="T:GemBox.Spreadsheet.AnchorCell"/> class.</overloads>
            <summary>
            Initializes a new instance by using offset values.
            </summary>
            <param name="column">Column where the anchor is placed.</param>
            <param name="row">Row where the anchor is placed.</param>
            <param name="columnOffset">Column offset for the anchor.</param>
            <param name="rowOffset">Row offset for the anchor.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.AnchorCell.#ctor(GemBox.Spreadsheet.ExcelColumn,GemBox.Spreadsheet.ExcelRow,System.Boolean)">
            <summary>
            Initializes a new instance without using offset values.
            </summary>
            <param name="column">Column where the anchor is placed.</param>
            <param name="row">Row where the anchor is placed.</param>
            <param name="topLeft">If true, anchor will be placed in the top left corner of the anchor cell.
            Otherwise the anchor will be placed in the bottom right corner of the anchor cell.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.AnchorCell.#ctor(GemBox.Spreadsheet.AnchorCell)">
            <summary>
            Initializes a new instance by using another anchor cell.
            </summary>
            <param name="anchorCell">Anchor cell to copy from.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.AnchorCell.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:GemBox.Spreadsheet.AnchorCell">AnchorCell</see> is equal 
            to the current <see cref="T:GemBox.Spreadsheet.AnchorCell">AnchorCell</see>.
            </summary>
            <param name="obj">Object of <see cref="T:GemBox.Spreadsheet.AnchorCell">AnchorCell</see> type.</param>
            <returns><b>true</b> if the specified <see cref="T:GemBox.Spreadsheet.AnchorCell">AnchorCell</see> is equal 
            to the current <see cref="T:GemBox.Spreadsheet.AnchorCell">AnchorCell</see>; otherwise, <b>false</b>.</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.AnchorCell.GetHashCode">
            <summary>
            Gets the hash code for anchor object.
            </summary>
            <returns>Hash code.</returns>
        </member>
        <member name="P:GemBox.Spreadsheet.AnchorCell.Column">
            <summary>
            Gets or sets column for the anchor cell.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.AnchorCell.ColumnOffset">
            <summary>
            Gets or sets column offset for the anchor cell.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.AnchorCell.Row">
            <summary>
            Gets or sets row for the anchor cell.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.AnchorCell.RowOffset">
            <summary>
            Gets or sets row offset for the anchor cell.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.XlsxType">
            <summary>
            OpenXML file type.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.XlsxType.Xlsx">
            <summary>
            Excel 2007 XML Workbook.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.XlsxType.Xlsm">
            <summary>
            Excel 2007 XML Macro-Enabled Workbook.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.XlsxType.Xltx">
            <summary>
            Excel 2007 XML Template.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.XlsxType.Xltm">
            <summary>
            Excel 2007 XML Macro-Enabled Template.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.FormulaTokenType">
            <summary>
            The set of predefined formula token types
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.FormulaTokenClass">
            <summary>
            The set of predefined formula token classes
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.FormulaTokenCode">
            <summary>
            The set of predefined formula token codes
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.RangeIndexingMode">
            <summary>
            Indexing modes used by <see cref="T:GemBox.Spreadsheet.CellRange">CellRange</see>.
            </summary>
            <example> Following code creates horizontal, vertical and rectangular cell ranges and demonstrates how 
indexing works different in different context. <see cref="M:GemBox.Spreadsheet.CellRange.SetBorders(GemBox.Spreadsheet.MultipleBorders,System.Drawing.Color,GemBox.Spreadsheet.LineStyle)">SetBorders</see> 
method is used to mark outside borders of the rectangular range.
<code lang="vbnet">
    Dim cr As CellRange = excelFile.Worksheets(0).Rows(1).Cells

    cr(0).Value = cr.IndexingMode
    cr(3).Value = "D2"
    cr("B").Value = "B2"

    cr = excelFile.Worksheets(0).Columns(4).Cells

    cr(0).Value = cr.IndexingMode
    cr(2).Value = "E3"
    cr("5").Value = "E5"

    cr = excelFile.Worksheets(0).Cells.GetSubrange("F2", "J8")
    cr.SetBorders(MultipleBorders.Outside, Color.Navy, LineStyle.Dashed)

    cr("I7").Value = cr.IndexingMode
    cr(0, 0).Value = "F2"
    cr("G3").Value = "G3"
    cr(5).Value = "F3" <font color="Green">' Cell range width is 5 (F G H I J).</font>
</code>
<code lang="C#">
	CellRange cr = excelFile.Worksheets[0].Rows[1].Cells;				

	cr[0].Value = cr.IndexingMode;
	cr[3].Value = "D2";
	cr["B"].Value = "B2";

	cr = excelFile.Worksheets[0].Columns[4].Cells;

	cr[0].Value = cr.IndexingMode;
	cr[2].Value = "E3";
	cr["5"].Value = "E5";

	cr = excelFile.Worksheets[0].Cells.GetSubrange("F2", "J8");
	cr.SetBorders(MultipleBorders.Outside, Color.Navy, LineStyle.Dashed);

	cr["I7"].Value = cr.IndexingMode;
	cr[0,0].Value = "F2";
	cr["G3"].Value = "G3";
	cr[5].Value = "F3"; <font color="Green">// Cell range width is 5 (F G H I J).</font>
</code>
</example>
            <seealso cref="P:GemBox.Spreadsheet.CellRange.IndexingMode"/>
        </member>
        <member name="F:GemBox.Spreadsheet.RangeIndexingMode.Rectangular">
            <summary>
            Rectangular indexing mode. Rectangular cell range is higher than one row and wider than one column.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.RangeIndexingMode.Horizontal">
            <summary>
            Horizontal indexing mode. Horizontal cell range has 
            <see cref="P:GemBox.Spreadsheet.CellRange.Height">CellRange.Height</see> equal to 1.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.RangeIndexingMode.Vertical">
            <summary>
            Vertical indexing mode. Vertical cell range has 
            <see cref="P:GemBox.Spreadsheet.CellRange.Width">CellRange.Width</see> equal to 1.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.WorksheetWindowOptions.ShowFormulas">
            <summary>
            If set, MS Excel shows formulas. Otherwise, formula results are shown.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.WorksheetWindowOptions.ShowGridLines">
            <summary>
            If set, MS Excel shows grid lines.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.WorksheetWindowOptions.ShowSheetHeaders">
            <summary>
            If set, MS Excel shows row and column headers.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.WorksheetWindowOptions.FrozenPanes">
            <summary>
            If set, panes are frozen in MS Excel.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.WorksheetWindowOptions.ShowZeroValues">
            <summary>
            If set, MS Excel shows zero values. Otherwise, zero values are shown as empty cells.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.WorksheetWindowOptions.DefaultGridLineColor">
            <summary>
            If set, MS Excel uses default grid line color.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.WorksheetWindowOptions.ColumnsFromRightToLeft">
            <summary>
            If set, MS Excel shows columns from right to left.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.WorksheetWindowOptions.ShowOutlineSymbols">
            <summary>
            If set, MS Excel shows outline symbols.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.WorksheetWindowOptions.FrozenNoSplit">
            <summary>
            If set, MS Excel removes splits if pane freeze is removed.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.WorksheetWindowOptions.SheetSelected">
            <summary>
            Set if sheet is selected in MS Excel.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.WorksheetWindowOptions.SheetVisible">
            <summary>
            Set if sheet is visible in MS Excel.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.WorksheetWindowOptions.ShowInPageBreakPreview">
            <summary>
            If set, MS Excel shows worksheet in page break preview. Otherwise, normal view is used.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.NumbersParser">
            <summary>
            Class used for controling number format
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.NumbersParser.formatProvider">
            <summary>
            Number format for string conversion
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.NumbersParser.#cctor">
            <summary>
            Initialize object
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.NumbersParser.IsUshort(System.Double)">
            <summary>
            Determines whether the specified double value is ushort( integer ).
            </summary>
            <param name="doubleValue">The double value.</param>
            <returns>
            	<c>true</c> if the specified double value is ushort; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:GemBox.Spreadsheet.NumbersParser.StrToFloat(System.String)">
            <summary>
            Converts string to float.
            </summary>
            <param name="str">strind data.</param>
            <returns>flot data.</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.NumbersParser.StrToInt(System.String)">
            <summary>
            Converts string to int.
            </summary>
            <param name="data">string data.</param>
            <returns>int data.</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.NumbersParser.StrToDouble(System.String)">
            <summary>
            Convert string to double.
            </summary>
            <param name="data">string data.</param>
            <returns>double data.</returns>
        </member>
        <member name="P:GemBox.Spreadsheet.NumbersParser.Provider">
            <summary>
            Get number format info instance
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.Buffer">
            <summary>
            Buffer class is used as the wrapper aroung input string for FormulaParser providing
            additional helpful methods for accessing string buffer.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.Buffer.Empty">
            <summary>
            Unique char to identify that char is empty
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.Buffer.EmptyInteger">
            <summary>
            Unique integer to identify that integer is null
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.Buffer.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:GemBox.Spreadsheet.Buffer"/> class.
            </summary>
            <param name="data">The string data to wrap.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.Buffer.SkipWhitespaces">
            <summary>
            Skips the whitespaces.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.Buffer.GetNextOnDemand(System.Char,System.Boolean)">
            <summary>
            Gets the next on demand( if next symbol is peek, than read it and return back ).
            Additionally it can skip whitespaces on demand.
            </summary>
            <param name="peek">The char to peek for.</param>
            <param name="skipWhitespaces">if set to <c>true</c> [skip whitespaces].</param>
            <returns>
            read char or special char indicating no read status
            </returns>
        </member>
        <member name="M:GemBox.Spreadsheet.Buffer.GetNext">
            <summary>
            Gets the next char from buffer.
            </summary>		
            <returns>read char or special char indicating no read status</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.Buffer.Peek">
            <summary>
            Peeks for the next char.
            </summary>		
            <returns>read char or special char indicating no read status</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.Buffer.Peek(System.Int32)">
            <summary>
            Peeks for the next char at specified forward-position
            </summary>		
            <returns>read char or special char indicating no read status</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.Buffer.GetNextString(System.Char)">
            <summary>
            Gets the next string from buffer.
            </summary>
            <param name="endChar">The char used as end mark during reading.</param>
            <returns>read string</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.Buffer.GetNextString(System.Char[])">
            <summary>
            Gets the next string from buffer.
            </summary>
            <param name="endChars">The arrag of chars used as end marks during reading.</param>
            <returns>read string</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.Buffer.GetNextString(System.Boolean)">
            <summary>
            Gets the next string from buffer with optional skipping whitespaces.
            </summary>		
            <returns>read string</returns>
        </member>
        <member name="P:GemBox.Spreadsheet.Buffer.Data">
            <summary>
            Gets the input data string buffer.
            </summary>
            <value>The input data string buffer.</value>
        </member>
        <member name="P:GemBox.Spreadsheet.Buffer.Pos">
            <summary>
            Gets the position of input data string buffer.
            </summary>
            <value>The position of input data string buffer.</value>
        </member>
        <member name="P:GemBox.Spreadsheet.Buffer.IsEOF">
            <summary>
            Gets a value indicating whether we have reached end of input buffer.
            </summary>
            <value><c>true</c> if we have reached end of input buffer; otherwise, <c>false</c>.</value>
        </member>
        <member name="T:GemBox.Spreadsheet.ExcelComment">
            <summary>
            Represents a comment object used by <see cref="P:GemBox.Spreadsheet.ExcelCell.Comment">Comment</see> in the worksheet.
            </summary>
            <remarks>Supported only in xlsx.</remarks>
            <example>
Following code demonstrates how to use comments. It shows next features: 
<list type="number">
<item> comment text setting </item>
<item> comment' IsVisible property in action </item>
</list>
<code lang="vbnet">		
	excelFile.Worksheets(0).Cells(0, 0).Comment.Text = "comment1" 
	excelFile.Worksheets(0).Cells(0, 0).Comment.IsVisible = False
</code>
<code lang="C#">
	excelFile.Worksheets[ 0 ].Cells[ 0, 0 ].Comment.Text = "comment1";
	excelFile.Worksheets[ 0 ].Cells[ 0, 0 ].Comment.IsVisible = false;
</code>
</example>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelComment.Text">
            <summary>
            Gets the comment text assigned to excel cell
            </summary>
            <value>The comment text assigned to excel cell.</value>
            <example>
Following code demonstrates how to use comments. It shows next features: 
<list type="number">
<item> comment text setting </item>
<item> comment' IsVisible property in action </item>
</list>
<code lang="vbnet">		
	excelFile.Worksheets(0).Cells(0, 0).Comment.Text = "comment1" 
	excelFile.Worksheets(0).Cells(0, 0).Comment.IsVisible = False
</code>
<code lang="C#">
	excelFile.Worksheets[ 0 ].Cells[ 0, 0 ].Comment.Text = "comment1";
	excelFile.Worksheets[ 0 ].Cells[ 0, 0 ].Comment.IsVisible = false;
</code>
</example>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelComment.Author">
            <summary>
            Gets or sets comment author.
            </summary>
            <value>Comment author.</value>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelComment.IsVisible">
            <summary>
            Gets or sets a value indicating whether this instance is visible.
            </summary>
            <value>
            	<c>true</c> if this instance is visible; otherwise, <c>false</c>.
            </value>
            <example>
Following code demonstrates how to use comments. It shows next features: 
<list type="number">
<item> comment text setting </item>
<item> comment' IsVisible property in action </item>
</list>
<code lang="vbnet">		
	excelFile.Worksheets(0).Cells(0, 0).Comment.Text = "comment1" 
	excelFile.Worksheets(0).Cells(0, 0).Comment.IsVisible = False
</code>
<code lang="C#">
	excelFile.Worksheets[ 0 ].Cells[ 0, 0 ].Comment.Text = "comment1";
	excelFile.Worksheets[ 0 ].Cells[ 0, 0 ].Comment.IsVisible = false;
</code>
</example>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelComment.TopLeftCell">
            <summary>
            Gets or sets the top left anchor cell for the comment shape.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelComment.BottomRightCell">
            <summary>
            Gets or sets the bottom right anchor cell for the comment shape.
            </summary>        
        </member>
        <member name="T:GemBox.Spreadsheet.CRC32">
            <summary>
            Calculates a 32bit Cyclic Redundancy Checksum (CRC) using the
            same polynomial used by Zip. This type is used internally by DotNetZip; it is generally not used directly
            by applications wishing to create, read, or manipulate zip archive files.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.CRC32.GetCrc32(System.IO.Stream)">
            <summary>
            Returns the CRC32 for the specified stream.
            </summary>
            <param name="input">The stream over which to calculate the CRC32</param>
            <returns>the CRC32 calculation</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.CRC32.GetCrc32AndCopy(System.IO.Stream,System.IO.Stream)">
            <summary>
            Returns the CRC32 for the specified stream, and writes the input into the output stream.
            </summary>
            <param name="input">The stream over which to calculate the CRC32</param>
            <param name="output">The stream into which to deflate the input</param>
            <returns>the CRC32 calculation</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.CRC32.SlurpBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the value for the running CRC32 using the given block of bytes.
            This is useful when using the CRC32() class in a Stream.
            </summary>
            <param name="block">block of bytes to slurp</param>
            <param name="offset">starting point in the block</param>
            <param name="count">how many bytes within the block to slurp</param>
        </member>
        <member name="P:GemBox.Spreadsheet.CRC32.TotalBytesRead">
            <summary>
            indicates the total number of bytes read on the CRC stream.
            This is used when writing the ZipDirEntry when compressing files.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.CRC32.Crc32Result">
            <summary>
            Indicates the current CRC for all blocks slurped in.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.CrcCalculatorStream">
             <summary>
             A Stream that calculates a CRC32 (a checksum) on all bytes read, 
             or on all bytes written.
             </summary>
            
             <remarks>
             <para>
             This class can be used to verify the CRC of a ZipEntry when reading from a stream, 
             or to calculate a CRC when writing to a stream.  The stream should be used to either 
             read, or write, but not both.  If you intermix reads and writes, the results are
             not defined. 
             </para>
             <para>This class is intended primarily for use internally by the DotNetZip library.</para>
             </remarks>
        </member>
        <member name="M:GemBox.Spreadsheet.CrcCalculatorStream.#ctor(System.IO.Stream)">
            <summary>
            The constructor.
            </summary>
            <param name="stream">The underlying stream</param>
        </member>
        <member name="M:GemBox.Spreadsheet.CrcCalculatorStream.#ctor(System.IO.Stream,System.Int64)">
            <summary>
            The constructor.
            </summary>
            <param name="stream">The underlying stream</param>
            <param name="length">The length of the stream to slurp</param>
        </member>
        <member name="M:GemBox.Spreadsheet.CrcCalculatorStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read from the stream
            </summary>
            <param name="buffer">the buffer to read</param>
            <param name="offset">the offset at which to start</param>
            <param name="count">the number of bytes to read</param>
            <returns>the number of bytes actually read</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.CrcCalculatorStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Write to the stream. 
            </summary>
            <param name="buffer">the buffer from which to write</param>
            <param name="offset">the offset at which to start writing</param>
            <param name="count">the number of bytes to write</param>
        </member>
        <member name="M:GemBox.Spreadsheet.CrcCalculatorStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.CrcCalculatorStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Not implemented.
            </summary>
            <param name="offset">N/A</param>
            <param name="origin">N/A</param>
            <returns>N/A</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.CrcCalculatorStream.SetLength(System.Int64)">
            <summary>
            Not implemented.
            </summary>
            <param name="value">N/A</param>
        </member>
        <member name="P:GemBox.Spreadsheet.CrcCalculatorStream.TotalBytesSlurped">
             <summary>
             Gets the total number of bytes run through the CRC32 calculator.
             </summary>
            
             <remarks>
             This is either the total number of bytes read, or the total number
             of bytes written, depending on the direction of this stream.
             </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.CrcCalculatorStream.Crc32">
            <summary>
            Provides the current CRC for all blocks slurped in.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.CrcCalculatorStream.CanRead">
            <summary>
            Indicates whether the stream supports reading. 
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.CrcCalculatorStream.CanSeek">
            <summary>
            Indicates whether the stream supports seeking. 
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.CrcCalculatorStream.CanWrite">
            <summary>
            Indicates whether the stream supports writing. 
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.CrcCalculatorStream.Length">
            <summary>
            Not implemented.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.CrcCalculatorStream.Position">
            <summary>
            Not implemented.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.AreaErr3dFormulaToken">
            <summary>
            Formula token for holding 3d reference error.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.Area3dFormulaToken">
            <summary>
            Formula token for holding 3d reference on internal cell range.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.Area3dFormulaToken.regexOptions">
            <summary>
            Regular expression default options
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.Area3dFormulaToken.IsCellRange3DRegex">
            <summary>
            Regular expression used to determinate whether the input string is 3d cell range( 1t case ) or not
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.Area3dFormulaToken.refIndex">
            <summary>
            REF entry' index on EXTERNSHEET record( see the Link Table ).
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.Area3dFormulaToken.#ctor(GemBox.Spreadsheet.FormulaTokenCode,GemBox.Spreadsheet.ExcelWorksheetCollection)">
            <summary>
            Initializes a new instance of the <see cref="T:GemBox.Spreadsheet.Area3dFormulaToken"/> class.
            </summary>
            <param name="code">The FormulaTokenCode code.</param>
            <param name="workbook">The workbook.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.Area3dFormulaToken.IsArea3dToken(System.Byte)">
            <summary>
            Determines whether is the specified code related to area3d token.
            </summary>
            <param name="code">The code to be checked.</param>
            <returns>
            	<c>true</c> if the specified code related to area3d token; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:GemBox.Spreadsheet.Area3dFormulaToken.DelayInitialize(System.Object[])">
            <summary>
            Make custom delay initialize.
            </summary>
            <param name="data">The data for initialization which is unique for each formula token.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.Area3dFormulaToken.Read(System.Byte[],System.Int32)">
            <summary>
            Initialize formula token by reading input data from array of bytes
            </summary>
            <param name="rpnBytes">input data, array of bytes</param>
            <param name="startIndex">start position for array of bytes to read from</param>
        </member>
        <member name="M:GemBox.Spreadsheet.Area3dFormulaToken.ConvertToBytes">
            <summary>
            Convert formula token to array of byte representation.
            </summary>
            <returns>formula token' array of byte representation</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.Area3dFormulaToken.ToString">
            <summary>
            Convert formula token to string representation.
            </summary>
            <returns>formula token string representation</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.AreaErr3dFormulaToken.#ctor(GemBox.Spreadsheet.FormulaTokenCode)">
            <summary>
            Initializes a new instance of the <see cref="T:GemBox.Spreadsheet.AreaErr3dFormulaToken"/> class.
            </summary>
            <param name="code">The FormulaTokenCode code.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.AreaErr3dFormulaToken.ToString">
            <summary>
            Convert formula token to string representation.
            </summary>
            <returns>formula token string representation</returns>
        </member>
        <member name="T:GemBox.Spreadsheet.ExcelPictureCollection">
            <summary>
            Collection of the <see cref="T:GemBox.Spreadsheet.ExcelPicture">ExcelPicture</see>.
            </summary>	
            <remarks>Supported only in xlsx.</remarks>
            <seealso cref="T:GemBox.Spreadsheet.ExcelWorksheet">ExcelWorksheet</seealso>
            <example>
Following code demonstrates how to use images. It shows next features: 
<list type="number">
<item> bmp, jpeg loading </item>
<item> bmp, jpeg loading with custom coordinates and dimensions </item>
</list>
<code lang="vbnet">
	sheet.Pictures.Add( "Image.bmp" ) 
	sheet.Pictures.Add( "Image.bmp", New Rectangle(10, 50, 100, 100) )
</code>
<code lang="C#">
	sheet.Pictures.Add( "Image.bmp" );
	sheet.Pictures.Add( "Image.bmp", new Rectangle( 10, 50, 100, 100 ) );
</code>
</example>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelPictureCollection.#ctor(GemBox.Spreadsheet.ExcelWorksheet)">
            <summary>
            Initializes a new instance of the <see cref="T:GemBox.Spreadsheet.ExcelPictureCollection"/> class.
            </summary>
            <param name="worksheet">The worksheet to initialize with.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelPictureCollection.#ctor(GemBox.Spreadsheet.ExcelWorksheet,GemBox.Spreadsheet.ExcelPictureCollection)">
            <summary>
            Initializes a new instance of the <see cref="T:GemBox.Spreadsheet.ExcelPictureCollection"/> class.
            </summary>
            <param name="worksheet">The worksheet to initialize with.</param>
            <param name="sourcePictures">The collection to initialize with.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelPictureCollection.Add(System.String,System.Drawing.Rectangle)">
            <overloads>Adds new <see cref="T:GemBox.Spreadsheet.ExcelPicture"/> object to ExcelPictureCollection.</overloads>
            <summary>
            Adds the image from specified fileName.
            </summary>
            <param name="fileName">The fileName.</param>
            <param name="rect">The destination rectangle.</param>	
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelPictureCollection.Add(System.IO.MemoryStream,System.Drawing.Rectangle,GemBox.Spreadsheet.ExcelPictureFormat)">
            <summary>
            Adds image from the image object by using defined rectangle.
            </summary>
            <param name="imageStream">Image stream.</param>
            <param name="rect">Destination rectangle.</param>
            <param name="format">Picture format.</param>	
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelPictureCollection.Add(System.String,GemBox.Spreadsheet.PositioningMode,GemBox.Spreadsheet.AnchorCell,GemBox.Spreadsheet.AnchorCell)">
            <summary>
            Adds the image from specified fileName with defined anchor properties.
            </summary>
            <param name="fileName">File name of the image to be added.</param>
            <param name="mode">Positioning mode of the image.</param>
            <param name="topLeftCell">Top left anchor cell.</param>
            <param name="bottomRightCell">Bottom right anchor cell.</param>
            <remarks>If column or row offset is greater then that row height or that column width, excel will show image as that offset is set to 0.</remarks>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelPictureCollection.Add(System.IO.MemoryStream,GemBox.Spreadsheet.PositioningMode,GemBox.Spreadsheet.AnchorCell,GemBox.Spreadsheet.AnchorCell,GemBox.Spreadsheet.ExcelPictureFormat)">
            <summary>
            Adds the image with defined anchor properties.
            </summary>
            <param name="imageStream">Stream of the image to be added.</param>
            <param name="mode">Positioning mode of the image.</param>
            <param name="topLeftCell">Top left anchor cell.</param>
            <param name="bottomRightCell">Bottom right anchor cell.</param>
            <param name="format">Picture format.</param>
            <remarks>If column or row offset is greater then that row height or that column width, excel will show image as that offset is set to 0.</remarks>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelPictureCollection.Clear">
            <summary>
            Clears ExcelPictureCollection.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelPictureCollection.DeleteInternal(System.Int32)">
            <summary>
            Deletes picture at specified index.
            </summary>
            <param name="index">The specified index.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelPictureCollection.GetEnumerator">
            <summary>
            Returns an enumerator that can iterate through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.Generic.IEnumerator{T}">IEnumerator&lt;ExcelPicture&gt;</see>
            that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelPictureCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that can iterate through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/>
            that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelPictureCollection.Count">
            <summary>
            Gets the count of pictures items.
            </summary>
            <value>The count of pictures items.</value>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelPictureCollection.Item(System.Int32)">
            <summary>
            Gets the <see cref="T:GemBox.Spreadsheet.ExcelPicture"/> at the specified index.
            </summary>
            <value>the <see cref="T:GemBox.Spreadsheet.ExcelPicture"/></value>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelPictureCollection.Worksheet">
            <summary>
            Gets the worksheet.
            </summary>
            <value>The worksheet.</value>
        </member>
        <member name="T:GemBox.Spreadsheet.SharedUtilities">
            <summary>
            Collects general purpose utility methods.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.SharedUtilities.#ctor">
            private null constructor
        </member>
        <member name="M:GemBox.Spreadsheet.SharedUtilities.RoundToEvenSecond(System.DateTime)">
             <summary>
             Round the given DateTime value to an even second value.  
             </summary>
            
             <remarks>
             <para>
             Round up in the case of an odd second value.  The rounding does not consider fractional seconds.
             </para>
             <para>
             This is useful because the Zip spec allows storage of time only to the nearest even second.
             So if you want to compare the time of an entry in the archive with it's actual time in the filesystem, you 
             need to round the actual filesystem time, or use a 2-second threshold for the  comparison. 
             </para>
             <para>
             This is most nautrally an extension method for the DateTime class but this library is 
             built for .NET 2.0, not for .NET 3.5;  This means extension methods are a no-no.  
             </para>
             </remarks>
             <param name="source">The DateTime value to round</param>
             <returns>The ruonded DateTime value</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.SharedUtilities.TrimVolumeAndSwapSlashes(System.String)">
            <summary>
            Utility routine for transforming path names. 
            </summary>
            <param name="pathName">source path.</param>
            <returns>transformed path</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.SharedUtilities.FindSignature(System.IO.Stream,System.Int32)">
            <summary>
            Finds a signature in the zip stream. This is useful for finding 
            the end of a zip entry, for example. 
            </summary>
            <param name="stream"></param>
            <param name="SignatureToFind"></param>
            <returns></returns>
        </member>
        <member name="M:GemBox.Spreadsheet.SharedUtilities.GetTempFilename">
            <summary>
            Return a random filename, suitable for use as a temporary file.
            </summary>
            <remarks>
            The System.IO.Path.GetRandomFileName() method is not available on the Compact
            Framework, so this library provides its own substitute. 
            </remarks>
            <returns>a filename of the form DotNetZip-xxxxxxxx.tmp, where xxxxxxxx is replaced 
            by randomly chosen characters.</returns>
        </member>
        <member name="T:GemBox.Spreadsheet.CountingStream">
            <summary> 
            A Stream wrapper, used for bookkeeping on input or output
            streams.  In some cases, it is not possible to get the Position
            of a stream, let's say, on a write-only output stream like
            ASP.NET's Response.Output, or on a different write-only stream
            provided as the destination for the zip by the application.
            In this case, we can use this counting stream to count the bytes
            read or written.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.CountingStream.#ctor(System.IO.Stream)">
            <summary>
            The  constructor.
            </summary>
            <param name="s">The underlying stream</param>
        </member>
        <member name="T:GemBox.Spreadsheet.SupBookRecord">
            <summary>
            SupBookRecord record is used to provide information about internal 3d references	
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.SupBookRecord.#ctor(System.Int32,System.IO.BinaryReader,GemBox.Spreadsheet.AbsXLSRec,GemBox.Spreadsheet.IoOperationInfo)">
            <summary>
            Initializes a new instance of the <see cref="T:GemBox.Spreadsheet.SupBookRecord"/> class.
            </summary>
            <param name="bodyLength">Length of the body.</param>
            <param name="br">The binary reader to read from.</param>
            <param name="previousRecord">The previous record.</param>
            <param name="operationInfo">Current operation information.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.SupBookRecord.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:GemBox.Spreadsheet.SupBookRecord"/> class.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.SupBookRecord.SheetsCount">
            <summary>
            Gets or sets the sheets count in current workbook.
            </summary>
            <value>The sheets count in current workbook.</value>
        </member>
        <member name="T:GemBox.Spreadsheet.AbstractRange">
            <summary>
            Base class for classes representing one or more excel cells.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.AbstractRange.#ctor(GemBox.Spreadsheet.ExcelWorksheet)">
            <summary>
            Internal.
            </summary>
            <param name="parent"></param>
            <exclude/>
        </member>
        <member name="M:GemBox.Spreadsheet.AbstractRange.SetBorders(GemBox.Spreadsheet.MultipleBorders,System.Drawing.Color,GemBox.Spreadsheet.LineStyle)">
            <summary>
            Sets borders on one or more excel cells, taking cell position into account.
            </summary>
            <param name="multipleBorders">Borders to set.</param>
            <param name="lineColor">Line color.</param>
            <param name="lineStyle">Line style.</param>
        </member>
        <member name="P:GemBox.Spreadsheet.AbstractRange.Comment">
            <summary>
            Gets is sets comment
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.AbstractRange.Formula">
            <summary>
            Gets or sets formula string.
            </summary>		
        </member>
        <member name="P:GemBox.Spreadsheet.AbstractRange.Value">
            <summary>
            Gets or sets cell value on one or more excel cells.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.AbstractRange.Style">
            <summary>
            Gets or sets cell style (<see cref="T:GemBox.Spreadsheet.CellStyle">CellStyle</see>) on one or more excel cells.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.AbstractRange.IsStyleDefault">
            <summary>
            Returns <b>true</b> if all cells in <see cref="T:GemBox.Spreadsheet.AbstractRange">AbstractRange</see> have default 
            cell style; otherwise, <b>false</b>.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.SortDescription">
            <summary>
            Specifies the column, sorting order and optional custom comparison used in <see cref="M:GemBox.Spreadsheet.CellRange.Sort(System.Collections.Generic.IEnumerable{GemBox.Spreadsheet.SortDescription})"/> method.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.SortDescription.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:GemBox.Spreadsheet.SortDescription"/> class with specified sorting column index.
            Valid column indexes are between 0 and <see cref="P:GemBox.Spreadsheet.CellRange.LastColumnIndex"/> - <see cref="P:GemBox.Spreadsheet.CellRange.FirstColumnIndex"/>, inclusive.
            </summary>
            <param name="columnRangeIndex">The column index in the <see cref="T:GemBox.Spreadsheet.CellRange"/> on which <see cref="M:GemBox.Spreadsheet.CellRange.Sort(System.Collections.Generic.IEnumerable{GemBox.Spreadsheet.SortDescription})"/> method has been invoked.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.SortDescription.#ctor(System.Int32,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:GemBox.Spreadsheet.SortDescription"/> class with specified sorting column index and sort direction.
            Valid column indexes are between 0 and <see cref="P:GemBox.Spreadsheet.CellRange.LastColumnIndex"/> - <see cref="P:GemBox.Spreadsheet.CellRange.FirstColumnIndex"/>, inclusive.
            </summary>
            <param name="columnRangeIndex">The column index in the <see cref="T:GemBox.Spreadsheet.CellRange"/> on which <see cref="M:GemBox.Spreadsheet.CellRange.Sort(System.Collections.Generic.IEnumerable{GemBox.Spreadsheet.SortDescription})"/> method has been invoked.</param>
            <param name="isAscending">A value indicating whether sort direction is ascending or descending.</param>
        </member>
        <member name="P:GemBox.Spreadsheet.SortDescription.ColumnRangeIndex">
            <summary>
            Gets the column index in the <see cref="T:GemBox.Spreadsheet.CellRange"/> on which <see cref="M:GemBox.Spreadsheet.CellRange.Sort(System.Collections.Generic.IEnumerable{GemBox.Spreadsheet.SortDescription})"/> method has been invoked.
            </summary>
            <value>
            The column index in the <see cref="T:GemBox.Spreadsheet.CellRange"/> on which <see cref="M:GemBox.Spreadsheet.CellRange.Sort(System.Collections.Generic.IEnumerable{GemBox.Spreadsheet.SortDescription})"/> method has been invoked.
            </value>
        </member>
        <member name="P:GemBox.Spreadsheet.SortDescription.IsAscending">
            <summary>
            Gets a value indicating whether sort direction is ascending or descending.
            </summary>
            <value>
            <c>true</c> if sort direction is ascending; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:GemBox.Spreadsheet.SortDescription.Comparison">
            <summary>
            Gets or sets the comparison that can be used to override default comparison.
            </summary>
            <value>
            The comparison that can be used to override default comparison.
            </value>
        </member>
        <member name="T:GemBox.Spreadsheet.CellRange">
            <summary>
            Cell range is a rectangular group of worksheet cells.
            </summary>
            <remarks>
            <p>Cell range is determined by its top (<see cref="P:GemBox.Spreadsheet.CellRange.FirstRowIndex">FirstRowIndex</see>), 
            left (<see cref="P:GemBox.Spreadsheet.CellRange.FirstColumnIndex">FirstColumnIndex</see>), 
            bottom (<see cref="P:GemBox.Spreadsheet.CellRange.LastRowIndex">LastRowIndex</see>) and 
            right (<see cref="P:GemBox.Spreadsheet.CellRange.LastColumnIndex">LastColumnIndex</see>) borders. This properties 
            are read-only, so if you require different cell range use one of GetSubrange methods 
            (<see cref="M:GemBox.Spreadsheet.CellRange.GetSubrangeAbsolute(System.Int32,System.Int32,System.Int32,System.Int32)">GetSubrangeAbsolute</see>, 
            <see cref="M:GemBox.Spreadsheet.CellRange.GetSubrangeRelative(System.Int32,System.Int32,System.Int32,System.Int32)">GetSubrangeRelative</see> or 
            <see cref="M:GemBox.Spreadsheet.CellRange.GetSubrange(System.String,System.String)">GetSubrange</see>). Specific cell can be accessed in a few 
            ways, depending on <see cref="P:GemBox.Spreadsheet.CellRange.IndexingMode">IndexingMode</see>. Cells in the 
            range can be merged / unmerged by the use of <see cref="P:GemBox.Spreadsheet.CellRange.Merged">Merged</see> 
            property.</p>
            <p><see cref="P:GemBox.Spreadsheet.CellRange.Value">Value</see> property set will set value of multiple cells 
            or of a merged range. <see cref="P:GemBox.Spreadsheet.CellRange.Value">Value</see> property get has meaning 
            only if range is merged; otherwise, exception is thrown.</p>
            <p><see cref="P:GemBox.Spreadsheet.CellRange.Style">Style</see> property set will set style of multiple cells 
            or of a merged range. <see cref="P:GemBox.Spreadsheet.CellRange.Style">Style</see> property get has meaning 
            only if range is merged; otherwise, exception is thrown.</p>
            <p> Note that for <see cref="P:GemBox.Spreadsheet.CellRange.Style">Style</see> property set on a cell range that 
is not merged, you can't use the following format:
<code lang="vbnet">
	Dim cr As CellRange = excelFile.Worksheets(0).Rows(1).Cells
	cr.Style.Rotation = 30
</code>
<code lang="C#">
	CellRange cr = excelFile.Worksheets[0].Rows[1].Cells;
	cr.Style.Rotation = 30;
</code>
because that would first call <see cref="P:GemBox.Spreadsheet.CellRange.Style">Style</see> property get method and that 
will certainly fail because <see cref="P:GemBox.Spreadsheet.CellRange.Style">Style</see> property get is defined only 
for a merged cell range. </p><p>Instead you can use two different code patterns, depending on whether you want to replace or combine the existing 
cell range styles with the new style.</p><p>
If you want to <b>replace</b> cell style on every cell in a cell range use the following code:
<code lang="vbnet">
	Dim cr As CellRange = excelFile.Worksheets(0).Rows(1).Cells
	Dim style As CellStyle = New CellStyle()
	style.Rotation = 30
	cr.Style = style
</code>
<code lang="C#">
	CellRange cr = excelFile.Worksheets[0].Rows[1].Cells;
	CellStyle style = new CellStyle();
	style.Rotation = 30;
	cr.Style = style;
</code>
</p><p>
If you want to <b>set</b> cell style property on every cell in a cell range (other cell style property values will 
remain unchanged) use the following code:
<code lang="vbnet">
    Dim cell As ExcelCell
    For Each cell In excelFile.Worksheets(0).Rows(1).Cells
        cell.Style.Rotation = 30
    Next
</code>
<code lang="C#">
	foreach(ExcelCell cell in excelFile.Worksheets[0].Rows[1].Cells)
		cell.Style.Rotation = 30;
</code>
</p>
            </remarks>
            <example> Following code creates horizontal, vertical and rectangular cell ranges and demonstrates how 
indexing works different in different context. <see cref="M:GemBox.Spreadsheet.CellRange.SetBorders(GemBox.Spreadsheet.MultipleBorders,System.Drawing.Color,GemBox.Spreadsheet.LineStyle)">SetBorders</see> 
method is used to mark outside borders of the rectangular range.
<code lang="vbnet">
    Dim cr As CellRange = excelFile.Worksheets(0).Rows(1).Cells

    cr(0).Value = cr.IndexingMode
    cr(3).Value = "D2"
    cr("B").Value = "B2"

    cr = excelFile.Worksheets(0).Columns(4).Cells

    cr(0).Value = cr.IndexingMode
    cr(2).Value = "E3"
    cr("5").Value = "E5"

    cr = excelFile.Worksheets(0).Cells.GetSubrange("F2", "J8")
    cr.SetBorders(MultipleBorders.Outside, Color.Navy, LineStyle.Dashed)

    cr("I7").Value = cr.IndexingMode
    cr(0, 0).Value = "F2"
    cr("G3").Value = "G3"
    cr(5).Value = "F3" <font color="Green">' Cell range width is 5 (F G H I J).</font>
</code>
<code lang="C#">
	CellRange cr = excelFile.Worksheets[0].Rows[1].Cells;				

	cr[0].Value = cr.IndexingMode;
	cr[3].Value = "D2";
	cr["B"].Value = "B2";

	cr = excelFile.Worksheets[0].Columns[4].Cells;

	cr[0].Value = cr.IndexingMode;
	cr[2].Value = "E3";
	cr["5"].Value = "E5";

	cr = excelFile.Worksheets[0].Cells.GetSubrange("F2", "J8");
	cr.SetBorders(MultipleBorders.Outside, Color.Navy, LineStyle.Dashed);

	cr["I7"].Value = cr.IndexingMode;
	cr[0,0].Value = "F2";
	cr["G3"].Value = "G3";
	cr[5].Value = "F3"; <font color="Green">// Cell range width is 5 (F G H I J).</font>
</code>
</example>
        </member>
        <member name="M:GemBox.Spreadsheet.CellRange.PositionToRowColumn(System.String,System.Int32@,System.Int32@)">
            <summary>
            Converts position string ("A1", "BN27", etc.) to row and column index.
            </summary>
            <param name="position">Position string.</param>
            <param name="row">Row index.</param>
            <param name="column">Column index.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.CellRange.RowColumnToPosition(System.Int32,System.Int32)">
            <summary>
            Converts row and column index to position string ("A1", "BN27", etc.).
            </summary>
            <param name="row">Row index.</param>
            <param name="column">Column index.</param>
            <returns>Position string.</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.CellRange.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:GemBox.Spreadsheet.CellRange">CellRange</see> is equal 
            to the current <see cref="T:GemBox.Spreadsheet.CellRange">CellRange</see>.
            </summary>
            <param name="obj">Object of <see cref="T:GemBox.Spreadsheet.CellRange">CellRange</see> type.</param>
            <returns><b>true</b> if the specified <see cref="T:GemBox.Spreadsheet.CellRange">CellRange</see> is equal 
            to the current <see cref="T:GemBox.Spreadsheet.CellRange">CellRange</see>; otherwise, <b>false</b>.</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.CellRange.GetHashCode">
            <summary>
            Returns the hash code of this object.
            </summary>
            <returns>Hash code.</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.CellRange.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:GemBox.Spreadsheet.CellRange">CellRange</see>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:GemBox.Spreadsheet.CellRange">CellRange</see>.
            </returns>
        </member>
        <member name="M:GemBox.Spreadsheet.CellRange.SetBorders(GemBox.Spreadsheet.MultipleBorders,System.Drawing.Color,GemBox.Spreadsheet.LineStyle)">
            <summary>
            Sets borders on one or more excel cells, taking cell position into account.
            </summary>
            <param name="multipleBorders">Borders to set.</param>
            <param name="lineColor">Line color.</param>
            <param name="lineStyle">Line style.</param>
            <example> Following code creates horizontal, vertical and rectangular cell ranges and demonstrates how 
indexing works different in different context. <see cref="M:GemBox.Spreadsheet.CellRange.SetBorders(GemBox.Spreadsheet.MultipleBorders,System.Drawing.Color,GemBox.Spreadsheet.LineStyle)">SetBorders</see> 
method is used to mark outside borders of the rectangular range.
<code lang="vbnet">
    Dim cr As CellRange = excelFile.Worksheets(0).Rows(1).Cells

    cr(0).Value = cr.IndexingMode
    cr(3).Value = "D2"
    cr("B").Value = "B2"

    cr = excelFile.Worksheets(0).Columns(4).Cells

    cr(0).Value = cr.IndexingMode
    cr(2).Value = "E3"
    cr("5").Value = "E5"

    cr = excelFile.Worksheets(0).Cells.GetSubrange("F2", "J8")
    cr.SetBorders(MultipleBorders.Outside, Color.Navy, LineStyle.Dashed)

    cr("I7").Value = cr.IndexingMode
    cr(0, 0).Value = "F2"
    cr("G3").Value = "G3"
    cr(5).Value = "F3" <font color="Green">' Cell range width is 5 (F G H I J).</font>
</code>
<code lang="C#">
	CellRange cr = excelFile.Worksheets[0].Rows[1].Cells;				

	cr[0].Value = cr.IndexingMode;
	cr[3].Value = "D2";
	cr["B"].Value = "B2";

	cr = excelFile.Worksheets[0].Columns[4].Cells;

	cr[0].Value = cr.IndexingMode;
	cr[2].Value = "E3";
	cr["5"].Value = "E5";

	cr = excelFile.Worksheets[0].Cells.GetSubrange("F2", "J8");
	cr.SetBorders(MultipleBorders.Outside, Color.Navy, LineStyle.Dashed);

	cr["I7"].Value = cr.IndexingMode;
	cr[0,0].Value = "F2";
	cr["G3"].Value = "G3";
	cr[5].Value = "F3"; <font color="Green">// Cell range width is 5 (F G H I J).</font>
</code>
</example>
        </member>
        <member name="M:GemBox.Spreadsheet.CellRange.Sort(System.Collections.Generic.IEnumerable{GemBox.Spreadsheet.SortDescription})">
            <summary>
            Sorts the rows of this <see cref="T:GemBox.Spreadsheet.CellRange"/> by comparing values of <see cref="T:GemBox.Spreadsheet.ExcelCell"/>s in columns specified by <paramref name="sortDescriptions"/>.
            </summary>
            <param name="sortDescriptions">The sort descriptions that specify columns by which to sort.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.CellRange.Sort(GemBox.Spreadsheet.SortDescription[])">
            <summary>
            Sorts the rows of this <see cref="T:GemBox.Spreadsheet.CellRange"/> by comparing values of <see cref="T:GemBox.Spreadsheet.ExcelCell"/>s in columns specified by <paramref name="sortDescriptions"/>.
            </summary>
            <param name="sortDescriptions">The sort descriptions that specify columns by which to sort.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.CellRange.GetEnumerator">
            <summary>
            Returns an enumerator for the <see cref="T:GemBox.Spreadsheet.CellRange">CellRange</see> (all cells).
            </summary>
            <remarks>
            Returns default enumerator that iterates all cells in the range. If you are only reading existing
            cells (values or formatting), use more appropriate <see cref="M:GemBox.Spreadsheet.CellRange.GetReadEnumerator"/>.
            </remarks>
        </member>
        <member name="M:GemBox.Spreadsheet.CellRange.GetReadEnumerator">
            <summary>
            Returns enumerator for the <see cref="T:GemBox.Spreadsheet.CellRange">CellRange</see> (only allocated cells).
            </summary>
            <remarks>
            Returns enumerator that iterates only already allocated cells in the range. If you are only reading existing
            cells (values or formatting), use this enumerator as it is faster and doesn't allocate unnecessary cells.
            </remarks>
        </member>
        <member name="M:GemBox.Spreadsheet.CellRange.GetSubrangeAbsolute(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns new cell range using absolute indexing.
            </summary>
            <param name="firstRow">Absolute index of the first row.</param>
            <param name="firstColumn">Absolute index of the first column.</param>
            <param name="lastRow">Absolute index of the last row.</param>
            <param name="lastColumn">Absolute index of the last column.</param>
            <remarks>
            New cell range must be within this cell range.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if arguments are out of range.</exception>
            <seealso cref="P:GemBox.Spreadsheet.CellRange.FirstRowIndex"/>
            <seealso cref="P:GemBox.Spreadsheet.CellRange.FirstColumnIndex"/>
            <seealso cref="P:GemBox.Spreadsheet.CellRange.LastRowIndex"/>
            <seealso cref="P:GemBox.Spreadsheet.CellRange.LastColumnIndex"/>
            <seealso cref="M:GemBox.Spreadsheet.CellRange.GetSubrangeRelative(System.Int32,System.Int32,System.Int32,System.Int32)"/>
            <seealso cref="M:GemBox.Spreadsheet.CellRange.GetSubrange(System.String,System.String)"/>
        </member>
        <member name="M:GemBox.Spreadsheet.CellRange.GetSubrangeRelative(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns new cell range using relative indexing.
            </summary>
            <param name="relativeRow">Relative index of the first row.</param>
            <param name="relativeColumn">Relative index of the first column.</param>
            <param name="width">Width of new cell range in columns.</param>
            <param name="height">Height of new cell range in rows.</param>
            <remarks>
            New cell range must be within this cell range.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if arguments are out of range.</exception>
            <seealso cref="P:GemBox.Spreadsheet.CellRange.Width"/>
            <seealso cref="P:GemBox.Spreadsheet.CellRange.Height"/>
            <seealso cref="M:GemBox.Spreadsheet.CellRange.GetSubrangeAbsolute(System.Int32,System.Int32,System.Int32,System.Int32)"/>
            <seealso cref="M:GemBox.Spreadsheet.CellRange.GetSubrange(System.String,System.String)"/>
        </member>
        <member name="M:GemBox.Spreadsheet.CellRange.GetSubrange(System.String,System.String)">
            <summary>
            Returns new cell range using start and end position.
            </summary>
            <param name="firstCell">Name of first (top-left) cell.</param>
            <param name="lastCell">Name of last (bottom-right) cell.</param>
            <remarks>
            New cell range must be within this cell range.
            </remarks>
            <example> Following code creates horizontal, vertical and rectangular cell ranges and demonstrates how 
indexing works different in different context. <see cref="M:GemBox.Spreadsheet.CellRange.SetBorders(GemBox.Spreadsheet.MultipleBorders,System.Drawing.Color,GemBox.Spreadsheet.LineStyle)">SetBorders</see> 
method is used to mark outside borders of the rectangular range.
<code lang="vbnet">
    Dim cr As CellRange = excelFile.Worksheets(0).Rows(1).Cells

    cr(0).Value = cr.IndexingMode
    cr(3).Value = "D2"
    cr("B").Value = "B2"

    cr = excelFile.Worksheets(0).Columns(4).Cells

    cr(0).Value = cr.IndexingMode
    cr(2).Value = "E3"
    cr("5").Value = "E5"

    cr = excelFile.Worksheets(0).Cells.GetSubrange("F2", "J8")
    cr.SetBorders(MultipleBorders.Outside, Color.Navy, LineStyle.Dashed)

    cr("I7").Value = cr.IndexingMode
    cr(0, 0).Value = "F2"
    cr("G3").Value = "G3"
    cr(5).Value = "F3" <font color="Green">' Cell range width is 5 (F G H I J).</font>
</code>
<code lang="C#">
	CellRange cr = excelFile.Worksheets[0].Rows[1].Cells;				

	cr[0].Value = cr.IndexingMode;
	cr[3].Value = "D2";
	cr["B"].Value = "B2";

	cr = excelFile.Worksheets[0].Columns[4].Cells;

	cr[0].Value = cr.IndexingMode;
	cr[2].Value = "E3";
	cr["5"].Value = "E5";

	cr = excelFile.Worksheets[0].Cells.GetSubrange("F2", "J8");
	cr.SetBorders(MultipleBorders.Outside, Color.Navy, LineStyle.Dashed);

	cr["I7"].Value = cr.IndexingMode;
	cr[0,0].Value = "F2";
	cr["G3"].Value = "G3";
	cr[5].Value = "F3"; <font color="Green">// Cell range width is 5 (F G H I J).</font>
</code>
</example>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if arguments are out of range.</exception>
            <seealso cref="P:GemBox.Spreadsheet.CellRange.StartPosition"/>
            <seealso cref="P:GemBox.Spreadsheet.CellRange.EndPosition"/>
            <seealso cref="M:GemBox.Spreadsheet.CellRange.GetSubrangeAbsolute(System.Int32,System.Int32,System.Int32,System.Int32)"/>
            <seealso cref="M:GemBox.Spreadsheet.CellRange.GetSubrangeRelative(System.Int32,System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:GemBox.Spreadsheet.CellRange.CopyTo(System.Int32,System.Int32)">
            <overloads>Copies this cell range to the specified position.</overloads>
            <summary>
            Copies this cell range to another position in the same worksheet.
            </summary>
            <param name="absoluteRow">Absolute index of the destination row.</param>
            <param name="absoluteColumn">Absolute index of the destination column.</param>
            <remarks>
            <p><i>absoluteRow</i> and <i>absoluteColumn</i> specify position of the top-left cell of 
            the destination cell range.</p>
            <p>Destination cell range has the same width and height as this cell range.</p>
            <p><see cref="T:System.ArgumentOutOfRangeException"/> is thrown if destination range:
            <list type="bullet">
            <item><description>breaks Excel worksheet row or column limit,</description></item>
            <item><description>overlaps with source range, or</description></item>
            <item><description>overlaps with existing merged range.</description></item>
            </list></p>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if destination range is invalid.</exception>
        </member>
        <member name="M:GemBox.Spreadsheet.CellRange.CopyTo(GemBox.Spreadsheet.ExcelWorksheet,System.Int32,System.Int32)">
            <summary>
            Copies this cell range to another worksheet.
            </summary>
            <param name="destinationWorksheet">Destination worksheet.</param>
            <param name="absoluteRow">Absolute index of the destination row.</param>
            <param name="absoluteColumn">Absolute index of the destination column.</param>
            <remarks>
            <p><i>absoluteRow</i> and <i>absoluteColumn</i> specify position of the top-left cell of 
            the destination cell range.</p>
            <p>Destination cell range has the same width and height as this cell range.</p>
            <p><see cref="T:System.ArgumentOutOfRangeException"/> is thrown if destination range:
            <list type="bullet">
            <item><description>breaks Excel worksheet row or column limit,</description></item>
            <item><description>overlaps with source range, or</description></item>
            <item><description>overlaps with existing merged range.</description></item>
            </list></p>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if destination range is invalid.</exception>
        </member>
        <member name="M:GemBox.Spreadsheet.CellRange.CopyTo(System.String)">
            <summary>
            Copies this cell range to another position in the same worksheet.
            </summary>
            <param name="topLeftCell">Full name of the top-left cell of the destination range.</param>
            <remarks>
            <p><i>topLeftCell</i> specifies position of the top-left cell of 
            the destination cell range.</p>
            <p>Destination cell range has the same width and height as this cell range.</p>
            <p><see cref="T:System.ArgumentOutOfRangeException"/> is thrown if destination range:
            <list type="bullet">
            <item><description>breaks Excel worksheet row or column limit,</description></item>
            <item><description>overlaps with source range, or</description></item>
            <item><description>overlaps with existing merged range.</description></item>
            </list></p>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if destination range is invalid.</exception>
        </member>
        <member name="M:GemBox.Spreadsheet.CellRange.CopyTo(GemBox.Spreadsheet.ExcelWorksheet,System.String)">
            <summary>
            Copies this cell range to another worksheet.
            </summary>
            <param name="destinationWorksheet">Destination worksheet.</param>
            <param name="topLeftCell">Full name of the top-left cell of the destination range.</param>
            <remarks>
            <p><i>topLeftCell</i> specifies position of the top-left cell of 
            the destination cell range.</p>
            <p>Destination cell range has the same width and height as this cell range.</p>
            <p><see cref="T:System.ArgumentOutOfRangeException"/> is thrown if destination range:
            <list type="bullet">
            <item><description>breaks Excel worksheet row or column limit,</description></item>
            <item><description>overlaps with source range, or</description></item>
            <item><description>overlaps with existing merged range.</description></item>
            </list></p>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if destination range is invalid.</exception>
        </member>
        <member name="M:GemBox.Spreadsheet.CellRange.Overlaps(GemBox.Spreadsheet.CellRange)">
            <summary>
            Checks if this cell range overlaps with another cell range.
            </summary>
            <param name="range">Cell range.</param>
            <returns><b>true</b> if cell ranges overlap; otherwise, <b>false</b>.</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.CellRange.FindText(System.String,System.Boolean,System.Boolean,System.Int32@,System.Int32@)">
            <summary>
            Finds the first occurrence of the specified text in the current cell range.
            </summary>
            <param name="text">Test to search.</param>
            <param name="matchCase"><b>True</b> to match exact case, <b>false</b> otherwise.</param>
            <param name="matchEntireCellContents"><b>True</b> to match entire cell contents, <b>false</b> otherwise.</param>
            <param name="row">Index of the row where the text was found or -1 if no text was found.</param>
            <param name="column">Index of the column where the text was found or -1 if no text was found.</param>
            <returns><b>True</b> if text is found, <b>false</b> otherwise.</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.CellRange.ExportToHtml(System.String,GemBox.Spreadsheet.HtmlExporterOptions,System.Boolean)">
            <overloads>Exports all data from the range to a new file or XmlTextWriter in HTML format.</overloads>
            <summary>
            Exports all data from the range to a new file in HTML format.
            </summary>
            <param name="filePath">File path.</param>
            <param name="options">Options that describe exporting process. 
            If the value is null, new HtmlExporterOptions is created with <see cref="P:GemBox.Spreadsheet.HtmlExporterOptions.ShowColumnLetters">HtmlExporterOptions.ShowColumnLetters</see> and <see cref="P:GemBox.Spreadsheet.HtmlExporterOptions.ShowRowNumbers">HtmlExporterOptions.ShowRowNumbers</see> set to true.</param>
            <param name="indented">Saved file will use XmlTextWriter with Formatting property set to Formatting.Indented.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.CellRange.ExportToHtml(System.Xml.XmlTextWriter,GemBox.Spreadsheet.HtmlExporterOptions,System.Boolean)">
            <summary>
            Exports all data from the range to a XmlTextWriter in HTML format.
            </summary>
            <param name="writer">Xml text writer.</param>
            <param name="options">Options that describe exporting process. 
            If the value is null, new HtmlExporterOptions is created with <see cref="P:GemBox.Spreadsheet.HtmlExporterOptions.ShowColumnLetters">HtmlExporterOptions.ShowColumnLetters</see> and <see cref="P:GemBox.Spreadsheet.HtmlExporterOptions.ShowRowNumbers">HtmlExporterOptions.ShowRowNumbers</see> set to true.</param>
            <param name="entirePage">If true, entire page will be exported. If false, only table will be exported.</param>
        </member>
        <member name="P:GemBox.Spreadsheet.CellRange.FirstRowIndex">
            <summary>
            Gets index of the first (topmost) row.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.CellRange.FirstColumnIndex">
            <summary>
            Gets index of the first (leftmost) column.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.CellRange.LastRowIndex">
            <summary>
            Gets index of the last (bottommost) row.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.CellRange.LastColumnIndex">
            <summary>
            Gets index of the last (rightmost) column.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.CellRange.Width">
            <summary>
            Gets width of this cell range, in columns.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.CellRange.Height">
            <summary>
            Gets height of this cell range, in rows.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.CellRange.StartPosition">
            <summary>
            Gets name of the first (top-left) cell in this cell range.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.CellRange.EndPosition">
            <summary>
            Gets name of the last (bottom-right) cell in this cell range.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.CellRange.IsAnyCellMerged">
            <summary>
            Returns <b>true</b> is any cell in this cell range is merged; otherwise, <b>false</b>.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.CellRange.Item(System.Int32)">
            <overloads>Gets excel cell with the specified name or at the specified position.</overloads>
            <summary>
            Gets excel cell at the specified index.
            </summary>
            <param name="contextIndex">The zero-based context index of the cell.</param>
            <remarks>
            <p>If <see cref="P:GemBox.Spreadsheet.CellRange.IndexingMode">IndexingMode</see> is 
            <see cref="F:GemBox.Spreadsheet.RangeIndexingMode.Horizontal">RangeIndexingMode.Horizontal</see> context index  
            is specifying relative column position.</p>
            <p>If <see cref="P:GemBox.Spreadsheet.CellRange.IndexingMode">IndexingMode</see> is 
            <see cref="F:GemBox.Spreadsheet.RangeIndexingMode.Vertical">RangeIndexingMode.Vertical</see> context index
            is specifying relative row position.</p>
            <p>If <see cref="P:GemBox.Spreadsheet.CellRange.IndexingMode">IndexingMode</see> is 
            <see cref="F:GemBox.Spreadsheet.RangeIndexingMode.Rectangular">RangeIndexingMode.Rectangular</see> context index
            is specifying cell index inside cell range. The cell at <see cref="P:GemBox.Spreadsheet.CellRange.StartPosition">
            StartPosition</see> has index 0, and the cell at 
            <see cref="P:GemBox.Spreadsheet.CellRange.EndPosition">EndPosition</see> has index of 
            <see cref="P:GemBox.Spreadsheet.CellRange.Width">Width</see> x 
            <see cref="P:GemBox.Spreadsheet.CellRange.Height">Height</see> - 1.</p>
            </remarks>
            <example> Following code creates horizontal, vertical and rectangular cell ranges and demonstrates how 
indexing works different in different context. <see cref="M:GemBox.Spreadsheet.CellRange.SetBorders(GemBox.Spreadsheet.MultipleBorders,System.Drawing.Color,GemBox.Spreadsheet.LineStyle)">SetBorders</see> 
method is used to mark outside borders of the rectangular range.
<code lang="vbnet">
    Dim cr As CellRange = excelFile.Worksheets(0).Rows(1).Cells

    cr(0).Value = cr.IndexingMode
    cr(3).Value = "D2"
    cr("B").Value = "B2"

    cr = excelFile.Worksheets(0).Columns(4).Cells

    cr(0).Value = cr.IndexingMode
    cr(2).Value = "E3"
    cr("5").Value = "E5"

    cr = excelFile.Worksheets(0).Cells.GetSubrange("F2", "J8")
    cr.SetBorders(MultipleBorders.Outside, Color.Navy, LineStyle.Dashed)

    cr("I7").Value = cr.IndexingMode
    cr(0, 0).Value = "F2"
    cr("G3").Value = "G3"
    cr(5).Value = "F3" <font color="Green">' Cell range width is 5 (F G H I J).</font>
</code>
<code lang="C#">
	CellRange cr = excelFile.Worksheets[0].Rows[1].Cells;				

	cr[0].Value = cr.IndexingMode;
	cr[3].Value = "D2";
	cr["B"].Value = "B2";

	cr = excelFile.Worksheets[0].Columns[4].Cells;

	cr[0].Value = cr.IndexingMode;
	cr[2].Value = "E3";
	cr["5"].Value = "E5";

	cr = excelFile.Worksheets[0].Cells.GetSubrange("F2", "J8");
	cr.SetBorders(MultipleBorders.Outside, Color.Navy, LineStyle.Dashed);

	cr["I7"].Value = cr.IndexingMode;
	cr[0,0].Value = "F2";
	cr["G3"].Value = "G3";
	cr[5].Value = "F3"; <font color="Green">// Cell range width is 5 (F G H I J).</font>
</code>
</example>
            <seealso cref="P:GemBox.Spreadsheet.CellRange.IndexingMode"/>
        </member>
        <member name="P:GemBox.Spreadsheet.CellRange.Item(System.Int32,System.Int32)">
            <summary>
            Gets excel cell at the specified relative position.
            </summary>
            <param name="relativeRow">The zero-based relative row position.</param>
            <param name="relativeColumn">The zero-based relative column position.</param>
            <remarks>
            Absolute position of excel cell is calculated by adding <i>relativeRow</i> and <i>relativeColumn</i> to
            <see cref="P:GemBox.Spreadsheet.CellRange.FirstRowIndex">FirstRowIndex</see> and 
            <see cref="P:GemBox.Spreadsheet.CellRange.FirstColumnIndex">FirstColumnIndex</see>.
            </remarks>
            <example> Following code creates horizontal, vertical and rectangular cell ranges and demonstrates how 
indexing works different in different context. <see cref="M:GemBox.Spreadsheet.CellRange.SetBorders(GemBox.Spreadsheet.MultipleBorders,System.Drawing.Color,GemBox.Spreadsheet.LineStyle)">SetBorders</see> 
method is used to mark outside borders of the rectangular range.
<code lang="vbnet">
    Dim cr As CellRange = excelFile.Worksheets(0).Rows(1).Cells

    cr(0).Value = cr.IndexingMode
    cr(3).Value = "D2"
    cr("B").Value = "B2"

    cr = excelFile.Worksheets(0).Columns(4).Cells

    cr(0).Value = cr.IndexingMode
    cr(2).Value = "E3"
    cr("5").Value = "E5"

    cr = excelFile.Worksheets(0).Cells.GetSubrange("F2", "J8")
    cr.SetBorders(MultipleBorders.Outside, Color.Navy, LineStyle.Dashed)

    cr("I7").Value = cr.IndexingMode
    cr(0, 0).Value = "F2"
    cr("G3").Value = "G3"
    cr(5).Value = "F3" <font color="Green">' Cell range width is 5 (F G H I J).</font>
</code>
<code lang="C#">
	CellRange cr = excelFile.Worksheets[0].Rows[1].Cells;				

	cr[0].Value = cr.IndexingMode;
	cr[3].Value = "D2";
	cr["B"].Value = "B2";

	cr = excelFile.Worksheets[0].Columns[4].Cells;

	cr[0].Value = cr.IndexingMode;
	cr[2].Value = "E3";
	cr["5"].Value = "E5";

	cr = excelFile.Worksheets[0].Cells.GetSubrange("F2", "J8");
	cr.SetBorders(MultipleBorders.Outside, Color.Navy, LineStyle.Dashed);

	cr["I7"].Value = cr.IndexingMode;
	cr[0,0].Value = "F2";
	cr["G3"].Value = "G3";
	cr[5].Value = "F3"; <font color="Green">// Cell range width is 5 (F G H I J).</font>
</code>
</example>
        </member>
        <member name="P:GemBox.Spreadsheet.CellRange.Item(System.String)">
            <summary>
            Gets excel cell with the specified full or partial name.
            </summary>
            <param name="contextName">Full or partial name of the cell.</param>
            <remarks>
            <p>If <see cref="P:GemBox.Spreadsheet.CellRange.IndexingMode">IndexingMode</see> is 
            <see cref="F:GemBox.Spreadsheet.RangeIndexingMode.Rectangular">RangeIndexingMode.Rectangular</see> full name of 
            the cell must be used (for example; "A1", "D7", etc.).</p>
            <p>If <see cref="P:GemBox.Spreadsheet.CellRange.IndexingMode">IndexingMode</see> is 
            <see cref="F:GemBox.Spreadsheet.RangeIndexingMode.Horizontal">RangeIndexingMode.Horizontal</see> column name  
            must be used (for example; "A", "D", etc.).</p>
            <p>If <see cref="P:GemBox.Spreadsheet.CellRange.IndexingMode">IndexingMode</see> is 
            <see cref="F:GemBox.Spreadsheet.RangeIndexingMode.Vertical">RangeIndexingMode.Vertical</see> row name 
            must be used (for example; "1", "7", etc.).</p>
            </remarks>
            <example> Following code creates horizontal, vertical and rectangular cell ranges and demonstrates how 
indexing works different in different context. <see cref="M:GemBox.Spreadsheet.CellRange.SetBorders(GemBox.Spreadsheet.MultipleBorders,System.Drawing.Color,GemBox.Spreadsheet.LineStyle)">SetBorders</see> 
method is used to mark outside borders of the rectangular range.
<code lang="vbnet">
    Dim cr As CellRange = excelFile.Worksheets(0).Rows(1).Cells

    cr(0).Value = cr.IndexingMode
    cr(3).Value = "D2"
    cr("B").Value = "B2"

    cr = excelFile.Worksheets(0).Columns(4).Cells

    cr(0).Value = cr.IndexingMode
    cr(2).Value = "E3"
    cr("5").Value = "E5"

    cr = excelFile.Worksheets(0).Cells.GetSubrange("F2", "J8")
    cr.SetBorders(MultipleBorders.Outside, Color.Navy, LineStyle.Dashed)

    cr("I7").Value = cr.IndexingMode
    cr(0, 0).Value = "F2"
    cr("G3").Value = "G3"
    cr(5).Value = "F3" <font color="Green">' Cell range width is 5 (F G H I J).</font>
</code>
<code lang="C#">
	CellRange cr = excelFile.Worksheets[0].Rows[1].Cells;				

	cr[0].Value = cr.IndexingMode;
	cr[3].Value = "D2";
	cr["B"].Value = "B2";

	cr = excelFile.Worksheets[0].Columns[4].Cells;

	cr[0].Value = cr.IndexingMode;
	cr[2].Value = "E3";
	cr["5"].Value = "E5";

	cr = excelFile.Worksheets[0].Cells.GetSubrange("F2", "J8");
	cr.SetBorders(MultipleBorders.Outside, Color.Navy, LineStyle.Dashed);

	cr["I7"].Value = cr.IndexingMode;
	cr[0,0].Value = "F2";
	cr["G3"].Value = "G3";
	cr[5].Value = "F3"; <font color="Green">// Cell range width is 5 (F G H I J).</font>
</code>
</example>
            <seealso cref="P:GemBox.Spreadsheet.CellRange.IndexingMode"/>
        </member>
        <member name="P:GemBox.Spreadsheet.CellRange.Merged">
            <summary>
            Gets or sets whether cells in this range are merged.
            </summary>
            <remarks>
            <p>By setting this property to <b>true</b>, you are merging all the cells 
            (<see cref="T:GemBox.Spreadsheet.ExcelCell">ExcelCell</see>) in this range. Merging process will fail if any 
            of the cells in the range is already merged.</p>
            <p>When modifying merged cell, whole merged range is modified. For example, if you set 
            <see cref="P:GemBox.Spreadsheet.ExcelCell.Value">ExcelCell.Value</see>, value of merged range will be modified. 
            You can find out if the cell is merged by checking if 
            <see cref="P:GemBox.Spreadsheet.ExcelCell.MergedRange">ExcelCell.MergedRange</see> property is different 
            than <b>null</b>.</p>
            </remarks>
            <exception cref="T:System.ArgumentException">Thrown when merged range can't be created because some of the cells
            in the range are already merged.</exception>
        </member>
        <member name="P:GemBox.Spreadsheet.CellRange.Comment">
            <summary>
            Gets or sets comment
            </summary>		
        </member>
        <member name="P:GemBox.Spreadsheet.CellRange.Formula">
            <summary>
            Gets or sets formula string.
            </summary>
            <remarks>
            <p>GemBox.Spreadsheet can read and write formulas, but cannot calculate formula results. However, when you 
            open a file in MS Excel, formula results will be calculated automatically.</p>
            <p>Old XLS format requires all formulas to be parsed and saved to XLS files as special
            tokens in RPN (Reverse Polish notation). GemBox.Spreadsheet only knows how to parse limited
            set of formulas listed below.</p>
            <p>New XLSX (Open XML) format stores formulas as strings and leaves formula parsing to applications
            that read XLSX documents. Therefore, ALL formulas are supported when writing/reading XLSX files.</p>
            <p>Depending on <see cref="P:GemBox.Spreadsheet.ExcelFile.DelayFormulaParse">
            ExcelFile.DelayFormulaParse</see> property, formula string can be parsed when this property is set
            or when one of <see cref="M:GemBox.Spreadsheet.ExcelFile.SaveXls(System.String)">
            ExcelFile.SaveXls</see> methods is called.</p>
            <p>GemBox.Spreadsheet formula parser will use English culture to parse numbers.</p>
            <p>Currently supported formula features by GemBox.Spreadsheet XLS formula parser are:
            <list type="bullet">
            <item><description>Named cell</description></item>
            <item><description>Named range</description></item>
            <item><description>Absolute cell/range</description></item>
            <item><description>Relative cell/range</description></item>
            <item><description>Functions( partly, see the list of supported functions below )</description></item>
            <item><description>Missed argument</description></item>
            <item><description>Unary operator</description></item>
            <item><description>Binary operator</description></item>
            <item><description>Parentheses</description></item>
            <item><description>3d cell reference</description></item>
            <item><description>3d cell range reference</description></item>
            <item><description>Boolean</description></item>
            <item><description>Integer</description></item>
            <item><description>Float</description></item>
            <item><description>String</description></item>
            <item><description>Error</description></item>
            </list>
            </p>
            <p>
            Currently unsupported formula features are:
            <list type="bullet">
            <item><description>Const array</description></item>
            <item><description>Array formula</description></item>
            <item><description>R1C1 reference</description></item>
            </list>
            </p>
            <p>
            Currently supported functions are: ABS, ACOS, ACOSH, ADDRESS, AND, ARCTAN, AREAS, ASC, ASIN, ASINH, ATAN2, ATANH, AVEDEV, AVERAGE, AVERAGE, BETADIST, BETAINV, BINOMDIST, CEILING, CELL, CHAR, CHIDST, CHIINV, CHOOSE, CLEAN, CODE, COLUMN, COLUMNS, COMBIN, CONCATENATE, CONFIDENCE, COS, COSH, COUNT, COUNTA, COUNTBLANK, COUNTIF, CRITBINOM, DATE, DATEDIF, DATESTRING, DATEVALUE, DAVERAGE, DAY, DAYS360, DB, DBSC, DCOUNT, DCOUNTA, DDB, DEGREES, DEVSQ, DGET, DMAX, DMIN, DOLLAR, DPRODUCT, DSTDEV, DSTDEVP, DSUM, DVAR, DVARP, EVEN, EXACT, EXP, EXPONDIST, FACT, FDIST, FIND, FINDB, FINV, FISHER, FISHERINV, FIXED, FLOOR, FV, GAMMADIST, GAMMAINV, GAMMALN, GEOMEAN, GROWTH, HARMEAN, HLOOKUP, HOUR, HYPERLINK, HYPGEOMVERT, IF, INDEX, INDIRECT, INFO, INT, IPMT, IRR, ISBLANK, ISERR, ISERROR, ISLOGICAL, ISNA, ISNONTEXT, ISNUMBER, ISPMT, ISREF, ISTEXT, KURT, LARGE, LEFT, LEFTB, LEN, LENB, LINEST, LN, LOG, LOG10, LOGEST, LOGINV, LOOKUP, LOWER, MATCH, MAX, MAXA, MDETERM, MEDIAN, MID, MIDB, MIN, MINA, MINUTE, MINVERSE, MIRR, MNORMSINV, MOD, MODE, MONTH, N, NA, EGBINOMDIST, NORMDIST, NORMINV, NORMSDIST, NORMSDIST, NOT, NOW, NPER, NPV, NUMBERSTRING, ODD, OFFSET, OR, PERCENTILE, PERCENTRANK, PERMUT, PHONETIC, PI, PMT, POISSON, POWER, PPMT, PRODUCT, PROPER, PV, QUARTILE, RADIANS, RAND, RANK, RATE, REPLACE, REPLACEB, REPT, RIGHT, RIGHTB, ROMAN, ROUND, ROUNDDOWN, ROUNDUP, ROW, ROWS, SEARCH, SEARCHB, SECOND, SIGN, SIN, SINH, SKEW, SLN, SMALL, SQRT, STANDARDIZE, STDEV, STDEVA, STDEVP, STDEVPA, SUBSTITUTE, SUBTOTAL, SUM, SUMIF, SUMSQ, SYD, T, TAN, TANH, TDIST, TEXT, TIME, TIMEVALUE, TINV, TODAY, TRANSPOSE, TREND, TRIM, TRIMMEAN, TRUNC, TYPE, UPPER, USDOLLAR, VALUE, VAR, VARA, VARP, VARPA, VDB, VLOOKUP, WEEKDAY, WEIBULL, YEAR, ZTEST, FALSE, TRUE.
            </p>
            <p>
            For more information on formulas, consult Microsoft Excel documentation.
            </p>
            </remarks>
            <exception cref="T:System.InvalidOperationException">Thrown if property get is attempted on a cell range 
            which is not merged.</exception>
            <example>Following code demonstrates how to use formulas and named ranges. It shows next features: 
cell references (both absolute and relative), unary and binary operators, constand operands (integer and floating point),
functions and named cell ranges.
<code lang="vbnet">
    ws.Cells("A1").Value = 5
    ws.Cells("A2").Value = 6
    ws.Cells("A3").Value = 10
 
    ws.Cells("C1").Formula = "=A1+A2"
    ws.Cells("C2").Formula = "=$A$1-A3"
    ws.Cells("C3").Formula = "=COUNT(A1:A3)"
    ws.Cells("C4").Formula = "=AVERAGE($A$1:$A$3)"
    ws.Cells("C5").Formula = "=SUM(A1:A3,2,3)"
    ws.Cells("C7").Formula = "= 123 - (-(-(23.5)))"
 
    ws.NamedRanges.Add("DataRange", ws.Cells.GetSubrange("A1", "A3"))
    ws.Cells("C8").Formula = "=MAX(DataRange)"
 
    Dim cr As CellRange = ws.Cells.GetSubrange("B9","C10")
    cr.Merged = True
    cr.Formula = "=A1*25"
</code>
<code lang="C#">	
	ws.Cells["A1"].Value = 5;
	ws.Cells["A2"].Value = 6;
	ws.Cells["A3"].Value = 10;

	ws.Cells["C1"].Formula = "=A1+A2";
	ws.Cells["C2"].Formula = "=$A$1-A3";
	ws.Cells["C3"].Formula = "=COUNT(A1:A3)";
	ws.Cells["C4"].Formula = "=AVERAGE($A$1:$A$3)";
	ws.Cells["C5"].Formula = "=SUM(A1:A3,2,3)";
	ws.Cells["C7"].Formula = "= 123 - (-(-(23.5)))";

	ws.NamedRanges.Add("DataRange", ws.Cells.GetSubrange("A1", "A3"));
	ws.Cells["C8"].Formula = "=MAX(DataRange)";

	CellRange cr = ws.Cells.GetSubrange("B9", "C10");
	cr.Merged = true;
	cr.Formula = "=A1*25";
</code>
</example>
            <seealso cref="M:GemBox.Spreadsheet.NamedRangeCollection.Add(System.String,GemBox.Spreadsheet.CellRange,System.Boolean)">
            NamedRangeCollection.Add</seealso>
        </member>
        <member name="P:GemBox.Spreadsheet.CellRange.Value">
            <summary>
            Gets or sets cell value on one or more excel cells.
            </summary>
            <remarks>
            <p>Property set will set value of multiple cells or of a merged range.</p>
            <p>Property get has meaning only if range is <see cref="P:GemBox.Spreadsheet.CellRange.Merged">Merged</see>; 
            otherwise, exception is thrown.</p>
            </remarks>
            <exception cref="T:System.InvalidOperationException">Thrown if property get is attempted on a cell range 
            which is not merged.</exception>
            <seealso cref="P:GemBox.Spreadsheet.CellRange.Merged"/>
        </member>
        <member name="P:GemBox.Spreadsheet.CellRange.Style">
            <summary>
            Gets or sets cell style (<see cref="T:GemBox.Spreadsheet.CellStyle">CellStyle</see>) on one or more excel cells.
            </summary>
            <remarks>
            <p>Property set will set style of multiple cells or of a merged range.</p>
            <p>Property get has meaning only if range is <see cref="P:GemBox.Spreadsheet.CellRange.Merged">Merged</see>; 
            otherwise, exception is thrown.</p>
            <p> Note that for <see cref="P:GemBox.Spreadsheet.CellRange.Style">Style</see> property set on a cell range that 
is not merged, you can't use the following format:
<code lang="vbnet">
	Dim cr As CellRange = excelFile.Worksheets(0).Rows(1).Cells
	cr.Style.Rotation = 30
</code>
<code lang="C#">
	CellRange cr = excelFile.Worksheets[0].Rows[1].Cells;
	cr.Style.Rotation = 30;
</code>
because that would first call <see cref="P:GemBox.Spreadsheet.CellRange.Style">Style</see> property get method and that 
will certainly fail because <see cref="P:GemBox.Spreadsheet.CellRange.Style">Style</see> property get is defined only 
for a merged cell range. </p><p>Instead you can use two different code patterns, depending on whether you want to replace or combine the existing 
cell range styles with the new style.</p><p>
If you want to <b>replace</b> cell style on every cell in a cell range use the following code:
<code lang="vbnet">
	Dim cr As CellRange = excelFile.Worksheets(0).Rows(1).Cells
	Dim style As CellStyle = New CellStyle()
	style.Rotation = 30
	cr.Style = style
</code>
<code lang="C#">
	CellRange cr = excelFile.Worksheets[0].Rows[1].Cells;
	CellStyle style = new CellStyle();
	style.Rotation = 30;
	cr.Style = style;
</code>
</p><p>
If you want to <b>set</b> cell style property on every cell in a cell range (other cell style property values will 
remain unchanged) use the following code:
<code lang="vbnet">
    Dim cell As ExcelCell
    For Each cell In excelFile.Worksheets(0).Rows(1).Cells
        cell.Style.Rotation = 30
    Next
</code>
<code lang="C#">
	foreach(ExcelCell cell in excelFile.Worksheets[0].Rows[1].Cells)
		cell.Style.Rotation = 30;
</code>
</p>
            </remarks>
            <exception cref="T:System.InvalidOperationException">Thrown if property get is attempted on a cell range 
            which is not merged.</exception>
            <seealso cref="P:GemBox.Spreadsheet.CellRange.Merged"/>
        </member>
        <member name="P:GemBox.Spreadsheet.CellRange.IsStyleDefault">
            <summary>
            Returns <b>true</b> if all cells in cell range or merged range have default 
            cell style; otherwise, <b>false</b>.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.CellRange.IndexingMode">
            <summary>
            Gets indexing mode used for cell range.
            </summary>
            <remarks>
            <p>If <see cref="P:GemBox.Spreadsheet.CellRange.Height">Height</see> is 1, indexing mode 
            is <see cref="F:GemBox.Spreadsheet.RangeIndexingMode.Horizontal">Horizontal</see>.</p>
            <p>Otherwise, if <see cref="P:GemBox.Spreadsheet.CellRange.Width">Width</see> is 1, indexing mode 
            is <see cref="F:GemBox.Spreadsheet.RangeIndexingMode.Vertical">Vertical</see>.</p>
            <p>Otherwise, indexing mode is <see cref="F:GemBox.Spreadsheet.RangeIndexingMode.Rectangular">
            Rectangular</see>.</p>
            </remarks>
            <example> Following code creates horizontal, vertical and rectangular cell ranges and demonstrates how 
indexing works different in different context. <see cref="M:GemBox.Spreadsheet.CellRange.SetBorders(GemBox.Spreadsheet.MultipleBorders,System.Drawing.Color,GemBox.Spreadsheet.LineStyle)">SetBorders</see> 
method is used to mark outside borders of the rectangular range.
<code lang="vbnet">
    Dim cr As CellRange = excelFile.Worksheets(0).Rows(1).Cells

    cr(0).Value = cr.IndexingMode
    cr(3).Value = "D2"
    cr("B").Value = "B2"

    cr = excelFile.Worksheets(0).Columns(4).Cells

    cr(0).Value = cr.IndexingMode
    cr(2).Value = "E3"
    cr("5").Value = "E5"

    cr = excelFile.Worksheets(0).Cells.GetSubrange("F2", "J8")
    cr.SetBorders(MultipleBorders.Outside, Color.Navy, LineStyle.Dashed)

    cr("I7").Value = cr.IndexingMode
    cr(0, 0).Value = "F2"
    cr("G3").Value = "G3"
    cr(5).Value = "F3" <font color="Green">' Cell range width is 5 (F G H I J).</font>
</code>
<code lang="C#">
	CellRange cr = excelFile.Worksheets[0].Rows[1].Cells;				

	cr[0].Value = cr.IndexingMode;
	cr[3].Value = "D2";
	cr["B"].Value = "B2";

	cr = excelFile.Worksheets[0].Columns[4].Cells;

	cr[0].Value = cr.IndexingMode;
	cr[2].Value = "E3";
	cr["5"].Value = "E5";

	cr = excelFile.Worksheets[0].Cells.GetSubrange("F2", "J8");
	cr.SetBorders(MultipleBorders.Outside, Color.Navy, LineStyle.Dashed);

	cr["I7"].Value = cr.IndexingMode;
	cr[0,0].Value = "F2";
	cr["G3"].Value = "G3";
	cr[5].Value = "F3"; <font color="Green">// Cell range width is 5 (F G H I J).</font>
</code>
</example>
        </member>
        <member name="T:GemBox.Spreadsheet.CellRangeEnumerator">
            <summary>
            Enumerator used for iterating cells in a <see cref="T:GemBox.Spreadsheet.CellRange">CellRange</see>.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.CellRangeEnumerator.Dispose">
            <exclude/>
        </member>
        <member name="M:GemBox.Spreadsheet.CellRangeEnumerator.Reset">
            <summary>
            Sets the enumerator to its initial position, which is one column before 
            the first cell in the cell range.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.CellRangeEnumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the cell range.
            </summary>
            <returns>
            <b>true</b> if the enumerator was successfully advanced to the next element; <b>false</b> if 
            the enumerator has passed the end of the cell range.
            </returns>
        </member>
        <member name="P:GemBox.Spreadsheet.CellRangeEnumerator.Parent">
            <summary>
            Parent <see cref="T:GemBox.Spreadsheet.CellRange">CellRange</see>. 
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.CellRangeEnumerator.CurrentRow">
            <summary>
            Current absolute row index in the cell range.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.CellRangeEnumerator.CurrentColumn">
            <summary>
            Current absolute column index in the cell range.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.CellRangeEnumerator.Current">
            <summary>
            Gets the current <see cref="T:GemBox.Spreadsheet.ExcelCell">ExcelCell</see> in the cell range.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.CellRangeEnumerator.CurrentCell">
            <summary>
            Gets the current <see cref="T:GemBox.Spreadsheet.ExcelCell">ExcelCell</see> in the cell range.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.CellRangeEnumerator.System#Collections#IEnumerator#Current">
            <summary>
            Gets the current <see cref="T:GemBox.Spreadsheet.ExcelCell">ExcelCell</see> in the cell range.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.MergedCellRange.Formula">
            <summary>
            Gets or sets merged range formula string.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.MergedCellRange.Comment">
            <summary>
            Gets or sets cell comment.
            </summary>
            <remarks>
            <p>
            You can set comment text, set whether comment will be visible during loading xls file or not.
            Additinally you can get column or row of the excel cell to which this comment is assigned.
            </p>
            </remarks>
            <example>
Following code demonstrates how to use comments. It shows next features: 
<list type="number">
<item> comment text setting </item>
<item> comment' IsVisible property in action </item>
</list>
<code lang="vbnet">		
	excelFile.Worksheets(0).Cells(0, 0).Comment.Text = "comment1" 
	excelFile.Worksheets(0).Cells(0, 0).Comment.IsVisible = False
</code>
<code lang="C#">
	excelFile.Worksheets[ 0 ].Cells[ 0, 0 ].Comment.Text = "comment1";
	excelFile.Worksheets[ 0 ].Cells[ 0, 0 ].Comment.IsVisible = false;
</code>
</example>
        </member>
        <member name="T:GemBox.Spreadsheet.FunctionFormulaToken">
            <summary>
            Formula token for holding function.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.FunctionFormulaToken.#ctor(GemBox.Spreadsheet.FormulaTokenCode)">
            <summary>
            Initializes a new instance of the <see cref="T:GemBox.Spreadsheet.FunctionFormulaToken"/> class.
            </summary>
            <param name="code">The code.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.FunctionFormulaToken.DelayInitialize(System.Object[])">
            <summary>
            Make custom delay initialize.
            </summary>
            <param name="data">The data for initialization which is unique for each formula token.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.FunctionFormulaToken.Read(System.Byte[],System.Int32)">
            <summary>
            Initialize formula token by reading input data from array of bytes
            </summary>
            <param name="rpnBytes">input data, array of bytes</param>
            <param name="startIndex">start position for array of bytes to read from</param>
        </member>
        <member name="M:GemBox.Spreadsheet.FunctionFormulaToken.ConvertToBytes">
            <summary>
            Convert formula token to array of byte representation.
            </summary>
            <returns>formula token' array of byte representation</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.FunctionFormulaToken.ToString">
            <summary>
            Convert formula token to string representation.
            </summary>
            <returns>formula token string representation</returns>
        </member>
        <member name="T:GemBox.Spreadsheet.DataValidationCollection">
            <summary>
            A collection of <see cref="T:GemBox.Spreadsheet.DataValidation"/> items.
            Supported in XLSX only.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.DataValidationCollection.InsertItem(System.Int32,GemBox.Spreadsheet.DataValidation)">
            <exclude/>
        </member>
        <member name="M:GemBox.Spreadsheet.DataValidationCollection.SetItem(System.Int32,GemBox.Spreadsheet.DataValidation)">
            <exclude/>
        </member>
        <member name="T:GemBox.Spreadsheet.DataValidation">
            <summary>
            A single item of data validation defined on a ranges of the worksheet.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.DataValidation.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:GemBox.Spreadsheet.DataValidation"/> class.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.DataValidation.#ctor(GemBox.Spreadsheet.ExcelWorksheet,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Initializes a new instance of the <see cref="T:GemBox.Spreadsheet.DataValidation"/> class with specified worksheet and cell references on which this data validation will be applied.
            </summary>
            <param name="worksheet">The worksheet that will be used to initialize <see cref="T:GemBox.Spreadsheet.CellRange"/>s that will be added to the <see cref="P:GemBox.Spreadsheet.DataValidation.CellRanges"/> collection of this data validation.</param>
            <param name="cellReferences">The cell references from which to create <see cref="T:GemBox.Spreadsheet.CellRange"/>s.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.DataValidation.#ctor(GemBox.Spreadsheet.ExcelWorksheet,System.String[])">
            <summary>
            Initializes a new instance of the <see cref="T:GemBox.Spreadsheet.DataValidation"/> class with specified worksheet and cell references on which this data validation will be applied.
            </summary>
            <param name="worksheet">The worksheet that will be used to initialize <see cref="T:GemBox.Spreadsheet.CellRange"/>s that will be added to the <see cref="P:GemBox.Spreadsheet.DataValidation.CellRanges"/> collection of this data validation.</param>
            <param name="cellReferences">The cell references from which to create <see cref="T:GemBox.Spreadsheet.CellRange"/>s.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.DataValidation.#ctor(System.Collections.Generic.IEnumerable{GemBox.Spreadsheet.CellRange})">
            <summary>
            Initializes a new instance of the <see cref="T:GemBox.Spreadsheet.DataValidation"/> class with specified cell ranges on which this data validation will be applied.
            </summary>
            <param name="cellRanges">The cell ranges on which this data validation will be applied.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.DataValidation.#ctor(GemBox.Spreadsheet.CellRange[])">
            <summary>
            Initializes a new instance of the <see cref="T:GemBox.Spreadsheet.DataValidation"/> class with specified cell ranges on which this data validation will be applied.
            </summary>
            <param name="cellRanges">The cell ranges on which this data validation will be applied.</param>
        </member>
        <member name="P:GemBox.Spreadsheet.DataValidation.Type">
            <summary>
            Gets or sets the type of data validation.
            </summary>
            <value>
            The type of data validation.
            </value>
        </member>
        <member name="P:GemBox.Spreadsheet.DataValidation.Operator">
            <summary>
            Gets or sets the relational operator used with this data validation.
            </summary>
            <value>
            The relational operator used with this data validation.
            </value>
        </member>
        <member name="P:GemBox.Spreadsheet.DataValidation.IgnoreBlank">
            <summary>
            Gets or sets a value indicating whether the data validation treats empty or blank entries as 
            valid. <c>true</c> means empty entries are OK and do not violate the validation constraints.
            </summary>
            <value>
            <c>true</c> if empty entries are OK and do not violate the validation constraints; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:GemBox.Spreadsheet.DataValidation.InCellDropdown">
            <summary>
            Gets or sets a value indicating whether to display the dropdown combo box for a <see cref="F:GemBox.Spreadsheet.DataValidationType.List"/> data validation type.
            </summary>
            <value>
            <c>true</c> to display the dropdown combo box for a <see cref="F:GemBox.Spreadsheet.DataValidationType.List"/> data validation type; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:GemBox.Spreadsheet.DataValidation.Formula1">
            <summary>
            Gets or sets the first formula in the DataValidation dropdown.
            </summary>
            <value>
            The first formula in the DataValidation dropdown.
            </value>
            <remarks>
            It used as a bounds for <see cref="F:GemBox.Spreadsheet.DataValidationOperator.Between"/> and <see cref="F:GemBox.Spreadsheet.DataValidationOperator.NotBetween"/> relational
            operators, and the only formula used for other relational operators (<see cref="F:GemBox.Spreadsheet.DataValidationOperator.Equal"/>, 
            <see cref="F:GemBox.Spreadsheet.DataValidationOperator.NotEqual"/>, <see cref="F:GemBox.Spreadsheet.DataValidationOperator.LessThan"/>, <see cref="F:GemBox.Spreadsheet.DataValidationOperator.LessThanOrEqual"/>,
            <see cref="F:GemBox.Spreadsheet.DataValidationOperator.GreaterThan"/>, <see cref="F:GemBox.Spreadsheet.DataValidationOperator.GreaterThanOrEqual"/>), 
            or for <see cref="F:GemBox.Spreadsheet.DataValidationType.Custom"/> or <see cref="F:GemBox.Spreadsheet.DataValidationType.List"/> data validation type.
            The content can be an instance of any type, but the following rules apply when formula is being written:
            <list type="table">
            <item><description>
            If data validation type is <see cref="F:GemBox.Spreadsheet.DataValidationType.WholeNumber"/> or <see cref="F:GemBox.Spreadsheet.DataValidationType.TextLength"/>, and content is integral data type
            (<see cref="T:System.SByte"/>, <see cref="T:System.Byte"/>, <see cref="T:System.Int16"/>, <see cref="T:System.UInt16"/>, <see cref="T:System.Int32"/>, 
            <see cref="T:System.UInt32"/>, <see cref="T:System.Int64"/>, <see cref="T:System.UInt64"/>), formula will be saved as integral constant, else if formula is an 
            Excel formula or an Excel reference (<see cref="T:System.String"/> that starts with '='), value will be saved as a formula, otherwise, it will be saved as string constant.
            </description></item>
            <item><description>
            If data validation type is <see cref="F:GemBox.Spreadsheet.DataValidationType.Decimal"/>, and content is floating-point data type (<see cref="T:System.Single"/>,
            <see cref="T:System.Double"/>, <see cref="T:System.Decimal"/>), formula will be saved as floating-point constant, else if formula is an 
            Excel formula or an Excel reference (<see cref="T:System.String"/> that starts with '='), value will be saved as a formula, otherwise, it will be saved as string constant.
            </description></item>
            <item><description>
            If data validation type is <see cref="F:GemBox.Spreadsheet.DataValidationType.Date"/>, and content is <see cref="T:System.DateTime"/> data type, formula will be saved as 
            date constant, else if formula is an Excel formula or an Excel reference (<see cref="T:System.String"/> that starts with '='), 
            value will be saved as a formula, otherwise, it will be saved as string constant.
            </description></item>
            <item><description>
            If data validation type is <see cref="F:GemBox.Spreadsheet.DataValidationType.Time"/>, and content is <see cref="T:System.TimeSpan"/> data type, formula will be saved as
            time constant, else if formula is an Excel formula or an Excel reference (<see cref="T:System.String"/> that starts with '='), 
            value will be saved as a formula, otherwise, it will be saved as string constant.
            </description></item>
            <item><description>
            If data validation type is <see cref="F:GemBox.Spreadsheet.DataValidationType.List"/>, and content is any type that implements <see cref="T:System.Collections.IEnumerable"/>, 
            formula will be saved as list series (comma seperated values), else if formula is an Excel formula or an Excel reference 
            (<see cref="T:System.String"/> that starts with '='), value will be saved as a formula, otherwise, it will be saved as string constant.
            </description></item>
            <item><description>
            If data validation type is <see cref="F:GemBox.Spreadsheet.DataValidationType.Custom"/>, and formula is an Excel formula or an Excel reference 
            (<see cref="T:System.String"/> that starts with '='), value will be saved as a formula, otherwise, it will be saved as string constant.
            </description></item>
            <item><description>
            If data validation type is <see cref="F:GemBox.Spreadsheet.DataValidationType.None"/>, formula won't be saved.
            </description></item>
            </list>
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.DataValidation.Formula2">
            <summary>
            Gets or sets the second formula in the DataValidation dropdown.
            </summary>
            <value>
            The second formula in the DataValidation dropdown.
            </value>
            <remarks>
            It used as a bounds for <see cref="F:GemBox.Spreadsheet.DataValidationOperator.Between"/> and <see cref="F:GemBox.Spreadsheet.DataValidationOperator.NotBetween"/> relational operators only.
            For the information about the content, see <see cref="P:GemBox.Spreadsheet.DataValidation.Formula1"/> remarks.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.DataValidation.ShowInputMessage">
            <summary>
            Gets or sets a value indicating whether to display the input prompt message.
            </summary>
            <value>
            <c>true</c> to display the input prompt message; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:GemBox.Spreadsheet.DataValidation.InputMessageTitle">
            <summary>
            Gets or sets the title bar text of input prompt.
            </summary>
            <value>
            The title bar text of input prompt.
            </value>
        </member>
        <member name="P:GemBox.Spreadsheet.DataValidation.InputMessage">
            <summary>
            Gets or sets the message text of input prompt.
            </summary>
            <value>
            The message text of input prompt.
            </value>
        </member>
        <member name="P:GemBox.Spreadsheet.DataValidation.ShowErrorAlert">
            <summary>
            Gets or sets a value indicating whether to display the error alert message when an invalid
            value has been entered, according to the criteria specified.
            </summary>
            <value>
            <c>true</c> to display the error alert message when an invalid
            value has been entered; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:GemBox.Spreadsheet.DataValidation.ErrorStyle">
            <summary>
            Gets or sets the style of error alert used for this data validation.
            </summary>
            <value>
            The style of error alert used for this data validation.
            </value>
        </member>
        <member name="P:GemBox.Spreadsheet.DataValidation.ErrorTitle">
            <summary>
            Gets or sets the title bar text of error alert.
            </summary>
            <value>
            The title bar text of error alert.
            </value>
        </member>
        <member name="P:GemBox.Spreadsheet.DataValidation.ErrorMessage">
            <summary>
            Gets or sets the message text of error alert.
            </summary>
            <value>
            The message text of error alert.
            </value>
        </member>
        <member name="P:GemBox.Spreadsheet.DataValidation.CellRanges">
            <summary>
            Gets the ranges over which data validation is applied.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.CellRangeCollection">
            <summary>
            A collection of <see cref="T:GemBox.Spreadsheet.CellRange"/> items.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.CellRangeCollection.Add(GemBox.Spreadsheet.ExcelWorksheet,System.String)">
            <summary>
            Adds the <see cref="T:GemBox.Spreadsheet.CellRange"/> from the specified worksheet to the collection.
            </summary>
            <param name="worksheet">The worksheet.</param>
            <param name="cellReference">The cell reference for which to create <see cref="T:GemBox.Spreadsheet.CellRange"/>.</param>
            <returns>An instance of the <see cref="T:GemBox.Spreadsheet.CellRange"/> that was added to the collection.</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.CellRangeCollection.InsertItem(System.Int32,GemBox.Spreadsheet.CellRange)">
            <exclude/>
        </member>
        <member name="M:GemBox.Spreadsheet.CellRangeCollection.SetItem(System.Int32,GemBox.Spreadsheet.CellRange)">
            <exclude/>
        </member>
        <member name="T:GemBox.Spreadsheet.DataValidationType">
            <summary>
            Specifies the type of data validation used to validate user input.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.DataValidationType.None">
            <summary>
            No data validation.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.DataValidationType.WholeNumber">
            <summary>
            Data validation which checks for whole number values satisfying the given condition.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.DataValidationType.Decimal">
            <summary>
            Data validation which checks for decimal values satisfying the given condition.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.DataValidationType.List">
            <summary>
            Data validation which checks for a value matching one of list of values.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.DataValidationType.Date">
            <summary>
            Data validation which checks for date values satisfying the given condition.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.DataValidationType.Time">
            <summary>
            Data validation which checks for time values satisfying the given condition.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.DataValidationType.TextLength">
            <summary>
            Data validation which checks for text values, whose length satisfies the given condition.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.DataValidationType.Custom">
            <summary>
            Data validation which uses a custom formula to check the cell value.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.DataValidationOperator">
            <summary>
            The relational operator used in data validation.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.DataValidationOperator.Between">
            <summary>
            Data validation which checks if a value is between two other values.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.DataValidationOperator.NotBetween">
            <summary>
            Data validation which checks if a value is not between two other values.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.DataValidationOperator.Equal">
            <summary>
            Data validation which checks if a value is equal to a specified value.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.DataValidationOperator.NotEqual">
            <summary>
            Data validation which checks if a value is not equal to a specified value.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.DataValidationOperator.LessThan">
            <summary>
            Data validation which checks if a value is less than a specified value.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.DataValidationOperator.LessThanOrEqual">
            <summary>
            Data validation which checks if a value is less than or equal to a specified value.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.DataValidationOperator.GreaterThan">
            <summary>
            Data validation which checks if a value is greater than a specified value.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.DataValidationOperator.GreaterThanOrEqual">
            <summary>
            Data validation which checks if a value is greater than or equal to a specified value.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.DataValidationErrorStyle">
            <summary>
            The style of data validation error alert.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.DataValidationErrorStyle.Stop">
            <summary>
            This data validation error style uses a stop icon in the error alert.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.DataValidationErrorStyle.Warning">
            <summary>
            This data validation error style uses a warning icon in the error alert.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.DataValidationErrorStyle.Information">
            <summary>
            This data validation error style uses an information icon in the error alert.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.MsofbtBseRecord.Read(System.IO.BinaryReader)">
            <summary>
            Reads data from the specified reader.
            </summary>
            <param name="reader">The source binary reader.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.MsofbtBseRecord.SetData(GemBox.Spreadsheet.MsoDelayedRecords)">
            <summary>
            Sets the inner data( mso structure' data without header: atom, type, length ).
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.UnaryOperatorFormulaToken">
            <summary>
            Formula token for holding unary operator.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.UnaryOperatorFormulaToken.#cctor">
            <summary>
            Initializes the <see cref="T:GemBox.Spreadsheet.UnaryOperatorFormulaToken"/> class.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.UnaryOperatorFormulaToken.#ctor(GemBox.Spreadsheet.FormulaTokenCode)">
            <summary>
            Initializes a new instance of the <see cref="T:GemBox.Spreadsheet.UnaryOperatorFormulaToken"/> class.
            </summary>
            <param name="code">The code.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.UnaryOperatorFormulaToken.ToString">
            <summary>
            Convert formula token to string representation.
            </summary>
            <returns>formula token string representation</returns>
        </member>
        <member name="T:GemBox.Spreadsheet.StrFormulaToken">
            <summary>
            Formula token for holding string.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.StrFormulaToken.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:GemBox.Spreadsheet.StrFormulaToken"/> class.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.StrFormulaToken.DelayInitialize(System.Object[])">
            <summary>
            Make custom delay initialize.
            </summary>
            <param name="data">The data for initialization which is unique for each formula token.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.StrFormulaToken.Read(System.Byte[],System.Int32)">
            <summary>
            Initialize formula token by reading input data from array of bytes
            </summary>
            <param name="rpnBytes">input data, array of bytes</param>
            <param name="startIndex">start position for array of bytes to read from</param>
        </member>
        <member name="M:GemBox.Spreadsheet.StrFormulaToken.ConvertToBytes">
            <summary>
            Convert formula token to array of byte representation.
            </summary>
            <returns>formula token' array of byte representation</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.StrFormulaToken.ToString">
            <summary>
            Convert formula token to string representation.
            </summary>
            <returns>formula token string representation</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.FormulaTokensFactory.CreateFrom(GemBox.Spreadsheet.ExcelWorksheet,System.Byte[],System.Int32)">
            <summary>
            Creates formula token from rpn bytes and the code read from that bytes.
            </summary>
            <param name="sheet"></param>
            <param name="rpnBytes">The RPN bytes.</param>
            <param name="startIndex">The start index to read code from the RPN bytes.</param>
            <returns>created formula token</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.FormulaTokensFactory.CreateFunctionFromName(System.String,GemBox.Spreadsheet.FormulaTokenClass,System.Byte)">
            <summary>
            Creates formula token form the name of the function.
            </summary>
            <param name="name">The name of the function.</param>
            <param name="tokenClass">The token class.</param>
            <param name="argumentsCount">The arguments count for the function.</param>
            <returns>created formula token</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.FormulaTokensFactory.CreateFromCode(GemBox.Spreadsheet.ExcelWorksheet,GemBox.Spreadsheet.FormulaTokenCode)">
            <summary>
            Creates formula token from code.
            </summary>
            <param name="sheet"></param>
            <param name="tokenCode">The token code.</param>
            <returns>created formula token</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.FormulaTokensFactory.CreateFromCode(GemBox.Spreadsheet.ExcelWorksheet,System.Byte)">
            <summary>
            Creates formula token from byte code.
            </summary>
            <param name="sheet"></param>
            <param name="code">The byte code.</param>
            <returns>created formula token</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.FormulaTokensFactory.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:GemBox.Spreadsheet.FormulaTokensFactory"/> class.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.FormulaParser.boolList">
            <summary>
            List of allowed values for boolean primitive type
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.FormulaParser.#ctor(GemBox.Spreadsheet.ExcelWorksheet)">
            <summary>
            Initializes a new instance of the <see cref="T:GemBox.Spreadsheet.FormulaParser"/> class.
            </summary>
            <param name="sheet">The excel worksheet.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.FormulaParser.Parse(System.String)">
            <summary>
            Parses the specified string formula.
            </summary>
            <param name="formula">The string formula.</param>
            <returns>formula token array</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.FormulaParser.AddToken(GemBox.Spreadsheet.FormulaToken)">
            <summary>
            Adds the token to the result list.
            </summary>
            <param name="token">The token to be added.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.FormulaParser.AddToken(GemBox.Spreadsheet.FormulaTokenCode)">
            <summary>
            Adds the token to the result list.
            </summary>
            <param name="code">The code of the token to be added.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.FormulaParser.AddToken(GemBox.Spreadsheet.FormulaTokenCode,System.Object)">
            <summary>
            Adds the token to the result list.
            </summary>
            <param name="code">The code of the token to be added.</param>
            <param name="data">The data to be used as the input for formula token delay initialization.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.FormulaParser.AddToken(GemBox.Spreadsheet.FormulaTokenCode,System.Object[])">
            <summary>
            Adds the token to the result list.
            </summary>
            <param name="code">The code of the token to be added.</param>
            <param name="data">The array of data to be used as the input for formula token delay initialization.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.CellFormula.Recalculate">
            <summary>
            Recalculate formula based on saved tokens.
            It need to be done for changing some data which can be changed after setting formula
            and before saving xls file.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.CellFormula.UpdateValueFromExtraRecords">
            <summary>
            Updates the <see cref="P:GemBox.Spreadsheet.CellFormula.Value"/> property based on <c>STRING</c> structure
            in <see cref="F:GemBox.Spreadsheet.CellFormula.ExtraFormulaRecords"/>.
            </summary>
            <remarks>
            If there is no <c>STRING</c> structure in extra records then the value
            remains unchanged.
            </remarks>
        </member>
        <member name="T:GemBox.Spreadsheet.ExcelCell">
            <summary>
            Excel cell provides access to a single worksheet cell or to a merged range if the cell is merged.
            </summary>
            <remarks>
            <p>Merged range is created by using <see cref="P:GemBox.Spreadsheet.CellRange.Merged">CellRange.Merged</see> property. 
            See the property documentation for more information on merging.</p>
            </remarks>
            <seealso cref="P:GemBox.Spreadsheet.CellRange.Merged">CellRange.Merged</seealso>
            <seealso cref="P:GemBox.Spreadsheet.ExcelCell.MergedRange"/>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelCell.SetBorders(GemBox.Spreadsheet.MultipleBorders,System.Drawing.Color,GemBox.Spreadsheet.LineStyle)">
            <summary>
            Sets borders on this cell or on merged range if this cell is merged.
            </summary>
            <param name="multipleBorders">Borders to set.</param>
            <param name="lineColor">Line color.</param>
            <param name="lineStyle">Line style.</param>
            <seealso cref="P:GemBox.Spreadsheet.CellRange.Merged">CellRange.Merged</seealso>
            <seealso cref="P:GemBox.Spreadsheet.ExcelCell.MergedRange"/>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelCell.ConvertExcelNumberToDateTime(System.Double,System.Boolean)">
            <summary>
            Converts Excel floating-point number to <see cref="T:System.DateTime">DateTime</see> structure.
            </summary>
            <remarks>
            <p>
            Excel file format doesn't have a separate data type for date and time. 
            <see cref="T:System.DateTime">DateTime</see> value is
            stored as IEEE number encoded in a special way. When reading Excel file, 
            <see cref="P:GemBox.Spreadsheet.CellStyle.NumberFormat">CellStyle.NumberFormat</see> is examined and if it matches 
            some of date/time number formats cell value is interpreted as <see cref="T:System.DateTime">DateTime</see>.</p>
            <p>However, if some non-standard date/time number format is used, cell value will not be recognized 
            as <see cref="T:System.DateTime">DateTime</see> but as ordinary number. In such cases (when you know that
            specific cell holds <see cref="T:System.DateTime">DateTime</see> value but you get a number when reading
            Excel file) use this method to convert IEEE number to <see cref="T:System.DateTime">DateTime</see> 
            structure.</p>
            </remarks>
            <param name="num">Excel floating-point number.</param>
            <param name="use1904DateSystem">True to use 1904 date system.</param>
            <returns>Converted DateTime structure.</returns>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelCell.Value">
            <summary>
            Gets or sets value of this cell or of merged range if this cell is merged.
            </summary>
            <remarks>
            <p>Exception is thrown if value for the set is not of supported type (See 
            <see cref="M:GemBox.Spreadsheet.ExcelFile.SupportsType(System.Type)">ExcelFile.SupportsType</see> for details).</p>
            <p>Note that the fact some type is supported doesn't mean it is written to Excel file in the native format. As
            Microsoft Excel has just few basic types, the object of supported type will be converted to a similar excel type. 
            If similar excel type doesn't exist, value is written as a string value.</p>
            <p>If the value of this property is of <see cref="T:System.DateTime">DateTime</see> type and 
            <see cref="P:GemBox.Spreadsheet.ExcelCell.Style">Style</see> number format is not set, ISO date/time 
            format will be used as <see cref="P:GemBox.Spreadsheet.CellStyle.NumberFormat">CellStyle.NumberFormat</see> 
            value.</p>
            </remarks>
            <exception cref="T:System.NotSupportedException">Thrown for unsupported types.</exception>
            <seealso cref="P:GemBox.Spreadsheet.CellRange.Merged">CellRange.Merged</seealso>
            <seealso cref="P:GemBox.Spreadsheet.ExcelCell.MergedRange"/>
            <seealso cref="M:GemBox.Spreadsheet.ExcelFile.SupportsType(System.Type)">ExcelFile.SupportsType</seealso>
            <seealso cref="P:GemBox.Spreadsheet.CellStyle.NumberFormat">CellStyle.NumberFormat</seealso>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelCell.Style">
            <summary>
            Gets or sets cell style (<see cref="T:GemBox.Spreadsheet.CellStyle">CellStyle</see>) of this cell or 
            of merged range if this cell is merged.
            </summary>
            <remarks>
            Unset style properties will be inherited from corresponding row or column. See
            <see cref="P:GemBox.Spreadsheet.ExcelFile.RowColumnResolutionMethod">ExcelFile.RowColumnResolutionMethod</see>
            for more details.
            </remarks>
            <seealso cref="P:GemBox.Spreadsheet.CellRange.Merged">CellRange.Merged</seealso>
            <seealso cref="P:GemBox.Spreadsheet.ExcelCell.MergedRange"/>
            <seealso cref="P:GemBox.Spreadsheet.ExcelFile.RowColumnResolutionMethod">ExcelFile.RowColumnResolutionMethod</seealso>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelCell.IsStyleDefault">
            <summary>
            Returns <b>true</b> if style is default; otherwise, <b>false</b>.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelCell.MergedRange">
            <summary>
            Returns associated merged range if the cell is merged; otherwise, <b>null</b>.
            </summary>
            <seealso cref="P:GemBox.Spreadsheet.CellRange.Merged">CellRange.Merged</seealso>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelCell.Formula">
            <summary>
            Gets or sets cell formula string.
            </summary>
            <remarks>
            <p>GemBox.Spreadsheet can read and write formulas, but cannot calculate formula results. However, when you 
            open a file in MS Excel, formula results will be calculated automatically.</p>
            <p>Old XLS format requires all formulas to be parsed and saved to XLS files as special
            tokens in RPN (Reverse Polish notation). GemBox.Spreadsheet only knows how to parse limited
            set of formulas listed below.</p>
            <p>New XLSX (Open XML) format stores formulas as strings and leaves formula parsing to applications
            that read XLSX documents. Therefore, ALL formulas are supported when writing/reading XLSX files.</p>
            <p>Depending on <see cref="P:GemBox.Spreadsheet.ExcelFile.DelayFormulaParse">
            ExcelFile.DelayFormulaParse</see> property, formula string can be parsed when this property is set
            or when one of <see cref="M:GemBox.Spreadsheet.ExcelFile.SaveXls(System.String)">
            ExcelFile.SaveXls</see> methods is called.</p>
            <p>GemBox.Spreadsheet formula parser will use English culture to parse numbers.</p>
            <p>Currently supported formula features by GemBox.Spreadsheet XLS formula parser are:
            <list type="bullet">
            <item><description>Named cell</description></item>
            <item><description>Named range</description></item>
            <item><description>Absolute cell/range</description></item>
            <item><description>Relative cell/range</description></item>
            <item><description>Functions( partly, see the list of supported functions below )</description></item>
            <item><description>Missed argument</description></item>
            <item><description>Unary operator</description></item>
            <item><description>Binary operator</description></item>
            <item><description>Parentheses</description></item>
            <item><description>3d cell reference</description></item>
            <item><description>3d cell range reference</description></item>
            <item><description>Boolean</description></item>
            <item><description>Integer</description></item>
            <item><description>Float</description></item>
            <item><description>String</description></item>
            <item><description>Error</description></item>
            </list>
            </p>
            <p>
            Currently unsupported formula features are:
            <list type="bullet">
            <item><description>Const array</description></item>
            <item><description>Array formula</description></item>
            <item><description>R1C1 reference</description></item>
            </list>
            </p>
            <p>
            Currently supported functions are: ABS, ACOS, ACOSH, ADDRESS, AND, ARCTAN, AREAS, ASC, ASIN, ASINH, ATAN2, ATANH, AVEDEV, AVERAGE, AVERAGE, BETADIST, BETAINV, BINOMDIST, CEILING, CELL, CHAR, CHIDST, CHIINV, CHOOSE, CLEAN, CODE, COLUMN, COLUMNS, COMBIN, CONCATENATE, CONFIDENCE, COS, COSH, COUNT, COUNTA, COUNTBLANK, COUNTIF, CRITBINOM, DATE, DATEDIF, DATESTRING, DATEVALUE, DAVERAGE, DAY, DAYS360, DB, DBSC, DCOUNT, DCOUNTA, DDB, DEGREES, DEVSQ, DGET, DMAX, DMIN, DOLLAR, DPRODUCT, DSTDEV, DSTDEVP, DSUM, DVAR, DVARP, EVEN, EXACT, EXP, EXPONDIST, FACT, FDIST, FIND, FINDB, FINV, FISHER, FISHERINV, FIXED, FLOOR, FV, GAMMADIST, GAMMAINV, GAMMALN, GEOMEAN, GROWTH, HARMEAN, HLOOKUP, HOUR, HYPERLINK, HYPGEOMVERT, IF, INDEX, INDIRECT, INFO, INT, IPMT, IRR, ISBLANK, ISERR, ISERROR, ISLOGICAL, ISNA, ISNONTEXT, ISNUMBER, ISPMT, ISREF, ISTEXT, KURT, LARGE, LEFT, LEFTB, LEN, LENB, LINEST, LN, LOG, LOG10, LOGEST, LOGINV, LOOKUP, LOWER, MATCH, MAX, MAXA, MDETERM, MEDIAN, MID, MIDB, MIN, MINA, MINUTE, MINVERSE, MIRR, MNORMSINV, MOD, MODE, MONTH, N, NA, EGBINOMDIST, NORMDIST, NORMINV, NORMSDIST, NORMSDIST, NOT, NOW, NPER, NPV, NUMBERSTRING, ODD, OFFSET, OR, PERCENTILE, PERCENTRANK, PERMUT, PHONETIC, PI, PMT, POISSON, POWER, PPMT, PRODUCT, PROPER, PV, QUARTILE, RADIANS, RAND, RANK, RATE, REPLACE, REPLACEB, REPT, RIGHT, RIGHTB, ROMAN, ROUND, ROUNDDOWN, ROUNDUP, ROW, ROWS, SEARCH, SEARCHB, SECOND, SIGN, SIN, SINH, SKEW, SLN, SMALL, SQRT, STANDARDIZE, STDEV, STDEVA, STDEVP, STDEVPA, SUBSTITUTE, SUBTOTAL, SUM, SUMIF, SUMSQ, SYD, T, TAN, TANH, TDIST, TEXT, TIME, TIMEVALUE, TINV, TODAY, TRANSPOSE, TREND, TRIM, TRIMMEAN, TRUNC, TYPE, UPPER, USDOLLAR, VALUE, VAR, VARA, VARP, VARPA, VDB, VLOOKUP, WEEKDAY, WEIBULL, YEAR, ZTEST, FALSE, TRUE.
            </p>
            <p>
            For more information on formulas, consult Microsoft Excel documentation.
            </p>
            </remarks>
            <example>Following code demonstrates how to use formulas and named ranges. It shows next features: 
cell references (both absolute and relative), unary and binary operators, constand operands (integer and floating point),
functions and named cell ranges.
<code lang="vbnet">
    ws.Cells("A1").Value = 5
    ws.Cells("A2").Value = 6
    ws.Cells("A3").Value = 10
 
    ws.Cells("C1").Formula = "=A1+A2"
    ws.Cells("C2").Formula = "=$A$1-A3"
    ws.Cells("C3").Formula = "=COUNT(A1:A3)"
    ws.Cells("C4").Formula = "=AVERAGE($A$1:$A$3)"
    ws.Cells("C5").Formula = "=SUM(A1:A3,2,3)"
    ws.Cells("C7").Formula = "= 123 - (-(-(23.5)))"
 
    ws.NamedRanges.Add("DataRange", ws.Cells.GetSubrange("A1", "A3"))
    ws.Cells("C8").Formula = "=MAX(DataRange)"
 
    Dim cr As CellRange = ws.Cells.GetSubrange("B9","C10")
    cr.Merged = True
    cr.Formula = "=A1*25"
</code>
<code lang="C#">	
	ws.Cells["A1"].Value = 5;
	ws.Cells["A2"].Value = 6;
	ws.Cells["A3"].Value = 10;

	ws.Cells["C1"].Formula = "=A1+A2";
	ws.Cells["C2"].Formula = "=$A$1-A3";
	ws.Cells["C3"].Formula = "=COUNT(A1:A3)";
	ws.Cells["C4"].Formula = "=AVERAGE($A$1:$A$3)";
	ws.Cells["C5"].Formula = "=SUM(A1:A3,2,3)";
	ws.Cells["C7"].Formula = "= 123 - (-(-(23.5)))";

	ws.NamedRanges.Add("DataRange", ws.Cells.GetSubrange("A1", "A3"));
	ws.Cells["C8"].Formula = "=MAX(DataRange)";

	CellRange cr = ws.Cells.GetSubrange("B9", "C10");
	cr.Merged = true;
	cr.Formula = "=A1*25";
</code>
</example>
            <seealso cref="M:GemBox.Spreadsheet.NamedRangeCollection.Add(System.String,GemBox.Spreadsheet.CellRange)">
            NamedRangeCollection.Add</seealso>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelCell.Comment">
            <summary>
            Gets or sets cell comment.
            </summary>
            <remarks>
            <p>
            You can set comment text, set whether comment will be visible during loading xls file or not.
            Additinally you can get column or row of the excel cell to which this comment is assigned.
            </p>
            <p>
            Supported only in xlsx.
            </p>
            </remarks>
            <example>
Following code demonstrates how to use comments. It shows next features: 
<list type="number">
<item> comment text setting </item>
<item> comment' IsVisible property in action </item>
</list>
<code lang="vbnet">		
	excelFile.Worksheets(0).Cells(0, 0).Comment.Text = "comment1" 
	excelFile.Worksheets(0).Cells(0, 0).Comment.IsVisible = False
</code>
<code lang="C#">
	excelFile.Worksheets[ 0 ].Cells[ 0, 0 ].Comment.Text = "comment1";
	excelFile.Worksheets[ 0 ].Cells[ 0, 0 ].Comment.IsVisible = false;
</code>
</example>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelCell.HasComment">
            <summary>
            If cell has comment returns true, else returns false.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelCell.Hyperlink">
            <summary>
            Gets or sets cell hyperlink.
            </summary>
            <remarks>
            <p>Supported only in xlsx. If you want hyperlinks also to work in XLS, assign HYPERLINK formula to
            <see cref="P:GemBox.Spreadsheet.ExcelCell.Formula">ExcelCell.Formula</see>.</p>
            <p>You can set cell style to underline and font color to blue in order to appear as hyperlink, that 
            is not done automatically.</p>
            </remarks> 
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelCell.HasHyperlink">
            <summary>
            If cell has hyperlink returns true, else returns false.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.ExcelCellCollection">
            <summary>
            Collection of excel cells (<see cref="T:GemBox.Spreadsheet.ExcelCell">ExcelCell</see>).
            </summary>
            <seealso cref="T:GemBox.Spreadsheet.ExcelCell"/>
        </member>
        <member name="T:GemBox.Spreadsheet.ExcelRowColumnCellCollectionBase">
            <summary>
            Base class for row, column and cell collections.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelRowColumnCellCollectionBase.GetEnumerator">
            <summary>
            Returns an enumerator for the <see cref="T:GemBox.Spreadsheet.ExcelRowColumnCellCollectionBase">
            ExcelRowColumnCellCollectionBase</see>.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelRowColumnCellCollectionBase.ItemsCore">
            <exclude/>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelRowColumnCellCollectionBase.Count">
            <summary>
            Gets the number of currently allocated elements (dynamically changes when worksheet is modified -- read remarks).
            </summary>
            <remarks>
            The cells are internally allocated in rows and not in columns. In other words, when you load CSV/XLS/XLSX or 
            access some cells via worksheet.Cells property new rows and cells can be allocated but the column count 
            will stay the same. To find last used column in the worksheet, use 
            <see cref="M:GemBox.Spreadsheet.ExcelWorksheet.GetUsedCellRange">ExcelWorksheet.GetUsedCellRange</see> method.
            </remarks>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelCellCollection.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator{T}">IEnumerator&lt;ExcelCell&gt;</see> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelCellCollection.ItemsCore">
            <exclude/>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelCellCollection.Item(System.Int32)">
            <summary>
            Gets the cell with the specified index.
            </summary>
            <param name="index">The zero-based index of the cell.</param>
        </member>
        <member name="T:GemBox.Spreadsheet.ExcelColumnRowBase">
            <summary>
            Base class for the excel column and row classes.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelColumnRowBase.#ctor(GemBox.Spreadsheet.ExcelRowColumnCollectionBase,System.Int32)">
            <summary>
            Internal.
            </summary>
            <param name="parent"></param>
            <param name="index"></param>
            <exclude/>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelColumnRowBase.#ctor(GemBox.Spreadsheet.ExcelRowColumnCollectionBase,GemBox.Spreadsheet.ExcelColumnRowBase)">
            <summary>
            Internal. Copy constructor.
            </summary>
            <param name="parent"></param>
            <param name="source"></param>
            <exclude/>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelColumnRowBase.Index">
            <summary>
            Gets the index.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelColumnRowBase.Style">
            <summary>
            Gets or sets cell style (<see cref="T:GemBox.Spreadsheet.CellStyle">CellStyle</see>) for contained cells.
            </summary>
            <remarks>
            Setting this property will not directly change <see cref="P:GemBox.Spreadsheet.ExcelCell.Style">ExcelCell.Style</see>. 
            Instead, this style will be used in resolving process when writing Excel file. See 
            <see cref="P:GemBox.Spreadsheet.ExcelFile.RowColumnResolutionMethod">ExcelFile.RowColumnResolutionMethod</see>
            for details.
            </remarks>
            <seealso cref="P:GemBox.Spreadsheet.ExcelFile.RowColumnResolutionMethod">ExcelFile.RowColumnResolutionMethod</seealso>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelColumnRowBase.IsStyleDefault">
            <summary>
            Returns <b>true</b> if style is default; otherwise, <b>false</b>.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelColumnRowBase.Collapsed">
            <summary>
            Gets or sets whether object is collapsed in outlining.
            </summary>
            <remarks>
            <p>When you use outline grouping and you want outline group to be collapsed, you need to set three properties:</p>
            <p><see cref="P:GemBox.Spreadsheet.ExcelColumnRowBase.OutlineLevel">OutlineLevel</see> property needs to be set to correct outline level.</p>
            <p>If group is collapsed, for all rows in the collapsed group <see cref="P:GemBox.Spreadsheet.ExcelColumnRowBase.Hidden">Hidden</see> property 
            needs to be set to <b>true</b>.</p>
            <p>If group is collapsed, for the row where collapsed (plus) sign is located 
            <see cref="P:GemBox.Spreadsheet.ExcelColumnRowBase.Collapsed">Collapsed</see> property needs to be set to <b>true</b>.</p>
            </remarks>
            <example> Following code creates two horizontal groups and one vertical group. Horizontal groups have 
outline button above (default is below), while vertical group is collapsed.
<code lang="vbnet">
    Sub GroupingSample(ByVal ws As ExcelWorksheet)
        ws.Cells(0, 0).Value = "Grouping and outline example:"

        <font color="Green">' Vertical grouping.</font>
        ws.Cells(2, 0).Value = "GroupA Start"
        ws.Rows(2).OutlineLevel = 1
        ws.Cells(3, 0).Value = "A"
        ws.Rows(3).OutlineLevel = 1
        ws.Cells(4, 1).Value = "GroupB Start"
        ws.Rows(4).OutlineLevel = 2
        ws.Cells(5, 1).Value = "B"
        ws.Rows(5).OutlineLevel = 2
        ws.Cells(6, 1).Value = "GroupB End"
        ws.Rows(6).OutlineLevel = 2
        ws.Cells(7, 0).Value = "GroupA End"
        ws.Rows(7).OutlineLevel = 1
        <font color="Green">' Put outline row buttons above groups.</font>
        ws.ViewOptions.OutlineRowButtonsBelow = False

        <font color="Green">' Horizontal grouping (collapsed).</font>
        ws.Cells("E2").Value = "Gr.C Start"
        ws.Columns("E").OutlineLevel = 1
        ws.Columns("E").Hidden = True
        ws.Cells("F2").Value = "C"
        ws.Columns("F").OutlineLevel = 1
        ws.Columns("F").Hidden = True
        ws.Cells("G2").Value = "Gr.C End"
        ws.Columns("G").OutlineLevel = 1
        ws.Columns("G").Hidden = True
        ws.Columns("H").Collapsed = True
    End Sub
</code>
<code lang="C#">
	static void GroupingSample(ExcelWorksheet ws)
	{
		  ws.Cells[0,0].Value = "Grouping and outline example:";

		  //Vertical grouping.
      ws.Cells[2, 0].Value = "GroupA Start";
      ws.Rows[2].OutlineLevel = 1;
      ws.Cells[3, 0].Value = "A";
      ws.Rows[3].OutlineLevel = 1;
      ws.Cells[4, 1].Value = "GroupB Start";
      ws.Rows[4].OutlineLevel = 2;
      ws.Cells[5, 1].Value = "B";
      ws.Rows[5].OutlineLevel = 2;
      ws.Cells[6, 1].Value = "GroupB End";
      ws.Rows[6].OutlineLevel = 2;
      ws.Cells[7, 0].Value = "GroupA End";
      ws.Rows[7].OutlineLevel = 1;
      // Put outline row buttons above groups.
      ws.ViewOptions.OutlineRowButtonsBelow = false;

      //Horizontal grouping (collapsed).
      ws.Cells["E2"].Value = "Gr.C Start";
      ws.Columns["E"].OutlineLevel = 1;
      ws.Columns["E"].Hidden = true;
      ws.Cells["F2"].Value = "C";
      ws.Columns["F"].OutlineLevel = 1;
      ws.Columns["F"].Hidden = true;
      ws.Cells["G2"].Value = "Gr.C End";
      ws.Columns["G"].OutlineLevel = 1;
      ws.Columns["G"].Hidden = true;
      ws.Columns["H"].Collapsed = true;
  }
</code>
</example>
            <seealso cref="P:GemBox.Spreadsheet.ExcelColumnRowBase.OutlineLevel"/>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelColumnRowBase.OutlineLevel">
            <summary>
            Gets or sets outline level.
            </summary>
            <remarks>
            <p>Exception is thrown if value is out of 0 to 7 range.</p>
            <p>Using this property you can create hierarchical groups. Range of consecutive objects (rows or columns) 
            with the same value of outline level belongs to the same group. Default value is zero, which prevents grouping.</p>
            <p>When you use outline grouping and you want outline group to be collapsed, you need to set three properties:</p>
            <p><see cref="P:GemBox.Spreadsheet.ExcelColumnRowBase.OutlineLevel">OutlineLevel</see> property needs to be set to correct outline level.</p>
            <p>If group is collapsed, for all rows in the collapsed group <see cref="P:GemBox.Spreadsheet.ExcelColumnRowBase.Hidden">Hidden</see> property 
            needs to be set to <b>true</b>.</p>
            <p>If group is collapsed, for the row where collapsed (plus) sign is located 
            <see cref="P:GemBox.Spreadsheet.ExcelColumnRowBase.Collapsed">Collapsed</see> property needs to be set to <b>true</b>.</p>
            </remarks>
            <example> Following code creates two horizontal groups and one vertical group. Horizontal groups have 
outline button above (default is below), while vertical group is collapsed.
<code lang="vbnet">
    Sub GroupingSample(ByVal ws As ExcelWorksheet)
        ws.Cells(0, 0).Value = "Grouping and outline example:"

        <font color="Green">' Vertical grouping.</font>
        ws.Cells(2, 0).Value = "GroupA Start"
        ws.Rows(2).OutlineLevel = 1
        ws.Cells(3, 0).Value = "A"
        ws.Rows(3).OutlineLevel = 1
        ws.Cells(4, 1).Value = "GroupB Start"
        ws.Rows(4).OutlineLevel = 2
        ws.Cells(5, 1).Value = "B"
        ws.Rows(5).OutlineLevel = 2
        ws.Cells(6, 1).Value = "GroupB End"
        ws.Rows(6).OutlineLevel = 2
        ws.Cells(7, 0).Value = "GroupA End"
        ws.Rows(7).OutlineLevel = 1
        <font color="Green">' Put outline row buttons above groups.</font>
        ws.ViewOptions.OutlineRowButtonsBelow = False

        <font color="Green">' Horizontal grouping (collapsed).</font>
        ws.Cells("E2").Value = "Gr.C Start"
        ws.Columns("E").OutlineLevel = 1
        ws.Columns("E").Hidden = True
        ws.Cells("F2").Value = "C"
        ws.Columns("F").OutlineLevel = 1
        ws.Columns("F").Hidden = True
        ws.Cells("G2").Value = "Gr.C End"
        ws.Columns("G").OutlineLevel = 1
        ws.Columns("G").Hidden = True
        ws.Columns("H").Collapsed = True
    End Sub
</code>
<code lang="C#">
	static void GroupingSample(ExcelWorksheet ws)
	{
		  ws.Cells[0,0].Value = "Grouping and outline example:";

		  //Vertical grouping.
      ws.Cells[2, 0].Value = "GroupA Start";
      ws.Rows[2].OutlineLevel = 1;
      ws.Cells[3, 0].Value = "A";
      ws.Rows[3].OutlineLevel = 1;
      ws.Cells[4, 1].Value = "GroupB Start";
      ws.Rows[4].OutlineLevel = 2;
      ws.Cells[5, 1].Value = "B";
      ws.Rows[5].OutlineLevel = 2;
      ws.Cells[6, 1].Value = "GroupB End";
      ws.Rows[6].OutlineLevel = 2;
      ws.Cells[7, 0].Value = "GroupA End";
      ws.Rows[7].OutlineLevel = 1;
      // Put outline row buttons above groups.
      ws.ViewOptions.OutlineRowButtonsBelow = false;

      //Horizontal grouping (collapsed).
      ws.Cells["E2"].Value = "Gr.C Start";
      ws.Columns["E"].OutlineLevel = 1;
      ws.Columns["E"].Hidden = true;
      ws.Cells["F2"].Value = "C";
      ws.Columns["F"].OutlineLevel = 1;
      ws.Columns["F"].Hidden = true;
      ws.Cells["G2"].Value = "Gr.C End";
      ws.Columns["G"].OutlineLevel = 1;
      ws.Columns["G"].Hidden = true;
      ws.Columns["H"].Collapsed = true;
  }
</code>
</example>
            <seealso cref="P:GemBox.Spreadsheet.ExcelColumnRowBase.Collapsed"/>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if value is out of 0 to 7 range.</exception>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelColumnRowBase.Hidden">
            <summary>
            Gets or sets whether excel object is hidden.
            </summary>
            <remarks>
            <p>When you use outline grouping and you want outline group to be collapsed, you need to set three properties:</p>
            <p><see cref="P:GemBox.Spreadsheet.ExcelColumnRowBase.OutlineLevel">OutlineLevel</see> property needs to be set to correct outline level.</p>
            <p>If group is collapsed, for all rows in the collapsed group <see cref="P:GemBox.Spreadsheet.ExcelColumnRowBase.Hidden">Hidden</see> property 
            needs to be set to <b>true</b>.</p>
            <p>If group is collapsed, for the row where collapsed (plus) sign is located 
            <see cref="P:GemBox.Spreadsheet.ExcelColumnRowBase.Collapsed">Collapsed</see> property needs to be set to <b>true</b>.</p>
            </remarks>
        </member>
        <member name="T:GemBox.Spreadsheet.ExcelRow">
            <summary>
            Excel row contains row options and cell range with row cells.
            </summary>
            <seealso cref="T:GemBox.Spreadsheet.ExcelColumn"/>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelRow.Delete">
            <summary>
            Deletes this row from the worksheet.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelRow.InsertEmpty(System.Int32)">
            <summary>
            Inserts specified number of empty rows before the current row.
            </summary>
            <param name="rowCount">Number of rows to insert.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelRow.InsertCopy(System.Int32,GemBox.Spreadsheet.ExcelRow)">
            <summary>
            Inserts specified number of copied rows before the current row.
            </summary>
            <param name="rowCount">Number of rows to insert.</param>
            <param name="sourceRow">Source row to copy.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelRow.AutoFit">
            <summary>
            Automatically fits row height to the minimum size required for all lines in the row cells to be visible.
            </summary>
            <remarks>
            <p>Auto-fit row height is a MS Excel feature and not a file format feature. When rows are
            auto-fit in MS Excel user interface, MS Excel will calculate current character heights and 
            set row height to the new numeric value.</p>
            <p>This method will set <see cref="P:GemBox.Spreadsheet.ExcelRow.Height">Height</see> to the approximate 
            value (maxLinesCount * 255).</p>
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelRow.Cells">
            <summary>
            Gets cell range with row cells.
            </summary>
            <example> Look at following code for cell referencing examples:
<code lang="vbnet">
	Dim ws As ExcelWorksheet = excelFile.Worksheets.ActiveWorksheet

	ws.Cells("B2").Value = "Cell B2."
	ws.Cells(6, 0).Value = "Cell in row 7 and column A."

	ws.Rows(2).Cells(0).Value = "Cell in row 3 and column A."
	ws.Rows("4").Cells("B").Value = "Cell in row 4 and column B."

	ws.Columns(2).Cells(4).Value = "Cell in column C and row 5."
	ws.Columns("AA").Cells("6").Value = "Cell in AA column and row 6."
</code>
<code lang="C#">
	ExcelWorksheet ws = excelFile.Worksheets.ActiveWorksheet;

	ws.Cells["B2"].Value = "Cell B2.";
	ws.Cells[6,0].Value = "Cell in row 7 and column A.";

	ws.Rows[2].Cells[0].Value = "Cell in row 3 and column A.";
	ws.Rows["4"].Cells["B"].Value = "Cell in row 4 and column B.";

	ws.Columns[2].Cells[4].Value = "Cell in column C and row 5.";
	ws.Columns["AA"].Cells["6"].Value = "Cell in AA column and row 6.";
</code>
</example>
            <seealso cref="P:GemBox.Spreadsheet.ExcelRow.AllocatedCells"/>
            <seealso cref="T:GemBox.Spreadsheet.ExcelCell"/>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelRow.AllocatedCells">
            <summary>
            Gets only currently allocated cells for this row.
            </summary>
            <remarks>
            <p>Use this collection if you are reading entire Excel file (you don't know exact position of 
            cells with data). If writing values, using <see cref="P:GemBox.Spreadsheet.ExcelRow.Cells">Cells</see>
            property is recommended.</p>
            <p>This collection contains only allocated cells so it is faster as you avoid  
            checking every single cell in a row. You still need to check if a specific cell contains 
            any value (it can be empty).</p>
            </remarks>
            <example> Following code reads entire XLS file and displays all cells containing any data. 
Data types are also displayed. 
<code lang="vbnet">
	Dim ef As New ExcelFile
	Dim sheet As ExcelWorksheet
	Dim row As ExcelRow
	Dim cell As ExcelCell

	ef.LoadXls("..\TestWorkbook.xls")

	For Each sheet In ef.Worksheets
		Console.WriteLine("--------- {0} ---------", sheet.Name)

		For Each row In sheet.Rows
			For Each cell In row.AllocatedCells
				If Not cell.Value Is Nothing Then
					Console.Write("{0}({1})", cell.Value, cell.Value.GetType().Name)
				End If

				Console.Write(vbTab)
			Next

			Console.WriteLine()
		Next
	Next
</code>
<code lang="C#">
	ExcelFile ef = new ExcelFile();
	ef.LoadXls("..\\..\\TestWorkbook.xls");

	foreach(ExcelWorksheet sheet in ef.Worksheets)
	{
		Console.WriteLine("--------- {0} ---------", sheet.Name);

		foreach(ExcelRow row in sheet.Rows)
		{
			foreach(ExcelCell cell in row.AllocatedCells)
			{
				if(cell.Value != null)
					Console.Write("{0}({1})", cell.Value, cell.Value.GetType().Name);

				Console.Write("\t");
			}

			Console.WriteLine();
		}
	}
</code> 
</example>
            <seealso cref="P:GemBox.Spreadsheet.ExcelRow.Cells"/>
            <seealso cref="T:GemBox.Spreadsheet.ExcelCell"/>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelRow.Height">
            <summary>
            Gets or sets row height.
            </summary>
            <remarks>
            Unit is twip (1/20th of a point).
            </remarks>
        </member>
        <member name="T:GemBox.Spreadsheet.ExcelRowColumnCollectionBase`1">
            <summary>
            Generic base class for row and column collections.
            </summary>
            <typeparam name="T">Type of the items in the collection, either <see cref="T:GemBox.Spreadsheet.ExcelRow"/> or <see cref="T:GemBox.Spreadsheet.ExcelColumn"/>.</typeparam>
        </member>
        <member name="T:GemBox.Spreadsheet.ExcelRowColumnCollectionBase">
            <summary>
            Base class for row and column collections.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelRowColumnCollectionBase.DeleteInternalCore(System.Int32)">
            <exclude/>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelRowColumnCollectionBase`1.AdjustArraySize(System.Int32)">
            <exclude/>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelRowColumnCollectionBase`1.ParseName(System.String)">
            <exclude/>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelRowColumnCollectionBase`1.DeleteInternalCore(System.Int32)">
            <exclude/>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelRowColumnCollectionBase`1.RemoveComments(System.Int32)">
            <exclude/>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelRowColumnCollectionBase`1.FixAllIndexes(System.Int32,System.Int32)">
            <exclude/>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelRowColumnCollectionBase`1.FixMergedRegionsIndexes(System.Int32,System.Int32)">
            <exclude/>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelRowColumnCollectionBase`1.FixPageBreaksIndexes(System.Int32,System.Int32)">
            <exclude/>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelRowColumnCollectionBase`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator{T}"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelRowColumnCollectionBase`1.Items">
            <exclude/>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelRowColumnCollectionBase`1.ItemsCore">
            <exclude/>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelRowColumnCollectionBase`1.Item(System.Int32)">
            <overloads>Gets the row / column with the specified index or name.</overloads>
            <summary>
            Gets the row / column with the specified index.
            </summary>
            <param name="index">The zero-based index of the row / column.</param>
            <example> Look at following code for cell referencing examples:
<code lang="vbnet">
	Dim ws As ExcelWorksheet = excelFile.Worksheets.ActiveWorksheet

	ws.Cells("B2").Value = "Cell B2."
	ws.Cells(6, 0).Value = "Cell in row 7 and column A."

	ws.Rows(2).Cells(0).Value = "Cell in row 3 and column A."
	ws.Rows("4").Cells("B").Value = "Cell in row 4 and column B."

	ws.Columns(2).Cells(4).Value = "Cell in column C and row 5."
	ws.Columns("AA").Cells("6").Value = "Cell in AA column and row 6."
</code>
<code lang="C#">
	ExcelWorksheet ws = excelFile.Worksheets.ActiveWorksheet;

	ws.Cells["B2"].Value = "Cell B2.";
	ws.Cells[6,0].Value = "Cell in row 7 and column A.";

	ws.Rows[2].Cells[0].Value = "Cell in row 3 and column A.";
	ws.Rows["4"].Cells["B"].Value = "Cell in row 4 and column B.";

	ws.Columns[2].Cells[4].Value = "Cell in column C and row 5.";
	ws.Columns["AA"].Cells["6"].Value = "Cell in AA column and row 6.";
</code>
</example>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelRowColumnCollectionBase`1.Item(System.String)">
            <summary>
            Gets the row / column with the specified name.
            </summary>
            <param name="name">The name of the row / column.</param>
            <example> Look at following code for cell referencing examples:
<code lang="vbnet">
	Dim ws As ExcelWorksheet = excelFile.Worksheets.ActiveWorksheet

	ws.Cells("B2").Value = "Cell B2."
	ws.Cells(6, 0).Value = "Cell in row 7 and column A."

	ws.Rows(2).Cells(0).Value = "Cell in row 3 and column A."
	ws.Rows("4").Cells("B").Value = "Cell in row 4 and column B."

	ws.Columns(2).Cells(4).Value = "Cell in column C and row 5."
	ws.Columns("AA").Cells("6").Value = "Cell in AA column and row 6."
</code>
<code lang="C#">
	ExcelWorksheet ws = excelFile.Worksheets.ActiveWorksheet;

	ws.Cells["B2"].Value = "Cell B2.";
	ws.Cells[6,0].Value = "Cell in row 7 and column A.";

	ws.Rows[2].Cells[0].Value = "Cell in row 3 and column A.";
	ws.Rows["4"].Cells["B"].Value = "Cell in row 4 and column B.";

	ws.Columns[2].Cells[4].Value = "Cell in column C and row 5.";
	ws.Columns["AA"].Cells["6"].Value = "Cell in AA column and row 6.";
</code>
</example>
        </member>
        <member name="T:GemBox.Spreadsheet.ExcelRowCollection">
            <summary>
            Collection of excel rows (<see cref="T:GemBox.Spreadsheet.ExcelRow">ExcelRow</see>).
            </summary>
            <seealso cref="T:GemBox.Spreadsheet.ExcelRow"/>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelRowCollection.AdjustArraySize(System.Int32)">
            <exclude/>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelRowCollection.ParseName(System.String)">
            <exclude/>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelRowCollection.RowNameToIndex(System.String)">
            <summary>
            Converts row name ("1", "2", ...) to row index (0, 1, ...).
            </summary>
            <param name="name">Row name.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelRowCollection.RowIndexToName(System.Int32)">
            <summary>
            Converts row index (0, 1, ...) to row name ("1", "2", ...).
            </summary>
            <param name="rowIndex">Row index.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelRowCollection.FixMergedRegionsIndexes(System.Int32,System.Int32)">
            <exclude/>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelRowCollection.FixPageBreaksIndexes(System.Int32,System.Int32)">
            <exclude/>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelRowCollection.RemoveComments(System.Int32)">
            <exclude/>
        </member>
        <member name="T:GemBox.Spreadsheet.ExcelColumn">
            <summary>
            Excel column contains column options and cell range with column cells.
            </summary>
            <seealso cref="T:GemBox.Spreadsheet.ExcelRow"/>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelColumn.AutoFit">
            <summary>
            Automatically fits column width to the minimum size required for all data in the column to be visible.
            </summary>
            <remarks>
            <p>Auto-fit column width is a MS Excel feature and not a file format feature. When columns are
            auto-fit in MS Excel user interface, MS Excel will calculate current character widths and 
            set column width to the new numeric value.</p>
            <p>This method will set <see cref="P:GemBox.Spreadsheet.ExcelColumn.Width">Width</see> to the approximate 
            value (maxCharCount * 340).</p>
            </remarks>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelColumn.AutoFitAdvanced(System.Single)">
            <overloads>Automatically fits column width to the minimum size required for all data in the column to be visible. 
            Advanced Autofit methods use methods from System.Drawing to determine the real data width.</overloads>
            <summary>
            Automatically fits column width by checking all the cells in the column.
            </summary>
            <remarks>Scaling factor is used to adjust the width of the column. 
            Resulting column width is equal to CalculatedWidth * scaling. Default scaling is 1.</remarks>
            <param name="scaling">Scaling factor.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelColumn.AutoFitAdvanced(System.Single,GemBox.Spreadsheet.ExcelRow,GemBox.Spreadsheet.ExcelRow)">
            <summary>
            Automatically fits column width by checking only the cells in the column that are specified by row range.
            </summary>
            <remarks>Scaling factor is used to adjust the width of the column. 
            Resulting column width is equal to CalculatedWidth * scaling. Default scaling is 1.</remarks>
            <param name="scaling">Scaling factor.</param>
            <param name="firstRow">First row.</param>
            <param name="lastRow">Last row.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelColumn.Delete">
            <summary>
            Deletes this column from the worksheet.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelColumn.InsertEmpty(System.Int32)">
            <summary>
            Inserts specified number of empty columns before the current column.
            </summary>
            <param name="columnCount">Number of columns to insert.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelColumn.InsertCopy(System.Int32,GemBox.Spreadsheet.ExcelColumn)">
            <summary>
            Inserts specified number of copied columns before the current column.
            </summary>
            <param name="columnCount">Number of columns to insert.</param>
            <param name="sourceColumn">Source column to copy.</param>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelColumn.Cells">
            <summary>
            Gets cell range with column cells.
            </summary>
            <example> Look at following code for cell referencing examples:
<code lang="vbnet">
	Dim ws As ExcelWorksheet = excelFile.Worksheets.ActiveWorksheet

	ws.Cells("B2").Value = "Cell B2."
	ws.Cells(6, 0).Value = "Cell in row 7 and column A."

	ws.Rows(2).Cells(0).Value = "Cell in row 3 and column A."
	ws.Rows("4").Cells("B").Value = "Cell in row 4 and column B."

	ws.Columns(2).Cells(4).Value = "Cell in column C and row 5."
	ws.Columns("AA").Cells("6").Value = "Cell in AA column and row 6."
</code>
<code lang="C#">
	ExcelWorksheet ws = excelFile.Worksheets.ActiveWorksheet;

	ws.Cells["B2"].Value = "Cell B2.";
	ws.Cells[6,0].Value = "Cell in row 7 and column A.";

	ws.Rows[2].Cells[0].Value = "Cell in row 3 and column A.";
	ws.Rows["4"].Cells["B"].Value = "Cell in row 4 and column B.";

	ws.Columns[2].Cells[4].Value = "Cell in column C and row 5.";
	ws.Columns["AA"].Cells["6"].Value = "Cell in AA column and row 6.";
</code>
</example>
            <seealso cref="T:GemBox.Spreadsheet.ExcelCell"/>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelColumn.Width">
            <summary>
            Gets or sets column width.
            </summary>
            <remarks>
            Unit is 1/256th of the width of the zero character in default font.
            </remarks>
            <seealso cref="P:GemBox.Spreadsheet.ExcelWorksheet.DefaultColumnWidth"/>
        </member>
        <member name="T:GemBox.Spreadsheet.ExcelColumnCollection">
            <summary>
            Collection of excel columns (<see cref="T:GemBox.Spreadsheet.ExcelColumn">ExcelColumn</see>).
            </summary>
            <remarks>
            <p>Note that the cells are internally allocated in rows and not in columns. ExcelColumn objects are created 
            only if they have non-standard width or style, or they are accessed directly. So, while ExcelRowCollection.Count 
            shows number of rows occupied with data, ExcelColumnCollection.Count does not say which Column is the 
            last one occupied with data!</p>
            <p>If you want to read all data in a sheet, use 
            <see cref="P:GemBox.Spreadsheet.ExcelRow.AllocatedCells">ExcelRow.AllocatedCells</see> property.</p>
            <p>If you want to find last column occupied with data, use 
            <see cref="M:GemBox.Spreadsheet.ExcelWorksheet.CalculateMaxUsedColumns">CalculateMaxUsedColumns</see> method.</p>
            </remarks>
            <seealso cref="T:GemBox.Spreadsheet.ExcelColumn"/>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelColumnCollection.AdjustArraySize(System.Int32)">
            <exclude/>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelColumnCollection.ParseName(System.String)">
            <exclude/>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelColumnCollection.ColumnNameToIndex(System.String)">
            <summary>
            Converts column name ("A", "B", ...) to column index (0, 1, ...).
            </summary>
            <param name="name">Column name.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelColumnCollection.ColumnIndexToName(System.Int32)">
            <summary>
            Converts column index (0, 1, ...) to column name ("A", "B", ...).
            </summary>
            <param name="columnIndex">Column index.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelColumnCollection.FixMergedRegionsIndexes(System.Int32,System.Int32)">
            <exclude/>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelColumnCollection.FixPageBreaksIndexes(System.Int32,System.Int32)">
            <exclude/>
        </member>
        <member name="T:GemBox.Spreadsheet.PageBreak">
            <summary>
            Base class for all page breaks.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.HorizontalPageBreak">
            <summary>
            Specifies a horizontal position where the new page begins when the worksheet is printed.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.HorizontalPageBreak.Row">
            <summary>
            Index of the first row of the new page.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.HorizontalPageBreak.FirstColumn">
            <summary>
            Index of the first column of the new page.
            </summary>
            <remarks>
            Use 0 (first column) if you don't care.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.HorizontalPageBreak.LastColumn">
            <summary>
            Index of the last column of the new page.
            </summary>
            <remarks>
            Use 255 (last column) if you don't care.
            </remarks>
        </member>
        <member name="T:GemBox.Spreadsheet.VerticalPageBreak">
            <summary>
            Specifies a vertical position where the new page begins when the worksheet is printed.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.VerticalPageBreak.Column">
            <summary>
            Index of the first column of the new page.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.VerticalPageBreak.FirstRow">
            <summary>
            Index of the first row of the new page.
            </summary>
            <remarks>
            Use 0 (first row) if you don't care.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.VerticalPageBreak.LastRow">
            <summary>
            Index of the last row of the new page.
            </summary>
            <remarks>
            Use 65535 (last row) if you don't care.
            </remarks>
        </member>
        <member name="T:GemBox.Spreadsheet.PageBreakCollection`1">
            <summary>
            Generic base class for page break collections.
            </summary>
            <typeparam name="T">Type of the items in the collection, either <see cref="T:GemBox.Spreadsheet.HorizontalPageBreak"/> or <see cref="T:GemBox.Spreadsheet.VerticalPageBreak"/>.</typeparam>
        </member>
        <member name="T:GemBox.Spreadsheet.PageBreakCollection">
            <summary>
            Base class for page break collections.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.PageBreakCollection.Clear">
            <summary>
            Removes all page breaks. 
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.PageBreakCollection.RemoveAt(System.Int32)">
            <summary>
            Removes the page break at the specified index.
            </summary>
            <param name="index">The zero-based index of the page break to remove.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.PageBreakCollection.GetEnumerator">
            <summary>
            Returns an enumerator for the collection.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.PageBreakCollection.ItemsCore">
            <exclude/>
        </member>
        <member name="P:GemBox.Spreadsheet.PageBreakCollection.Count">
            <summary>
            Gets the number of page breaks contained in the collection. 
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.PageBreakCollection`1.CreateItem(System.Int32,System.Int32,System.Int32)">
            <exclude/>
        </member>
        <member name="M:GemBox.Spreadsheet.PageBreakCollection`1.Add(System.Int32)">
            <exclude/>
        </member>
        <member name="M:GemBox.Spreadsheet.PageBreakCollection`1.Add(System.Int32,System.Int32,System.Int32)">
            <exclude/>
        </member>
        <member name="M:GemBox.Spreadsheet.PageBreakCollection`1.GetEnumerator">
            <summary>
            Returns an enumerator for the collection.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.PageBreakCollection`1.ItemsCore">
            <exclude/>
        </member>
        <member name="P:GemBox.Spreadsheet.PageBreakCollection`1.MaxLastLimit">
            <exclude/>
        </member>
        <member name="P:GemBox.Spreadsheet.PageBreakCollection`1.Item(System.Int32)">
            <exclude/>
        </member>
        <member name="T:GemBox.Spreadsheet.HorizontalPageBreakCollection">
            <summary>
            Collection of horizontal page breaks (<see cref="T:GemBox.Spreadsheet.HorizontalPageBreak">HorizontalPageBreak</see>).
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.HorizontalPageBreakCollection.CreateItem(System.Int32,System.Int32,System.Int32)">
            <exclude/>
        </member>
        <member name="M:GemBox.Spreadsheet.HorizontalPageBreakCollection.Add(System.Int32)">
            <overloads>Ads a new horizontal page break.</overloads>
            <summary>
            Ads a new horizontal page break above the specified row.
            </summary>
            <param name="row">The zero-based index of the row.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.HorizontalPageBreakCollection.Add(System.Int32,System.Int32,System.Int32)">
            <summary>
            Ads a new horizontal page break above the specified row and within specified columns.
            </summary>
            <param name="row">The zero-based index of the row.</param>
            <param name="firstColumn">The zero-based index of the first column.</param>
            <param name="lastColumn">The zero-based index of the last column.</param>
        </member>
        <member name="P:GemBox.Spreadsheet.HorizontalPageBreakCollection.MaxLastLimit">
            <exclude/>
        </member>
        <member name="P:GemBox.Spreadsheet.HorizontalPageBreakCollection.Item(System.Int32)">
            <summary>
            Gets or sets the horizontal page break at the specified index.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.VerticalPageBreakCollection">
            <summary>
            Collection of vertical page breaks (<see cref="T:GemBox.Spreadsheet.VerticalPageBreak">VerticalPageBreak</see>).
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.VerticalPageBreakCollection.CreateItem(System.Int32,System.Int32,System.Int32)">
            <exclude/>
        </member>
        <member name="M:GemBox.Spreadsheet.VerticalPageBreakCollection.Add(System.Int32)">
            <overloads>Ads a new vertical page break.</overloads>
            <summary>
            Ads a new vertical page break left to the specified column.
            </summary>
            <param name="column">The zero-based index of the column.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.VerticalPageBreakCollection.Add(System.Int32,System.Int32,System.Int32)">
            <summary>
            Ads a new vertical page break left to the specified column and within specified rows.
            </summary>
            <param name="column">The zero-based index of the column.</param>
            <param name="firstRow">The zero-based index of the first row.</param>
            <param name="lastRow">The zero-based index of the last row.</param>
        </member>
        <member name="P:GemBox.Spreadsheet.VerticalPageBreakCollection.MaxLastLimit">
            <exclude/>
        </member>
        <member name="P:GemBox.Spreadsheet.VerticalPageBreakCollection.Item(System.Int32)">
            <summary>
            Gets or sets the vertical page break at the specified index.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.SpreadsheetHyperlink">
            <summary>
            Hyperlink class.
            </summary>
            <remarks>
            <p>Supported only in xlsx. If you want hyperlinks also to work in XLS, assign HYPERLINK formula to
            <see cref="P:GemBox.Spreadsheet.ExcelCell.Formula">ExcelCell.Formula</see>.</p>
            <p>You can set cell style to underline and font color to blue in order to appear as hyperlink, that 
            is not done automatically.</p>
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.SpreadsheetHyperlink.IsExternal">
            <summary>
            Defines if hyperlink location is in this excel file.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.SpreadsheetHyperlink.ToolTip">
            <summary>
            Gets or sets ToolTip for hyperlink.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.SpreadsheetHyperlink.Location">
            <summary>
            Gets or sets the location string for hyperlink.
            <remarks>URL have to be in escaped format(You can use<see cref="M:System.Uri.EscapeUriString(System.String)">System.Uri.EscapeUriString</see> method).</remarks>
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.SpreadsheetHyperlinkCollection">
            <summary>
            Collection of hyperlinks (<see cref="T:GemBox.Spreadsheet.SpreadsheetHyperlink">SpreadsheetHyperlink</see>).
            </summary>
            <remarks>
            <p>Supported only in xlsx. If you want hyperlinks also to work in XLS, assign HYPERLINK formula to
            <see cref="P:GemBox.Spreadsheet.ExcelCell.Formula">ExcelCell.Formula</see>.</p>
            <p>You can set cell style to underline and font color to blue in order to appear as hyperlink, that 
            is not done automatically.</p>
            </remarks>
        </member>
        <member name="M:GemBox.Spreadsheet.SpreadsheetHyperlinkCollection.Add(GemBox.Spreadsheet.SpreadsheetHyperlink)">
            <summary>
            Adds hyperlink to collection.
            </summary>
            <param name="hyperlink">Hyperlink to add.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.SpreadsheetHyperlinkCollection.Clear">
            <summary>
            Removes all hyperlinks. 
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.SpreadsheetHyperlinkCollection.RemoveAt(System.Int32)">
            <summary>
            Removes the SpreadsheetHyperlink at the specified index.
            </summary>
            <param name="index">The zero-based index of the page break to remove.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.SpreadsheetHyperlinkCollection.DeleteInternal(GemBox.Spreadsheet.SpreadsheetHyperlink)">
            <summary>
            Deletes specified hyperlink.
            </summary>
            <param name="hyperlink">Hyperlink to delete.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.SpreadsheetHyperlinkCollection.GetEnumerator">
            <summary>
            Returns an enumerator for the collection.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.SpreadsheetHyperlinkCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator for the collection.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.SpreadsheetHyperlinkCollection.Count">
            <summary>
            Gets the number of hyperlinks contained in the collection. 
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.MsofbtClientTextBoxRecord.Read(System.IO.BinaryReader)">
            <summary>
            Reads data from the specified reader.
            </summary>
            <param name="reader">The source binary reader.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.MsofbtClientTextBoxRecord.ConvertToBytes(GemBox.Spreadsheet.MsoDelayedRecords)">
            <summary>
            Converts mso structure' representation to bytes.
            </summary>		
        </member>
        <member name="M:GemBox.Spreadsheet.MsofbtClientTextBoxRecord.SetData(GemBox.Spreadsheet.MsoDelayedRecords)">
            <summary>
            Sets the inner data( mso structure' data without header: atom, type, length ).
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.DeflateStream">
            <summary>
            A class for compressing and decompressing streams using the Deflate algorithm.
            </summary>
            <remarks>
            <para>
            Data can be compressed or decompressed, and either of those can be through reading or writing. 
            For more information on the Deflate algorithm, see IETF RFC 1951, "DEFLATE Compressed Data 
            Format Specification version 1.3." 
            </para>
            <para>
            This class is similar to <see cref="T:GemBox.Spreadsheet.ZlibStream"/>, except that <c>ZlibStream</c> adds the RFC1950 
            header bytes to a compressed stream when compressing, or expects the RFC1950 header bytes when 
            decompressing. The <c>DeflateStream</c> does not.
            </para>
            </remarks>
        </member>
        <member name="M:GemBox.Spreadsheet.DeflateStream.#ctor(System.IO.Stream,GemBox.Spreadsheet.CompressionMode,System.Boolean)">
            <summary>
            Create a DeflateStream using the specified CompressionMode, and explicitly specify whether
            the stream should be left open after Deflation or Inflation.
            </summary>
            <remarks>
            <para>
            This constructor allows the application to request that the captive stream remain open after
            the deflation or inflation occurs.  By default, after Close() is called on the stream, the 
            captive stream is also closed. In some cases this is not desired, for example if the stream 
            is a memory stream that will be re-read after compression.  Specify true for the 
            leaveOpen parameter to leave the stream open. 
            </para>
            <para>
            The DeflateStream will use the default compression level.
            </para>
            <para>
            See the other overloads of this constructor for example code.
            </para>
            </remarks>
            <param name="stream">The stream which will be read or written. This is called the 
            "captive" stream in other places in this documentation.</param>
            <param name="mode">Indicates whether the DeflateStream will compress or decompress.</param>
            <param name="leaveOpen">true if the application would like the stream to remain open after inflation/deflation.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.DeflateStream.#ctor(System.IO.Stream,GemBox.Spreadsheet.CompressionMode,GemBox.Spreadsheet.CompressionLevel,System.Boolean)">
            <summary>
            Create a DeflateStream using the specified CompressionMode and the specified CompressionLevel, 
            and explicitly specify whether
            the stream should be left open after Deflation or Inflation.
            </summary>
            <remarks>
            <para>
            This constructor allows the application to request that the captive stream remain open after
            the deflation or inflation occurs.  By default, after Close() is called on the stream, the 
            captive stream is also closed. In some cases this is not desired, for example if the stream 
            is a memory stream that will be re-read after compression.  Specify true for the 
            leaveOpen parameter to leave the stream open. 
            </para>
            </remarks>
            <example>
            This example shows how to use a DeflateStream to compress data.
            <code>
            using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
            {
                using (var raw = System.IO.File.Create(outputFile))
                {
                    using (Stream compressor = new DeflateStream(raw, CompressionMode.Compress, true))
                    {
                        byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                        int n= -1;
                        while (n != 0)
                        {
                            if (n &gt; 0) 
                                compressor.Write(buffer, 0, n);
                            n= input.Read(buffer, 0, buffer.Length);
                        }
                    }
                }
            }
            </code>
            <code lang="VB">
            Dim outputFile As String = (fileToCompress &amp; ".compressed")
            Using input As Stream = File.OpenRead(fileToCompress)
                Using raw As FileStream = File.Create(outputFile)
            	Using compressor As Stream = New DeflateStream(raw, CompressionMode.Compress, True)
            	    Dim buffer As Byte() = New Byte(4096) {}
            	    Dim n As Integer = -1
            	    Do While (n &lt;&gt; 0)
            		If (n &gt; 0) Then
            		    compressor.Write(buffer, 0, n)
            		End If
            		n = input.Read(buffer, 0, buffer.Length)
            	    Loop
            	End Using
                End Using
            End Using
            </code>
            </example>
            <param name="stream">The stream which will be read or written.</param>
            <param name="mode">Indicates whether the DeflateStream will compress or decompress.</param>
            <param name="leaveOpen">true if the application would like the stream to remain open after inflation/deflation.</param>
            <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.DeflateStream.Close">
            <summary>
            Close the stream.  
            </summary>
            <remarks>
            This may or may not close the captive stream. 
            See the ctor's with leaveOpen parameters for more information.
            </remarks>
        </member>
        <member name="M:GemBox.Spreadsheet.DeflateStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.DeflateStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read data from the stream. 
            </summary>
            <remarks>
            <para>
            If you wish to use the DeflateStream to compress data while reading, you can create a DeflateStream with 
            CompressionMode.Compress, providing an uncompressed data stream.  Then call Read() on that DeflateStream, 
            and the data read will be compressed. 
            If you wish to use the DeflateStream to decompress data while reading, you can create a DeflateStream with 
            CompressionMode.Decompress, providing a readable compressed data stream.  Then call Read() on that DeflateStream, 
            and the data read will be decompressed. 
            </para>
            <para>
            A DeflateStream can be used for Read() or Write(), but not both. 
            </para>
            </remarks>
            <param name="buffer">The buffer into which the read data should be placed.</param>
            <param name="offset">the offset within that data array to put the first byte read.</param>
            <param name="count">the number of bytes to read.</param>
            <returns>the number of bytes actually read</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.DeflateStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="offset">this is irrelevant, since it will always throw!</param>
            <param name="origin">this is irrelevant, since it will always throw!</param>
            <returns>irrelevant!</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.DeflateStream.SetLength(System.Int64)">
            <summary>
            Calling this method always throws a NotImplementedException.
            </summary>
            <param name="value">this is irrelevant, since it will always throw!</param>
        </member>
        <member name="M:GemBox.Spreadsheet.DeflateStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Write data to the stream. 
            </summary>
            <remarks>
            <para>
            If you wish to use the DeflateStream to compress data while writing, you can create a DeflateStream with 
            CompressionMode.Compress, and a writable output stream.  Then call Write() on that DeflateStream, 
            providing uncompressed data as input.  The data sent to the output stream will be the compressed form of the data written.
            If you wish to use the DeflateStream to decompress data while writing, you can create a DeflateStream with 
            CompressionMode.Decompress, and a writable output stream.  Then call Write() on that stream, providing previously 
            compressed data. The data sent to the output stream will be the decompressed form of the data written.   
            </para>
            <para>
            A DeflateStream can be used for Read() or Write(), but not both. 
            </para>
            </remarks>
            <param name="buffer">The buffer holding data to write to the stream.</param>
            <param name="offset">the offset within that data array to find the first byte to write.</param>
            <param name="count">the number of bytes to write.</param>
        </member>
        <member name="P:GemBox.Spreadsheet.DeflateStream.FlushMode">
            <summary>
            This property sets the flush behavior on the stream.  
            Sorry, though, not sure exactly how to describe all the various settings.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.DeflateStream.TotalIn">
            <summary> Returns the total number of bytes input so far.</summary>
        </member>
        <member name="P:GemBox.Spreadsheet.DeflateStream.TotalOut">
            <summary> Returns the total number of bytes output so far.</summary>
        </member>
        <member name="P:GemBox.Spreadsheet.DeflateStream.CanRead">
            <summary>
            Indicates whether the stream can be read.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports reading.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.DeflateStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.DeflateStream.CanWrite">
            <summary>
            Indicates whether the stream can be written.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports writing.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.DeflateStream.Length">
            <summary>
            Reading this property always throws a NotImplementedException.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.DeflateStream.Position">
            <summary>
            Reading or Writing this property always throws a NotImplementedException.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.ZlibStream">
            <summary>
            Represents a Zlib stream for compression or decompression.
            </summary>
            <remarks>
            <para>
            Data can be compressed or decompressed, and either of those can be through reading or writing. 
            For more information on the Deflate algorithm, see IETF RFC 1951, "DEFLATE Compressed Data 
            Format Specification version 1.3." 
            </para>
            <para>
            This class is similar to <see cref="T:GemBox.Spreadsheet.DeflateStream"/>, except that it adds the RFC1950 header 
            bytes to a compressed stream when compressing, or expects the RFC1950 header bytes when 
            decompressing.
            </para>
            </remarks>
        </member>
        <member name="M:GemBox.Spreadsheet.ZlibStream.#ctor(System.IO.Stream,GemBox.Spreadsheet.CompressionMode,System.Boolean)">
            <summary>
            Create a ZlibStream using the specified CompressionMode, and explicitly specify whether
            the stream should be left open after Deflation or Inflation.
            </summary>
            <remarks>
            <para>
            This constructor allows the application to request that the captive stream remain open after
            the deflation or inflation occurs.  By default, after Close() is called on the stream, the 
            captive stream is also closed. In some cases this is not desired, for example if the stream 
            is a memory stream that will be re-read after compression.  Specify true for the 
            leaveOpen parameter to leave the stream open. 
            </para>
            <para>
            The ZlibStream will use the default compression level.
            </para>
            <para>
            See the documentation for the <see cref="T:GemBox.Spreadsheet.DeflateStream"/> constructors for example code.
            </para>
            </remarks>
            <param name="stream">The stream which will be read or written. This is called the 
            "captive" stream in other places in this documentation.</param>
            <param name="mode">Indicates whether the ZlibStream will compress or decompress.</param>
            <param name="leaveOpen">true if the application would like the stream to remain open after inflation/deflation.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ZlibStream.#ctor(System.IO.Stream,GemBox.Spreadsheet.CompressionMode,GemBox.Spreadsheet.CompressionLevel,System.Boolean)">
            <summary>
            Create a ZlibStream using the specified CompressionMode and the specified CompressionLevel, 
            and explicitly specify whether
            the stream should be left open after Deflation or Inflation.
            </summary>
            <remarks>
            <para>
            This constructor allows the application to request that the captive stream remain open after
            the deflation or inflation occurs.  By default, after Close() is called on the stream, the 
            captive stream is also closed. In some cases this is not desired, for example if the stream 
            is a memory stream that will be re-read after compression.  Specify true for the 
            leaveOpen parameter to leave the stream open. 
            </para>
            </remarks>
            
            <example>
            <code>
            public void TestStreamCompression()
            {
                System.IO.MemoryStream msSinkCompressed;
                System.IO.MemoryStream msSinkDecompressed;
                ZlibStream zOut;
                String helloOriginal = "Hello, World!  This String will be compressed...";
            
                // first, compress:
                msSinkCompressed = new System.IO.MemoryStream();
                zOut = new ZlibStream(msSinkCompressed, CompressionMode.Compress, CompressionLevel.LEVEL9_BEST_COMPRESSION, true);
                CopyStream(StringToMemoryStream(helloOriginal), zOut);
                zOut.Close();
            
                // at this point, msSinkCompressed contains the compressed bytes
            
                // now, decompress:
                msSinkDecompressed = new System.IO.MemoryStream();
                zOut = new ZlibStream(msSinkDecompressed, CompressionMode.Decompress);
                msSinkCompressed.Position = 0;
                CopyStream(msSinkCompressed, zOut);
            
                string result = MemoryStreamToString(msSinkDecompressed);
                Console.WriteLine("decompressed: {0}", result);
            }
            
            private static void CopyStream(System.IO.Stream src, System.IO.Stream dest)
            {
                byte[] buffer = new byte[1024];
                int len = src.Read(buffer, 0, buffer.Length);
                while (len &gt; 0)
                {
                    dest.Write(buffer, 0, len);
                    len = src.Read(buffer, 0, buffer.Length);
                }
                dest.Flush();
            }
            
            static System.IO.MemoryStream StringToMemoryStream(string s)
            {
                System.Text.ASCIIEncoding enc = new System.Text.ASCIIEncoding();
                int byteCount = enc.GetByteCount(s.ToCharArray(), 0, s.Length);
                byte[] ByteArray = new byte[byteCount];
                int bytesEncodedCount = enc.GetBytes(s, 0, s.Length, ByteArray, 0);
                System.IO.MemoryStream ms = new System.IO.MemoryStream(ByteArray);
                return ms;
            }
            
            static String MemoryStreamToString(System.IO.MemoryStream ms)
            {
                byte[] ByteArray = ms.ToArray();
                System.Text.ASCIIEncoding enc = new System.Text.ASCIIEncoding();
                var s = enc.GetString(ByteArray);
                return s;
            }
            </code>
            </example>
            <param name="stream">The stream which will be read or written.</param>
            <param name="mode">Indicates whether the ZlibStream will compress or decompress.</param>
            <param name="leaveOpen">true if the application would like the stream to remain open after inflation/deflation.</param>
            <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ZlibStream.Close">
            <summary>
            Close the stream.  
            </summary>
            <remarks>
            This may or may not close the captive stream. 
            See the ctor's with leaveOpen parameters for more information.
            </remarks>
        </member>
        <member name="M:GemBox.Spreadsheet.ZlibStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.ZlibStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read data from the stream. 
            </summary>
            <remarks>
            <para>
            If you wish to use the ZlibStream to compress data while reading, you can create a ZlibStream with 
            CompressionMode.Compress, providing an uncompressed data stream.  Then call Read() on that ZlibStream, 
            and the data read will be compressed. 
            If you wish to use the ZlibStream to decompress data while reading, you can create a ZlibStream with 
            CompressionMode.Decompress, providing a readable compressed data stream.  Then call Read() on that ZlibStream, 
            and the data read will be decompressed. 
            </para>
            <para>
            A ZlibStream can be used for Read() or Write(), but not both. 
            </para>
            </remarks>
            <param name="buffer">The buffer into which the read data should be placed.</param>
            <param name="offset">the offset within that data array to put the first byte read.</param>
            <param name="count">the number of bytes to read.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ZlibStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Calling this method always throws a NotImplementedException.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.ZlibStream.SetLength(System.Int64)">
            <summary>
            Calling this method always throws a NotImplementedException.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.ZlibStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Write data to the stream. 
            </summary>
            <remarks>
            <para>
            If you wish to use the ZlibStream to compress data while writing, you can create a ZlibStream with 
            CompressionMode.Compress, and a writable output stream.  Then call Write() on that ZlibStream, 
            providing uncompressed data as input.  The data sent to the output stream will be the compressed form of the data written.
            If you wish to use the ZlibStream to decompress data while writing, you can create a ZlibStream with 
            CompressionMode.Decompress, and a writable output stream.  Then call Write() on that stream, providing previously 
            compressed data. The data sent to the output stream will be the decompressed form of the data written.   
            </para>
            <para>
            A ZlibStream can be used for Read() or Write(), but not both. 
            </para>
            </remarks>
            <param name="buffer">The buffer holding data to write to the stream.</param>
            <param name="offset">the offset within that data array to find the first byte to write.</param>
            <param name="count">the number of bytes to write.</param>
        </member>
        <member name="P:GemBox.Spreadsheet.ZlibStream.FlushMode">
            <summary>
            This property sets the flush behavior on the stream.  
            Sorry, though, not sure exactly how to describe all the various settings.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.ZlibStream.BufferSize">
            <summary>
            Callers can set the buffer size of the working buffer with this property.  
            </summary>
            <remarks>
            The working buffer is used for all stream operations.
            The default size is 1024 bytes.  The minimum size is 128 bytes. You may get better 
            performance with a larger buffer.  Then again, you might not.  I don't know, I haven't tested it.  
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ZlibStream.TotalIn">
            <summary> Returns the total number of bytes input so far.</summary>
        </member>
        <member name="P:GemBox.Spreadsheet.ZlibStream.TotalOut">
            <summary> Returns the total number of bytes output so far.</summary>
        </member>
        <member name="P:GemBox.Spreadsheet.ZlibStream.CanRead">
            <summary>
            Indicates whether the stream can be read.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports reading.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ZlibStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ZlibStream.CanWrite">
            <summary>
            Indicates whether the stream can be written.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports writing.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ZlibStream.Length">
            <summary>
            Reading this property always throws a NotImplementedException.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.ZlibStream.Position">
            <summary>
            Reading or Writing this property always throws a NotImplementedException.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.MsofbtOptRecord.Read(System.IO.BinaryReader)">
            <summary>
            Reads data from the specified reader.
            </summary>
            <param name="reader">The source binary reader.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.MsofbtOptRecord.SetData(GemBox.Spreadsheet.MsoDelayedRecords)">
            <summary>
            Sets the inner data( mso structure' data without header: atom, type, length ).
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.MsofbtDggRecord.Read(System.IO.BinaryReader)">
            <summary>
            Reads data from the specified reader.
            </summary>
            <param name="reader">The source binary reader.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.MsofbtDggRecord.SetData(GemBox.Spreadsheet.MsoDelayedRecords)">
            <summary>
            Sets the inner data( mso structure' data without header: atom, type, length ).
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.MsofbtClientAnchorRecord.Read(System.IO.BinaryReader)">
            <summary>
            Reads data from the specified reader.
            </summary>
            <param name="reader">The source binary reader.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.MsofbtClientAnchorRecord.SetData(GemBox.Spreadsheet.MsoDelayedRecords)">
            <summary>
            Sets the inner data( mso structure' data without header: atom, type, length ).
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.NameFormulaToken">
            <summary>
            Formula token for holding the index to a NAME/EXTERNNAME record.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.NameFormulaToken.nameIndex">
            <summary>
            One-based index to ExternName record.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.NameFormulaToken.DelayInitialize(System.Object[])">
            <summary>
            Make custom delay initialize.
            </summary>
            <param name="data">The data for initialization which is unique for each formula token.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.NameFormulaToken.Read(System.Byte[],System.Int32)">
            <summary>
            Initialize formula token by reading input data from array of bytes
            </summary>
            <param name="rpnBytes">input data, array of bytes</param>
            <param name="startIndex">start position for array of bytes to read from</param>
        </member>
        <member name="M:GemBox.Spreadsheet.NameFormulaToken.ConvertToBytes">
            <summary>
            Convert formula token to array of byte representation.
            </summary>
            <returns>formula token' array of byte representation</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.NameFormulaToken.ToString">
            <summary>
            Convert formula token to string representation.
            </summary>
            <returns>formula token string representation</returns>
        </member>
        <member name="T:GemBox.Spreadsheet.BoolFormulaToken">
            <summary>
            Formula token for holding bool.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.BoolFormulaToken.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:GemBox.Spreadsheet.BoolFormulaToken"/> class.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.BoolFormulaToken.DelayInitialize(System.Object[])">
            <summary>
            Make custom delay initialize.
            </summary>
            <param name="data">The data for initialization which is unique for each formula token.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.BoolFormulaToken.Read(System.Byte[],System.Int32)">
            <summary>
            Initialize formula token by reading input data from array of bytes
            </summary>
            <param name="rpnBytes">input data, array of bytes</param>
            <param name="startIndex">start position for array of bytes to read from</param>
        </member>
        <member name="M:GemBox.Spreadsheet.BoolFormulaToken.ConvertToBytes">
            <summary>
            Convert formula token to array of byte representation.
            </summary>
            <returns>formula token' array of byte representation</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.BoolFormulaToken.ToString">
            <summary>
            Convert formula token to string representation.
            </summary>
            <returns>formula token string representation</returns>
        </member>
        <member name="T:GemBox.Spreadsheet.BinaryOperatorFormulaToken">
            <summary>
            Formula token for holding binary operator.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.BinaryOperatorFormulaToken.#cctor">
            <summary>
            Initializes the <see cref="T:GemBox.Spreadsheet.BinaryOperatorFormulaToken"/> class.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.BinaryOperatorFormulaToken.#ctor(GemBox.Spreadsheet.FormulaTokenCode)">
            <summary>
            Initializes a new instance of the <see cref="T:GemBox.Spreadsheet.BinaryOperatorFormulaToken"/> class.
            </summary>
            <param name="code">The FormulaTokenCode code.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.BinaryOperatorFormulaToken.ToString">
            <summary>
            Convert formula token to string representation.
            </summary>
            <returns>formula token string representation</returns>
        </member>
        <member name="T:GemBox.Spreadsheet.ExcelWorksheet">
            <summary>
            Excel worksheet is a table with additional properties, identified by a unique name.
            </summary>
            <remarks>
            <p>
            Worksheet in Microsoft Excel has limited size. 
            Number of rows (<see cref="T:GemBox.Spreadsheet.ExcelRow">ExcelRow</see>) is limited 
            to <see cref="F:GemBox.Spreadsheet.ExcelFile.MaxRows">ExcelFile.MaxRows</see>. 
            Number of columns (<see cref="T:GemBox.Spreadsheet.ExcelColumn">ExcelColumn</see>) is limited 
            to <see cref="F:GemBox.Spreadsheet.ExcelFile.MaxColumns">ExcelFile.MaxColumns</see>. 
            A specific cell (<see cref="T:GemBox.Spreadsheet.ExcelCell">ExcelCell</see>) can be accessed either trough 
            <see cref="P:GemBox.Spreadsheet.ExcelRow.Cells">ExcelRow.Cells</see>, 
            <see cref="P:GemBox.Spreadsheet.ExcelColumn.Cells">ExcelColumn.Cells</see> or 
            <see cref="P:GemBox.Spreadsheet.ExcelWorksheet.Cells">ExcelWorksheet.Cells</see> property. 
            Whichever property used, there are two distinct methods of getting a cell reference; using <b>name</b>
            and using <b>index</b>. For example, full name of cell in top left corner of a worksheet is "A1". Translated
            to indexes, same cell would be 0,0 (zero row and zero column). If using 
            <see cref="P:GemBox.Spreadsheet.ExcelRow.Cells">ExcelRow.Cells</see> or 
            <see cref="P:GemBox.Spreadsheet.ExcelColumn.Cells">ExcelColumn.Cells</see> to access a
            specific cell, only partial name or partial index must be used, providing unknown column or row information. 
            </p>
            <p>Note that the cells are internally allocated in rows and not in columns. ExcelColumn objects are created 
            only if they have non-standard width or style, or they are accessed directly. So, while ExcelRowCollection.Count 
            shows number of rows occupied with data, ExcelColumnCollection.Count does not say which Column is the 
            last one occupied with data!</p>
            <p>If you want to read all data in a sheet, use 
            <see cref="P:GemBox.Spreadsheet.ExcelRow.AllocatedCells">ExcelRow.AllocatedCells</see> property.</p>
            <p>If you want to find last column occupied with data, use 
            <see cref="M:GemBox.Spreadsheet.ExcelWorksheet.CalculateMaxUsedColumns">CalculateMaxUsedColumns</see> method.</p>
            </remarks>
            <example> Look at following code for cell referencing examples:
<code lang="vbnet">
	Dim ws As ExcelWorksheet = excelFile.Worksheets.ActiveWorksheet

	ws.Cells("B2").Value = "Cell B2."
	ws.Cells(6, 0).Value = "Cell in row 7 and column A."

	ws.Rows(2).Cells(0).Value = "Cell in row 3 and column A."
	ws.Rows("4").Cells("B").Value = "Cell in row 4 and column B."

	ws.Columns(2).Cells(4).Value = "Cell in column C and row 5."
	ws.Columns("AA").Cells("6").Value = "Cell in AA column and row 6."
</code>
<code lang="C#">
	ExcelWorksheet ws = excelFile.Worksheets.ActiveWorksheet;

	ws.Cells["B2"].Value = "Cell B2.";
	ws.Cells[6,0].Value = "Cell in row 7 and column A.";

	ws.Rows[2].Cells[0].Value = "Cell in row 3 and column A.";
	ws.Rows["4"].Cells["B"].Value = "Cell in row 4 and column B.";

	ws.Columns[2].Cells[4].Value = "Cell in column C and row 5.";
	ws.Columns["AA"].Cells["6"].Value = "Cell in AA column and row 6.";
</code>
</example>
            <seealso cref="T:GemBox.Spreadsheet.ExcelRow"/>
            <seealso cref="T:GemBox.Spreadsheet.ExcelColumn"/>
            <seealso cref="T:GemBox.Spreadsheet.ExcelCell"/>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelWorksheet.Delete">
            <summary>
            Deletes this worksheet from the workbook.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelWorksheet.InsertEmpty(System.String)">
            <summary>
            Inserts an empty worksheet before the current worksheet.
            </summary>
            <param name="worksheetName">Worksheet name.</param>
            <returns>Newly created worksheet.</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelWorksheet.InsertCopy(System.String,GemBox.Spreadsheet.ExcelWorksheet)">
            <summary>
            Inserts a copy of an existing worksheet before the current worksheet.
            </summary>
            <param name="destinationWorksheetName">Name of the new worksheet.</param>
            <param name="sourceWorksheet">Source worksheet.</param>
            <returns>Newly created worksheet.</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelWorksheet.InsertDataTable(System.Data.DataTable,System.String,System.Boolean)">
            <summary>
            Inserts a <see cref="T:System.Data.DataTable">DataTable</see> at the specified position in 
            the current worksheet.
            </summary>
            <param name="dataTable">Source DataTable.</param>
            <param name="startCell">Name of start (top-left) cell.</param>
            <param name="columnHeaders">True to insert column names above data.</param>
            <returns>Number of inserted rows.</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelWorksheet.InsertDataTable(System.Data.DataTable,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Inserts a <see cref="T:System.Data.DataTable">DataTable</see> at the specified row and column in 
            the current worksheet.
            </summary>
            <param name="dataTable">Source DataTable.</param>
            <param name="startRow">Index of the start row.</param>
            <param name="startColumn">Index of the start column.</param>
            <param name="columnHeaders">True to insert column names above data.</param>
            <returns>Number of inserted rows.</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelWorksheet.ExtractToDataTable(System.Data.DataTable,System.Int32,GemBox.Spreadsheet.ExtractDataOptions,GemBox.Spreadsheet.ExcelRow,GemBox.Spreadsheet.ExcelColumn)">
            <overloads>Extracts data to <see cref="T:System.Data.DataTable">DataTable</see>.</overloads>
            <summary>
            Extracts data to DataTable with the same column order as it is in ExcelWorksheet.
            </summary>
            <remarks>
            <p>DataTable has to have all the columns defined before calling this method. 
            Because DataColumnMapping objects are not used in this method, columns in DataTable have to have the same
            order as columns in ExcelWorksheet (starting from column defined in startColumn argument).</p>
            <p>You can customize error handling by using <see cref="E:GemBox.Spreadsheet.ExcelWorksheet.ExtractDataEvent">ExtractDataEvent</see>.</p>
            <p>DataTable column type and corresponding cell value type need to be 'similar' data types. If that's not the case, then exception would be thrown.
            Note that numbers and string are not 'similar' data types. Numbers wouldn't be automatically converted to strings because of culture issues; someone would expect the number 12.4 is converted to "12.4" and someone else to "12,4".
            To make custom conversion, use <see cref="E:GemBox.Spreadsheet.ExcelWorksheet.ExtractDataEvent">ExtractDataEvent</see>.</p>
            </remarks>
            <param name="dataTable">Destination DataTable.</param>
            <param name="numberOfRows">Number of rows to extract.</param>
            <param name="options">Options that describe how data will be extracted.</param>
            <param name="startRow">Start ExcelRow.</param>
            <param name="startColumn">Start ExcelColumn.</param>
            <example>   
    Following code demonstrates how to handle <see cref="E:GemBox.Spreadsheet.ExcelWorksheet.ExtractDataEvent">ExtractDataEvent</see>.
    Code demonstrates how to make generic conversion from unsupported type to string.     
    <code lang="vbnet">
      Sub Main()

        ' Create new ExcelFile
        Dim ef = New ExcelFile()

        ' Add sheet
        Dim ws = ef.Worksheets.Add("Sheet1")

        ' Fill sheet
        For i As Integer = 0 To 5
          ws.Cells(i, 0).Value = i   ' Integer value
          ws.Cells(i, 1).Value = "Row: " + i.ToString() ' String value
        Next

        ' Initialize DataTable
        Dim dt = New DataTable()
        dt.Columns.Add("id", Type.GetType("System.String"))
        dt.Columns.Add("text", Type.GetType("System.String"))

        ' Manage ExtractDataError.WrongType error
        AddHandler ws.ExtractDataEvent, AddressOf ExtractDataErrorHandler

        ' Extract data to DataTable
        ws.ExtractToDataTable(dt, 1000, ExtractDataOptions.StopAtFirstEmptyRow, ws.Rows(0), ws.Columns(0))

      End Sub

      Sub ExtractDataErrorHandler(ByVal sender As Object, ByVal e As ExtractDataDelegateEventArgs)
        If e.ErrorID = ExtractDataError.WrongType Then

          If e.ExcelValue = Nothing Then
            e.DataTableValue = Nothing
          Else
            e.DataTableValue = e.ExcelValue.ToString()
          End If

          e.Action = ExtractDataEventAction.Continue

        End If
      End Sub
    </code>
    <code lang="C#">
      private static void Main(string[] args)
      {
        // Create new ExcelFile
        ExcelFile ef = new ExcelFile();

        // Add sheet
        ExcelWorksheet ws = ef.Worksheets.Add("Sheet1");

        // Fill sheet
        for (int i = 0; i != 5; i++)
        {
          ws.Cells[i, 0].Value = i;   // Integer value
          ws.Cells[i, 1].Value = "Row: " + i; // String value
        }

        // Initialize DataTable
        DataTable dt = new DataTable();
        dt.Columns.Add("id", typeof(string));
        dt.Columns.Add("text", typeof(string));

        // Manage ExtractDataError.WrongType error
        ws.ExtractDataEvent += (sender, e) =&gt;
        {
          if (e.ErrorID == ExtractDataError.WrongType)
          {
            e.DataTableValue = e.ExcelValue == null ? null : e.ExcelValue.ToString();
            e.Action = ExtractDataEventAction.Continue;
          }
        };

        // Extract data to DataTable
        ws.ExtractToDataTable(dt, 1000, ExtractDataOptions.StopAtFirstEmptyRow, ws.Rows[0], ws.Columns[0]);
      }
    </code>
  </example>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelWorksheet.ExtractUsedRangeToDataTable(GemBox.Spreadsheet.ExtractDataOptions)">
            <summary>
            Extracts data from used cells of this worksheet to a new DataTable with columns of type object.
            </summary>
            <remarks>This method first calls <see cref="M:GemBox.Spreadsheet.ExcelWorksheet.GetUsedCellRange(System.Boolean)">GetUsedCellRange</see> method
            to find block of used cells in this worksheet. Then it creates a new <see cref="T:System.Data.DataTable">DataTable</see> with the same
            number of columns as width of that range and with the column type of object. Finnaly, it extracts block of used cells to 
            <see cref="T:System.Data.DataTable">DataTable</see> and returns filled <see cref="T:System.Data.DataTable">DataTable</see>.
            </remarks>
            <param name="options">Options that describe how data will be extracted.</param>
            <returns>New DataTable.</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelWorksheet.ExtractToDataTable(System.Data.DataTable,System.Int32,GemBox.Spreadsheet.ExtractDataOptions,System.Data.Common.DataColumnMappingCollection,GemBox.Spreadsheet.ExcelRow)">
            <summary>
            Extracts data to DataTable with column mapping.
            </summary>
            <remarks>
            <p>DataTable has to have all the columns defined before calling this method. 
            How will data be extracted from ExcelColumn to DataTableColumn has to be defined
            in the dataColumnMappingCollection argument.</p>
            <p>You can customize error handling by using <see cref="E:GemBox.Spreadsheet.ExcelWorksheet.ExtractDataEvent">ExtractDataEvent</see>.</p>
            <p>DataTable column type and corresponding cell value type need to be 'similar' data types. If that's not the case, then exception would be thrown.
            Note that numbers and string are not 'similar' data types. Numbers wouldn't be automatically converted to strings because of culture issues; someone would expect the number 12.4 is converted to "12.4" and someone else to "12,4".
            To make custom conversion, use <see cref="E:GemBox.Spreadsheet.ExcelWorksheet.ExtractDataEvent">ExtractDataEvent</see>.</p>
            </remarks>
            <param name="dataTable">Destination DataTable.</param>
            <param name="numberOfRows">Number of rows to extract.</param>
            <param name="options">Options that describe how data will be extracted.</param>
            <param name="dataColumnMappingCollection">Column mapping.</param>
            <param name="startRow">Start ExcelRow.</param>
            <example>   
    Following code demonstrates how to handle <see cref="E:GemBox.Spreadsheet.ExcelWorksheet.ExtractDataEvent">ExtractDataEvent</see>.
    Code demonstrates how to make generic conversion from unsupported type to string.     
    <code lang="vbnet">
      Sub Main()

        ' Create new ExcelFile
        Dim ef = New ExcelFile()

        ' Add sheet
        Dim ws = ef.Worksheets.Add("Sheet1")

        ' Fill sheet
        For i As Integer = 0 To 5
          ws.Cells(i, 0).Value = i   ' Integer value
          ws.Cells(i, 1).Value = "Row: " + i.ToString() ' String value
        Next

        ' Initialize DataTable
        Dim dt = New DataTable()
        dt.Columns.Add("id", Type.GetType("System.String"))
        dt.Columns.Add("text", Type.GetType("System.String"))

        ' Manage ExtractDataError.WrongType error
        AddHandler ws.ExtractDataEvent, AddressOf ExtractDataErrorHandler

        ' Extract data to DataTable
        ws.ExtractToDataTable(dt, 1000, ExtractDataOptions.StopAtFirstEmptyRow, ws.Rows(0), ws.Columns(0))

      End Sub

      Sub ExtractDataErrorHandler(ByVal sender As Object, ByVal e As ExtractDataDelegateEventArgs)
        If e.ErrorID = ExtractDataError.WrongType Then

          If e.ExcelValue = Nothing Then
            e.DataTableValue = Nothing
          Else
            e.DataTableValue = e.ExcelValue.ToString()
          End If

          e.Action = ExtractDataEventAction.Continue

        End If
      End Sub
    </code>
    <code lang="C#">
      private static void Main(string[] args)
      {
        // Create new ExcelFile
        ExcelFile ef = new ExcelFile();

        // Add sheet
        ExcelWorksheet ws = ef.Worksheets.Add("Sheet1");

        // Fill sheet
        for (int i = 0; i != 5; i++)
        {
          ws.Cells[i, 0].Value = i;   // Integer value
          ws.Cells[i, 1].Value = "Row: " + i; // String value
        }

        // Initialize DataTable
        DataTable dt = new DataTable();
        dt.Columns.Add("id", typeof(string));
        dt.Columns.Add("text", typeof(string));

        // Manage ExtractDataError.WrongType error
        ws.ExtractDataEvent += (sender, e) =&gt;
        {
          if (e.ErrorID == ExtractDataError.WrongType)
          {
            e.DataTableValue = e.ExcelValue == null ? null : e.ExcelValue.ToString();
            e.Action = ExtractDataEventAction.Continue;
          }
        };

        // Extract data to DataTable
        ws.ExtractToDataTable(dt, 1000, ExtractDataOptions.StopAtFirstEmptyRow, ws.Rows[0], ws.Columns[0]);
      }
    </code>
  </example>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelWorksheet.CreateDataTable(GemBox.Spreadsheet.ColumnTypeResolution)">
            <summary>
            Extracts data from used cells of this worksheet to a new <see cref="T:System.Data.DataTable">DataTable</see>. 
            <see cref="P:System.Data.DataColumn.DataType">DataTable column type</see> is determined by the <see cref="T:GemBox.Spreadsheet.ColumnTypeResolution">resolution</see>.
            </summary>
            <param name="resolution">Resolution type that determines <see cref="P:System.Data.DataColumn.DataType">DataTable column type</see>.</param>
            <returns>DataTable with data from used cells.</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelWorksheet.CreateDataTable(GemBox.Spreadsheet.CellRange,GemBox.Spreadsheet.ColumnTypeResolution,GemBox.Spreadsheet.ExtractDataOptions,System.Boolean)">
            <summary>
            Extracts data from <see cref="T:GemBox.Spreadsheet.CellRange">specified range of cells</see> to a new <see cref="T:System.Data.DataTable">DataTable</see>. 
            </summary>
            <param name="range">Cell range.</param>
            <param name="resolution">Resolution type that determines <see cref="P:System.Data.DataColumn.DataType">DataTable column type</see>.</param>
            <param name="options">Options that describe how data will be extracted.</param>
            <param name="useFirstRowForColumnNames">If <b>True</b> then values from first row will be used for <see cref="P:System.Data.DataColumn.ColumnName">naming</see> columns.</param>
            <returns>DataTable with data from specified cells.</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelWorksheet.CreateDataTable(GemBox.Spreadsheet.ColumnTypeResolution,GemBox.Spreadsheet.ExcelRow,System.Int32,GemBox.Spreadsheet.ExtractDataOptions,System.Collections.Generic.IEnumerable{GemBox.Spreadsheet.ExcelColumn})">
            <summary>
            Extracts data from specified cells to a new <see cref="T:System.Data.DataTable">DataTable</see>. 
            </summary>
            <param name="resolution">Resolution type that determines <see cref="P:System.Data.DataColumn.DataType">DataTable column type</see>.</param>
            <param name="startRow">Start ExcelRow.</param>
            <param name="numberOfRows">Number of rows to extract.</param>
            <param name="options">Options that describe how data will be extracted.</param>
            <param name="columns">Columns to extract.</param>
            <returns>DataTable with data from specified rows/columns.</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelWorksheet.CreateDataTable(GemBox.Spreadsheet.ColumnTypeResolution,GemBox.Spreadsheet.ExcelRow,System.Int32,GemBox.Spreadsheet.ExtractDataOptions,System.Boolean,System.Collections.Generic.IEnumerable{GemBox.Spreadsheet.ExcelColumn})">
            <summary>
            Extracts data from specified cells to a new <see cref="T:System.Data.DataTable">DataTable</see>.
            </summary>
            <param name="resolution">Resolution type that determines <see cref="P:System.Data.DataColumn.DataType">DataTable column type</see>.</param>
            <param name="startRow">Start ExcelRow.</param>
            <param name="numberOfRows">Number of rows to extract.</param>
            <param name="options">Options that describe how data will be extracted.</param>
            <param name="useFirstRowForColumnNames">If <b>True</b> then values from first row will be used for <see cref="P:System.Data.DataColumn.ColumnName">naming</see> columns.</param>
            <param name="columns">Columns to extract.</param>
            <returns>DataTable with data from specified rows/columns.</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelWorksheet.CreateDataTable(GemBox.Spreadsheet.ColumnTypeResolution,GemBox.Spreadsheet.ExcelRow,System.Int32,GemBox.Spreadsheet.ExtractDataOptions,GemBox.Spreadsheet.ExcelColumn[])">
            <summary>
            Extracts data from specified cells to a new <see cref="T:System.Data.DataTable">DataTable</see>.
            </summary>
            <param name="resolution">Resolution type that determines <see cref="P:System.Data.DataColumn.DataType">DataTable column type</see>.</param>
            <param name="startRow">Start ExcelRow.</param>
            <param name="numberOfRows">Number of rows to extract.</param>
            <param name="options">Options that describe how data will be extracted.</param>
            <param name="columns">Columns to extract.</param>
            <returns>DataTable with data from specified rows/columns.</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelWorksheet.CreateDataTable(GemBox.Spreadsheet.ColumnTypeResolution,GemBox.Spreadsheet.ExcelRow,System.Int32,GemBox.Spreadsheet.ExtractDataOptions,System.Boolean,GemBox.Spreadsheet.ExcelColumn[])">
            <summary>
            Extracts data from specified cells to a new <see cref="T:System.Data.DataTable">DataTable</see>.
            </summary>
            <param name="resolution">Resolution type that determines <see cref="P:System.Data.DataColumn.DataType">DataTable column type</see>.</param>
            <param name="startRow">Start ExcelRow.</param>
            <param name="numberOfRows">Number of rows to extract.</param>
            <param name="options">Options that describe how data will be extracted.</param>
            <param name="useFirstRowForColumnNames">If <b>True</b> then values from first row will be used for <see cref="P:System.Data.DataColumn.ColumnName">naming</see> columns.</param>
            <param name="columns">Columns to extract.</param>
            <returns>DataTable with data from specified rows/columns.</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelWorksheet.GetUsedCellRange">
            <summary>
            Calculates cell range that is used in the worksheet (every allocated cell is considered used).
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelWorksheet.GetUsedCellRange(System.Boolean)">
            <summary>
            Calculates cell range that is used in the worksheet.
            </summary>
            <param name="ignoreCellsWithoutValue">Specifies if allocated cells with <see cref="P:GemBox.Spreadsheet.ExcelCell.Value"/> set to <see langword="null"/> are ignored.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelWorksheet.CalculateMaxUsedColumns">
            <summary>
            Iterates all rows and finds maximum number of used columns.
            </summary>
            <returns>Maximum number of occupied columns in this sheet.</returns>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelWorksheet.HasDataValidations">
            <summary>
            Gets a value indicating whether this sheet has any cells which have data validation features applied.
            </summary>
            <value>
            <c>true</c> if this sheet has any cells which have data validation features applied; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelWorksheet.DataValidations">
            <summary>
            Gets the collection that expresses all data validation information for cells in a sheet which have data validation features applied.
            Supported in XLSX only.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelWorksheet.Pictures">
            <summary>
            Gets <see cref="T:GemBox.Spreadsheet.ExcelPictureCollection">ExcelPictureCollection</see> containing images.
            </summary>
            <remarks>
            This feature is supported only in xlsx file format. 
            Picture formats that are supported are listed in <see cref="T:GemBox.Spreadsheet.ExcelPictureFormat">ExcelPictureFormat</see>.
            </remarks>
            <seealso cref="T:GemBox.Spreadsheet.ExcelPicture">ExcelPicture</seealso>
            <example>
Following code demonstrates how to use images. It shows next features: 
<list type="number">
<item> bmp, jpeg loading </item>
<item> bmp, jpeg loading with custom coordinates and dimensions </item>
</list>
<code lang="vbnet">
	sheet.Pictures.Add( "Image.bmp" ) 
	sheet.Pictures.Add( "Image.bmp", New Rectangle(10, 50, 100, 100) )
</code>
<code lang="C#">
	sheet.Pictures.Add( "Image.bmp" );
	sheet.Pictures.Add( "Image.bmp", new Rectangle( 10, 50, 100, 100 ) );
</code>
</example>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelWorksheet.NamedRanges">
            <summary>
            Gets <see cref="T:GemBox.Spreadsheet.NamedRangeCollection">NamedRangeCollection</see> 
            containing descriptive names which are used to represent cells, ranges of cells, 
            formulas, or constant values.
            </summary>		
            <remarks>
            You can use the labels of columns and rows on a worksheet to refer to the cells within 
            those columns and rows. Or you can create descriptive names to represent cells, ranges of cells, 
            formulas, or constant values. Labels can be used in formulas that refer to data on the same 
            worksheet; if you want to represent a range on another worksheet, use a name.
            You can also create 3-D names that represent the same cell or range of cells across multiple worksheets.		
            </remarks>
            <example>Following code demonstrates how to use formulas and named ranges. It shows next features: 
cell references (both absolute and relative), unary and binary operators, constand operands (integer and floating point),
functions and named cell ranges.
<code lang="vbnet">
    ws.Cells("A1").Value = 5
    ws.Cells("A2").Value = 6
    ws.Cells("A3").Value = 10
 
    ws.Cells("C1").Formula = "=A1+A2"
    ws.Cells("C2").Formula = "=$A$1-A3"
    ws.Cells("C3").Formula = "=COUNT(A1:A3)"
    ws.Cells("C4").Formula = "=AVERAGE($A$1:$A$3)"
    ws.Cells("C5").Formula = "=SUM(A1:A3,2,3)"
    ws.Cells("C7").Formula = "= 123 - (-(-(23.5)))"
 
    ws.NamedRanges.Add("DataRange", ws.Cells.GetSubrange("A1", "A3"))
    ws.Cells("C8").Formula = "=MAX(DataRange)"
 
    Dim cr As CellRange = ws.Cells.GetSubrange("B9","C10")
    cr.Merged = True
    cr.Formula = "=A1*25"
</code>
<code lang="C#">	
	ws.Cells["A1"].Value = 5;
	ws.Cells["A2"].Value = 6;
	ws.Cells["A3"].Value = 10;

	ws.Cells["C1"].Formula = "=A1+A2";
	ws.Cells["C2"].Formula = "=$A$1-A3";
	ws.Cells["C3"].Formula = "=COUNT(A1:A3)";
	ws.Cells["C4"].Formula = "=AVERAGE($A$1:$A$3)";
	ws.Cells["C5"].Formula = "=SUM(A1:A3,2,3)";
	ws.Cells["C7"].Formula = "= 123 - (-(-(23.5)))";

	ws.NamedRanges.Add("DataRange", ws.Cells.GetSubrange("A1", "A3"));
	ws.Cells["C8"].Formula = "=MAX(DataRange)";

	CellRange cr = ws.Cells.GetSubrange("B9", "C10");
	cr.Merged = true;
	cr.Formula = "=A1*25";
</code>
</example>
            <seealso cref="P:GemBox.Spreadsheet.ExcelCell.Formula">ExcelCell.Formula</seealso>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelWorksheet.Hyperlinks">
            <summary>
            Gets hyperlinks in this  sheet.
            </summary>
            <remarks>Supported only in xlsx.</remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelWorksheet.Name">
            <summary>
            Gets or sets worksheet name. 
            </summary>
            <remarks>
            If not unique (worksheet with that name already exists in 
            <see cref="P:GemBox.Spreadsheet.ExcelFile.Worksheets">ExcelFile.Worksheets</see> collection) exception is thrown.
            </remarks>
            <exception cref="T:System.ArgumentException">Thrown if worksheet name is not unique.</exception>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelWorksheet.Rows">
            <summary>
            Gets collection of all rows (<see cref="T:GemBox.Spreadsheet.ExcelRow">ExcelRow</see>) in the worksheet.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelWorksheet.Columns">
            <summary>
            Gets collection of all columns (<see cref="T:GemBox.Spreadsheet.ExcelColumn">ExcelColumn</see>) in the worksheet.
            </summary>
            <remarks>
            <p>Note that the cells are internally allocated in rows and not in columns. ExcelColumn objects are created 
            only if they have non-standard width or style, or they are accessed directly. So, while ExcelRowCollection.Count 
            shows number of rows occupied with data, ExcelColumnCollection.Count does not say which Column is the 
            last one occupied with data!</p>
            <p>If you want to read all data in a sheet, use 
            <see cref="P:GemBox.Spreadsheet.ExcelRow.AllocatedCells">ExcelRow.AllocatedCells</see> property.</p>
            <p>If you want to find last column occupied with data, use 
            <see cref="M:GemBox.Spreadsheet.ExcelWorksheet.CalculateMaxUsedColumns">CalculateMaxUsedColumns</see> method.</p>
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelWorksheet.Cells">
            <summary>
            Gets <see cref="T:GemBox.Spreadsheet.CellRange">CellRange</see> with all the cells 
            (<see cref="T:GemBox.Spreadsheet.ExcelCell">ExcelCell</see>) 
            in the worksheet.
            </summary>
            <example> Look at following code for cell referencing examples:
<code lang="vbnet">
	Dim ws As ExcelWorksheet = excelFile.Worksheets.ActiveWorksheet

	ws.Cells("B2").Value = "Cell B2."
	ws.Cells(6, 0).Value = "Cell in row 7 and column A."

	ws.Rows(2).Cells(0).Value = "Cell in row 3 and column A."
	ws.Rows("4").Cells("B").Value = "Cell in row 4 and column B."

	ws.Columns(2).Cells(4).Value = "Cell in column C and row 5."
	ws.Columns("AA").Cells("6").Value = "Cell in AA column and row 6."
</code>
<code lang="C#">
	ExcelWorksheet ws = excelFile.Worksheets.ActiveWorksheet;

	ws.Cells["B2"].Value = "Cell B2.";
	ws.Cells[6,0].Value = "Cell in row 7 and column A.";

	ws.Rows[2].Cells[0].Value = "Cell in row 3 and column A.";
	ws.Rows["4"].Cells["B"].Value = "Cell in row 4 and column B.";

	ws.Columns[2].Cells[4].Value = "Cell in column C and row 5.";
	ws.Columns["AA"].Cells["6"].Value = "Cell in AA column and row 6.";
</code>
</example>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelWorksheet.Protected">
            <summary>
            Gets or sets the worksheet protection flag.
            </summary>
            <remarks>
            This property is simply written to Excel file and has no effect on the behavior of this library.
            For more information on worksheet protection, consult Microsoft Excel documentation.
            </remarks>
            <seealso cref="P:GemBox.Spreadsheet.ExcelFile.Protected">ExcelFile.Protected</seealso>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelWorksheet.PasswordHash">
            <summary>
            Gets or sets the password hash for protected sheet.
            </summary>
            <remarks>
            This property is simply written to Excel file and has no effect on the behavior of this library.
            For more information on worksheet protection, consult Microsoft Excel documentation.
            This property needs to be set to value of type ushort (property is of type int because ushort is not cls compliant). 
            If you don't know which password hash corresponds to determinant password, make excel file using MS Excel, load it using GemBox.Spreadsheet, and read
            this property. Then reuse that value in your project.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelWorksheet.ProtectionSettings">
            <summary>
            Gets or sets worksheet protection properties. This settings will be used only if <see cref="P:GemBox.Spreadsheet.ExcelWorksheet.Protected"/> is set to <b>True</b>;
            Otherwise it will be ignored.
            Supported in XLSX only.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelWorksheet.Visibility">
            <summary>
            Gets or sets the worksheet visible property.
            </summary>
            <remarks>
            <p>Workbook must contain at least one visible sheet.</p>
            <p>This property is available only in XLSX file format.</p>
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelWorksheet.DefaultColumnWidth">
            <summary>
            Gets or sets default column width.
            </summary>
            <remarks>
            Unit is 1/256th of the width of the zero character in default font. This value is used as width for columns 
            which don't have <see cref="P:GemBox.Spreadsheet.ExcelColumn.Width">ExcelColumn.Width</see> property explicitly set.
            </remarks>
            <seealso cref="P:GemBox.Spreadsheet.ExcelColumn.Width">ExcelColumn.Width</seealso>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelWorksheet.HorizontalPageBreaks">
            <summary>
            Gets collection of all horizontal page breaks 
            (<see cref="T:GemBox.Spreadsheet.HorizontalPageBreak">HorizontalPageBreak</see>) in the worksheet.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelWorksheet.VerticalPageBreaks">
            <summary>
            Gets collection of all vertical page breaks 
            (<see cref="T:GemBox.Spreadsheet.VerticalPageBreak">VerticalPageBreak</see>) in the worksheet.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelWorksheet.HasShape">
            <summary>
            Gets a value indicating whether this instance has shape.
            </summary>
            <value><c>true</c> if this instance has shape; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelWorksheet.Shapes">
            <summary>
            Gets the shapes.
            </summary>
            <value>The shapes.</value>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelWorksheet.PrintOptions">
            <summary>
            Contains MS Excel print and print related options.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelWorksheet.ViewOptions">
            <summary>
            Contains MS Excel display and view related options.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelWorksheet.HeadersFooters">
            <summary>
            Gets or sets headers/footers for the sheet.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelWorksheet.HasHeadersFooters">
            <summary>
            Returns true if worksheet has headers/footers.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelWorksheet.Panes">
            <summary>
            Gets or sets the panes in the worksheet.
            </summary>
            <remarks>
            If there are no split or freeze panes in the worksheet, the value of this property is null.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelWorksheet.HasSplitOrFreezePanes">
            <summary>
            Returns true if worksheet has split or freeze panes.
            </summary>
        </member>
        <member name="E:GemBox.Spreadsheet.ExcelWorksheet.ExtractDataEvent">
            <summary>
            Event that fires when specific error occurs while extracting data to DataTable.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.ExcelWorksheet.ExtractDataEventHandler">
            <summary>
            Delegate for handling the ExtractData events.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.ExtractDataOptions">
            <summary>
            Options specified when extracting data to <see cref="T:System.Data.DataTable">DataTable</see>.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ExtractDataOptions.None">
            <summary>
            None of the options is set. 
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ExtractDataOptions.StopAtFirstEmptyRow">
            <summary>
            Extracting data stops at the first empty row.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ExtractDataOptions.SkipEmptyRows">
            <summary>
            When extracting data, skip all empty rows.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.ColumnTypeResolution">
            <summary>
            Defines resolution method that determines <see cref="P:System.Data.DataColumn.DataType">DataTable column type</see>. 
            </summary>
            <remarks>
            <see cref="P:System.Data.DataColumn.DataType">DataTable column type</see> is determined by the <see cref="T:GemBox.Spreadsheet.ColumnTypeResolution">column type resolution</see> and by exploring 
            types of all <see cref="P:GemBox.Spreadsheet.ExcelCell.Value">values</see> in some column.
            Column type can be <see cref="T:System.Boolean">bool</see>, <see cref="T:System.Int32">int</see>, <see cref="T:System.Double">double</see>, <see cref="T:System.DateTime">
            DateTime</see>, <see cref="T:System.String">string</see> or <see cref="T:System.Object">object</see>.
            </remarks>
        </member>
        <member name="F:GemBox.Spreadsheet.ColumnTypeResolution.Object">
            <summary>
            All columns will be of type <see cref="T:System.Object">object</see>.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ColumnTypeResolution.StringInvariantCulture">
            <summary>
            All columns  will be of type <see cref="T:System.String">string</see>. For conversion from some <see cref="P:GemBox.Spreadsheet.ExcelCell.Value">value</see> to string <see cref="P:System.Globalization.CultureInfo.InvariantCulture">
            invariant culture</see> will be used.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ColumnTypeResolution.StringCurrentCulture">
            <summary>
            All columns  will be of type <see cref="T:System.String">string</see>. For conversion from some <see cref="P:GemBox.Spreadsheet.ExcelCell.Value">value</see> to string <see cref="P:System.Globalization.CultureInfo.CurrentCulture">
            current culture</see> will be used.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ColumnTypeResolution.Auto">
            <summary>
            If all values in some column have the same type then that type will be used for <see cref="P:System.Data.DataColumn.DataType">DataTable column type</see>, otherwise
            column will be of type <see cref="T:System.Object">object</see>. 
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ColumnTypeResolution.AutoPreferStringInvariantCulture">
            <summary>
            If all values in some column have the same type then that type will be used for <see cref="P:System.Data.DataColumn.DataType">DataTable column type</see>, otherwise
            column will be of type <see cref="T:System.String">string</see>. For conversion from some <see cref="P:GemBox.Spreadsheet.ExcelCell.Value">value</see> to string <see cref="P:System.Globalization.CultureInfo.InvariantCulture">
            invariant culture</see> will be used.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ColumnTypeResolution.AutoPreferStringCurrentCulture">
            <summary>
            If all values in some column have the same type then that type will be used for <see cref="P:System.Data.DataColumn.DataType">DataTable column type</see>, otherwise
            column will be of type <see cref="T:System.String">string</see>. For conversion from some <see cref="P:GemBox.Spreadsheet.ExcelCell.Value">value</see> to string <see cref="P:System.Globalization.CultureInfo.CurrentCulture">
            current culture</see> will be used.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.ExcelWorksheetCollection">
            <summary>
            Collection of worksheets (<see cref="T:GemBox.Spreadsheet.ExcelWorksheet">ExcelWorksheet</see>).
            </summary>
            <seealso cref="T:GemBox.Spreadsheet.ExcelWorksheet"/>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelWorksheetCollection.Add(System.String)">
            <summary>
            Adds an empty worksheet to the end of the collection.
            </summary>
            <param name="worksheetName">Worksheet name.</param>
            <returns>Newly created worksheet.</returns>
            <remarks>
            If this is the first worksheet added to the collection the 
            <see cref="P:GemBox.Spreadsheet.ExcelWorksheetCollection.ActiveWorksheet">ActiveWorksheet</see> is set to this worksheet.
            </remarks>
            <exception cref="T:System.ArgumentException">Thrown if worksheet name is not unique.</exception>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelWorksheetCollection.AddCopy(System.String,GemBox.Spreadsheet.ExcelWorksheet)">
            <summary>
            Adds a copy of an existing worksheet to the end of the collection.
            </summary>
            <param name="destinationWorksheetName">Name of new worksheet.</param>
            <param name="sourceWorksheet">Source worksheet.</param>
            <returns>Newly created worksheet.</returns>
            <remarks>
            If this is the first worksheet added to the collection the 
            <see cref="P:GemBox.Spreadsheet.ExcelWorksheetCollection.ActiveWorksheet">ActiveWorksheet</see> is set to this worksheet.
            </remarks>
            <exception cref="T:System.ArgumentException">Thrown if worksheet name is not unique.</exception>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelWorksheetCollection.GetEnumerator">
            <summary>
            Returns an enumerator for the <see cref="T:GemBox.Spreadsheet.ExcelWorksheetCollection">
            ExcelWorksheetCollection</see>.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelWorksheetCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator for the <see cref="T:GemBox.Spreadsheet.ExcelWorksheetCollection">
            ExcelWorksheetCollection</see>.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelWorksheetCollection.Pictures">
            <summary>
            Get the list of bse records
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelWorksheetCollection.SheetNames">
            <summary>
            Gets the sheet names.
            </summary>
            <value>The sheet names.</value>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelWorksheetCollection.SheetIndexes">
            <summary>
            Gets the sheet indexes.
            </summary>
            <value>The sheet indexes.</value>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelWorksheetCollection.Item(System.Int32)">
            <overloads>Gets the worksheet with the specified index or name.</overloads>
            <summary>
            Gets the worksheet with the specified index.
            </summary>
            <param name="index">The zero-based index of the worksheet.</param>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelWorksheetCollection.Item(System.String)">
            <summary>
            Gets the worksheet with the specified name.
            </summary>
            <param name="name">The name of the worksheet.</param>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelWorksheetCollection.ActiveWorksheet">
            <summary>
            Gets or sets active worksheet.
            </summary>
            <remarks>
            Active worksheet is the one selected when file is opened with Microsoft Excel. By default active worksheet 
            is the first one added with <see cref="M:GemBox.Spreadsheet.ExcelWorksheetCollection.Add(System.String)">Add</see> method.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelWorksheetCollection.Count">
            <summary>
            Gets the number of elements contained in the <see cref="T:GemBox.Spreadsheet.ExcelWorksheetCollection">
            ExcelWorksheetCollection</see>.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.NamedRangeCollection">
            <summary>
            Collection of the descriptive names which are used 
            to represent cells, ranges of cells, formulas, or constant values.
            </summary>		
            <remarks>
            You can use the labels of columns and rows on a worksheet to refer to the cells within 
            those columns and rows. Or you can create descriptive names to represent cells, ranges of cells, 
            formulas, or constant values. Labels can be used in formulas that refer to data on the same 
            worksheet; if you want to represent a range on another worksheet, use a name.
            You can also create 3-D names that represent the same cell or range of cells across multiple worksheets.		
            </remarks>
            <example>Following code demonstrates how to use formulas and named ranges. It shows next features: 
cell references (both absolute and relative), unary and binary operators, constand operands (integer and floating point),
functions and named cell ranges.
<code lang="vbnet">
    ws.Cells("A1").Value = 5
    ws.Cells("A2").Value = 6
    ws.Cells("A3").Value = 10
 
    ws.Cells("C1").Formula = "=A1+A2"
    ws.Cells("C2").Formula = "=$A$1-A3"
    ws.Cells("C3").Formula = "=COUNT(A1:A3)"
    ws.Cells("C4").Formula = "=AVERAGE($A$1:$A$3)"
    ws.Cells("C5").Formula = "=SUM(A1:A3,2,3)"
    ws.Cells("C7").Formula = "= 123 - (-(-(23.5)))"
 
    ws.NamedRanges.Add("DataRange", ws.Cells.GetSubrange("A1", "A3"))
    ws.Cells("C8").Formula = "=MAX(DataRange)"
 
    Dim cr As CellRange = ws.Cells.GetSubrange("B9","C10")
    cr.Merged = True
    cr.Formula = "=A1*25"
</code>
<code lang="C#">	
	ws.Cells["A1"].Value = 5;
	ws.Cells["A2"].Value = 6;
	ws.Cells["A3"].Value = 10;

	ws.Cells["C1"].Formula = "=A1+A2";
	ws.Cells["C2"].Formula = "=$A$1-A3";
	ws.Cells["C3"].Formula = "=COUNT(A1:A3)";
	ws.Cells["C4"].Formula = "=AVERAGE($A$1:$A$3)";
	ws.Cells["C5"].Formula = "=SUM(A1:A3,2,3)";
	ws.Cells["C7"].Formula = "= 123 - (-(-(23.5)))";

	ws.NamedRanges.Add("DataRange", ws.Cells.GetSubrange("A1", "A3"));
	ws.Cells["C8"].Formula = "=MAX(DataRange)";

	CellRange cr = ws.Cells.GetSubrange("B9", "C10");
	cr.Merged = true;
	cr.Formula = "=A1*25";
</code>
</example>
            <seealso cref="P:GemBox.Spreadsheet.ExcelCell.Formula">ExcelCell.Formula</seealso>
        </member>
        <member name="M:GemBox.Spreadsheet.NamedRangeCollection.#ctor(GemBox.Spreadsheet.ExcelWorksheet)">
            <summary>
            Initializes a new instance of the <see cref="T:GemBox.Spreadsheet.NamedRangeCollection"/> class.
            </summary>
            <param name="worksheet">The worksheet to initialize NamedRangeCollection.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.NamedRangeCollection.#ctor(GemBox.Spreadsheet.ExcelWorksheet,GemBox.Spreadsheet.NamedRangeCollection)">
            <summary>
            Initializes a new instance of the <see cref="T:GemBox.Spreadsheet.NamedRangeCollection"/> class.
            </summary>
            <param name="worksheet">The worksheet to initialize NamedRangeCollection.</param>
            <param name="sourceNamedRanges">The source named range collection to initialize NamedRangeCollection.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.NamedRangeCollection.Add(System.String,GemBox.Spreadsheet.CellRange)">
            <overloads>Adds a new global or local named range.</overloads>
            <summary>
            Adds a new named range. Named ranges are used to represent cells, ranges of cells,
            formulas or constant values.
            </summary>		
            <param name="name">The user-defined name.</param>
            <param name="range">The range to be refered by name.</param>
            <remarks>
            You can use the labels of columns and rows on a worksheet to refer to the cells within
            those columns and rows. Or you can create descriptive names to represent cells, ranges of cells,
            formulas, or constant values. Labels can be used in formulas that refer to data on the same
            worksheet; if you want to represent a range on another worksheet, use a name.
            You can also create 3-D names that represent the same cell or range of cells across multiple worksheets.
            </remarks>
            <example>Following code demonstrates how to use formulas and named ranges. It shows next features: 
cell references (both absolute and relative), unary and binary operators, constand operands (integer and floating point),
functions and named cell ranges.
<code lang="vbnet">
    ws.Cells("A1").Value = 5
    ws.Cells("A2").Value = 6
    ws.Cells("A3").Value = 10
 
    ws.Cells("C1").Formula = "=A1+A2"
    ws.Cells("C2").Formula = "=$A$1-A3"
    ws.Cells("C3").Formula = "=COUNT(A1:A3)"
    ws.Cells("C4").Formula = "=AVERAGE($A$1:$A$3)"
    ws.Cells("C5").Formula = "=SUM(A1:A3,2,3)"
    ws.Cells("C7").Formula = "= 123 - (-(-(23.5)))"
 
    ws.NamedRanges.Add("DataRange", ws.Cells.GetSubrange("A1", "A3"))
    ws.Cells("C8").Formula = "=MAX(DataRange)"
 
    Dim cr As CellRange = ws.Cells.GetSubrange("B9","C10")
    cr.Merged = True
    cr.Formula = "=A1*25"
</code>
<code lang="C#">	
	ws.Cells["A1"].Value = 5;
	ws.Cells["A2"].Value = 6;
	ws.Cells["A3"].Value = 10;

	ws.Cells["C1"].Formula = "=A1+A2";
	ws.Cells["C2"].Formula = "=$A$1-A3";
	ws.Cells["C3"].Formula = "=COUNT(A1:A3)";
	ws.Cells["C4"].Formula = "=AVERAGE($A$1:$A$3)";
	ws.Cells["C5"].Formula = "=SUM(A1:A3,2,3)";
	ws.Cells["C7"].Formula = "= 123 - (-(-(23.5)))";

	ws.NamedRanges.Add("DataRange", ws.Cells.GetSubrange("A1", "A3"));
	ws.Cells["C8"].Formula = "=MAX(DataRange)";

	CellRange cr = ws.Cells.GetSubrange("B9", "C10");
	cr.Merged = true;
	cr.Formula = "=A1*25";
</code>
</example>
            <seealso cref="P:GemBox.Spreadsheet.ExcelCell.Formula">ExcelCell.Formula</seealso>
        </member>
        <member name="M:GemBox.Spreadsheet.NamedRangeCollection.Add(System.String,GemBox.Spreadsheet.CellRange,System.Boolean)">
            <summary>
            Adds a new named range. Named ranges are used to represent cells, ranges of cells,
            formulas or constant values.
            </summary>		
            <param name="name">The user-defined name.</param>
            <param name="range">The range to be refered by name.</param>
            <param name="globalName">sets the range as global if set to true</param>
            <remarks>
            You can use the labels of columns and rows on a worksheet to refer to the cells within
            those columns and rows. Or you can create descriptive names to represent cells, ranges of cells,
            formulas, or constant values. Labels can be used in formulas that refer to data on the same
            worksheet; if you want to represent a range on another worksheet, use a name.
            You can also create 3-D names that represent the same cell or range of cells across multiple worksheets.
            </remarks>
            <example>Following code demonstrates how to use formulas and named ranges. It shows next features: 
cell references (both absolute and relative), unary and binary operators, constand operands (integer and floating point),
functions and named cell ranges.
<code lang="vbnet">
    ws.Cells("A1").Value = 5
    ws.Cells("A2").Value = 6
    ws.Cells("A3").Value = 10
 
    ws.Cells("C1").Formula = "=A1+A2"
    ws.Cells("C2").Formula = "=$A$1-A3"
    ws.Cells("C3").Formula = "=COUNT(A1:A3)"
    ws.Cells("C4").Formula = "=AVERAGE($A$1:$A$3)"
    ws.Cells("C5").Formula = "=SUM(A1:A3,2,3)"
    ws.Cells("C7").Formula = "= 123 - (-(-(23.5)))"
 
    ws.NamedRanges.Add("DataRange", ws.Cells.GetSubrange("A1", "A3"))
    ws.Cells("C8").Formula = "=MAX(DataRange)"
 
    Dim cr As CellRange = ws.Cells.GetSubrange("B9","C10")
    cr.Merged = True
    cr.Formula = "=A1*25"
</code>
<code lang="C#">	
	ws.Cells["A1"].Value = 5;
	ws.Cells["A2"].Value = 6;
	ws.Cells["A3"].Value = 10;

	ws.Cells["C1"].Formula = "=A1+A2";
	ws.Cells["C2"].Formula = "=$A$1-A3";
	ws.Cells["C3"].Formula = "=COUNT(A1:A3)";
	ws.Cells["C4"].Formula = "=AVERAGE($A$1:$A$3)";
	ws.Cells["C5"].Formula = "=SUM(A1:A3,2,3)";
	ws.Cells["C7"].Formula = "= 123 - (-(-(23.5)))";

	ws.NamedRanges.Add("DataRange", ws.Cells.GetSubrange("A1", "A3"));
	ws.Cells["C8"].Formula = "=MAX(DataRange)";

	CellRange cr = ws.Cells.GetSubrange("B9", "C10");
	cr.Merged = true;
	cr.Formula = "=A1*25";
</code>
</example>
            <seealso cref="P:GemBox.Spreadsheet.ExcelCell.Formula">ExcelCell.Formula</seealso>
        </member>
        <member name="M:GemBox.Spreadsheet.NamedRangeCollection.SetPrintArea(GemBox.Spreadsheet.CellRange)">
            <summary>
            Sets print area.
            </summary>
            <param name="range">Range of cells that we want set as print area.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.NamedRangeCollection.SetPrintTitles(GemBox.Spreadsheet.ExcelRow,System.Int32)">
            <summary>
            Sets print titles (rows to repeat at top).
            </summary>
            <param name="startRow">First row.</param>
            <param name="numberOfRows">Number of rows that repeat.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.NamedRangeCollection.SetPrintTitles(GemBox.Spreadsheet.ExcelColumn,System.Int32)">
            <summary>
            Sets print titles (columns to repeat at left).
            </summary>
            <param name="startColumn">First column.</param>
            <param name="numberOfColumns">Number of columns that repeat.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.NamedRangeCollection.SetPrintTitles(GemBox.Spreadsheet.ExcelRow,System.Int32,GemBox.Spreadsheet.ExcelColumn,System.Int32)">
            <summary>
            Sets print titles.
            </summary>
            <param name="startRow">First row.</param>
            <param name="numberOfRows">Number of rows that repeat.</param>
            <param name="startColumn">First column.</param>
            <param name="numberOfColumns">Number of columns that repeat.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.NamedRangeCollection.GetEnumerator">
            <summary>
            Returns an enumerator that can iterate through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.Generic.IEnumerator{T}">IEnumerator&lt;NamedRange&gt;</see>
            that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:GemBox.Spreadsheet.NamedRangeCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that can iterate through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/>
            that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:GemBox.Spreadsheet.NamedRangeCollection.DeleteInternal(System.Int32)">
            <summary>
            Deletes named range at specified index.
            </summary>
            <param name="index">The specified index.</param>
        </member>
        <member name="P:GemBox.Spreadsheet.NamedRangeCollection.Names">
            <summary>
            Gets the user-defined names. You can use these names as shortcuts for ranges, cells, etc.
            </summary>
            <value>The user-defined names.</value>
        </member>
        <member name="P:GemBox.Spreadsheet.NamedRangeCollection.Count">
            <summary>
            Gets the number of named ranges contained in the collection.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.NamedRangeCollection.NamedRanges">
            <summary>
            Gets or sets the named cell name list
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.NamedRangeCollection.Item(System.Int32)">
            <overloads>Gets the <see cref="T:GemBox.Spreadsheet.NamedRange">NamedRange</see> with 
            the specified index or name.</overloads>
            <summary>
            Gets the <see cref="T:GemBox.Spreadsheet.NamedRange">NamedRange</see> at the specified index.
            </summary>
            <param name="index">Range index.</param>
        </member>
        <member name="P:GemBox.Spreadsheet.NamedRangeCollection.Item(System.String)">
            <summary>
            Gets the <see cref="T:GemBox.Spreadsheet.NamedRange">NamedRange</see> with the specified name.
            </summary>
            <param name="name">Range name.</param>
        </member>
        <member name="T:GemBox.Spreadsheet.NamedRange">
            <summary>
            Represents a named range in the worksheet.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.NamedRange.#ctor(GemBox.Spreadsheet.NamedRangeCollection,System.Int32,System.Object[],System.String,GemBox.Spreadsheet.CellRange,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:GemBox.Spreadsheet.NamedRange"/> class.
            </summary>
            <param name="parent">Parent collection.</param>
            <param name="index">Index in the parrent collection.</param>
            <param name="options">The options.</param>
            <param name="name">The cell range name.</param>
            <param name="range">The named cell range.</param>
            <param name="globalName">if name is global (=true)</param>
        </member>
        <member name="M:GemBox.Spreadsheet.NamedRange.Delete">
            <summary>
            Deletes this named range from the named ranges collection.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.NamedRange.GlobalName">
            <summary>
            gets global flag
            </summary>
            <value>if this name is global</value>
        </member>
        <member name="P:GemBox.Spreadsheet.NamedRange.Range">
            <summary>
            Gets or sets the named cell range.
            </summary>
            <value>The named cell range.</value>
        </member>
        <member name="P:GemBox.Spreadsheet.NamedRange.Name">
            <summary>
            Gets the named range name.
            </summary>
            <value>The named range name.</value>
        </member>
        <member name="P:GemBox.Spreadsheet.NamedRange.Options">
            <summary>
            Gets the options.
            </summary>
            <value>The options.</value>
        </member>
        <member name="T:GemBox.Spreadsheet.ExcelPrintOptions">
            <summary>
            Stores MS Excel print and print related options.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelPrintOptions.GetHashCode">
            <summary>
            Returns the hash code of this object.
            </summary>
            <returns>Hash code.</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.ExcelPrintOptions.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:GemBox.Spreadsheet.ExcelPrintOptions">ExcelPrintOptions</see> is equal 
            to the current <see cref="T:GemBox.Spreadsheet.ExcelPrintOptions">ExcelPrintOptions</see>.
            </summary>
            <param name="obj">Object of <see cref="T:GemBox.Spreadsheet.ExcelPrintOptions">ExcelPrintOptions</see> type.</param>
            <returns><b>true</b> if the specified <see cref="T:GemBox.Spreadsheet.ExcelPrintOptions">ExcelPrintOptions</see> is equal 
            to the current <see cref="T:GemBox.Spreadsheet.ExcelPrintOptions">ExcelPrintOptions</see>; otherwise, <b>false</b>.</returns>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelPrintOptions.VerticalCentered">
            <summary>
            <b>True</b> for printing sheet vertical centered, <b>false</b> otherwise.
            </summary>
            <remarks>
            Default value for this property is <b>false</b>.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelPrintOptions.HorizontalCentered">
            <summary>
            <b>True</b> for printing sheet horizontal centered, <b>false</b> otherwise.
            </summary>
            <remarks>
            Default value for this property is <b>false</b>.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelPrintOptions.PrintHeadings">
            <summary>
            <b>True</b> for print headings, <b>false</b> otherwise.
            </summary>
            <remarks>
            Default value for this property is <b>false</b>.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelPrintOptions.PrintGridlines">
            <summary>
            <b>True</b> for printing gridlines, <b>false</b> otherwise.
            </summary>
            <remarks>
            Default value for this property is <b>false</b>.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelPrintOptions.AutomaticPageBreakScalingFactor">
            <summary>
            Scaling factor for automatic page breaks.
            </summary>
            <remarks>
            <p>Unit is one percent. Value must be between 10 and 400.</p>
            <p>Default value for this property is 100.</p>
            <p>MS Excel inserts automatic page breaks depending on this scaling factor. 
            Smaller it gets, bigger will be the distance between the two automatic page breaks.</p>
            <p>If you set this property, <see cref="P:GemBox.Spreadsheet.ExcelPrintOptions.FitToPage">FitToPage</see>
            will automaticaly be set to <b>false</b>.</p>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if value is out of 10 to 400 range.</exception>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelPrintOptions.FitToPage">
            <summary>
            <b>True</b> for using 
            <see cref="P:GemBox.Spreadsheet.ExcelPrintOptions.FitWorksheetHeightToPages">FitWorksheetHeightToPages</see>
            and <see cref="P:GemBox.Spreadsheet.ExcelPrintOptions.FitWorksheetWidthToPages">FitWorksheetWidthToPages</see>, 
            <b>false</b> otherwise.
            </summary>
            <remarks>
            <p>This property determines whether <see cref="P:GemBox.Spreadsheet.ExcelPrintOptions.AutomaticPageBreakScalingFactor">AutomaticPageBreakScalingFactor</see>
            or <see cref="P:GemBox.Spreadsheet.ExcelPrintOptions.FitWorksheetHeightToPages">FitWorksheetHeightToPages</see>
            and <see cref="P:GemBox.Spreadsheet.ExcelPrintOptions.FitWorksheetWidthToPages">FitWorksheetWidthToPages</see>
            will be used in printing.</p>
            <p>Default value for this property is <b>false</b>.</p>
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelPrintOptions.PaperSize">
            <summary>
            MS Excel specific paper size / type index.
            </summary>
            <remarks>
            <p>
            Default value for this property is 0.
            </p>
            <p>
            Following table shows possible values:
            </p>
            <p>
            <font face="Arial" size="1">
            <table border="1" cellpadding="5" cellspacing="0" ID="Table1">
            <tr>
            <td><b>Index</b></td>
            <td><b>Paper type</b></td>
            <td><b>Paper size</b></td>
            </tr>
            <tr>
            <td>0</td>
            <td>Undefined</td>
            <td>
            </td>
            </tr>
            <tr>
            <td>1</td>
            <td>Letter</td>
            <td>8.5in × 11in</td>
            </tr>
            <tr>
            <td>2</td>
            <td>Letter small paper</td>
            <td>8.5in × 11in</td>
            </tr>
            <tr>
            <td>3</td>
            <td>Tabloid paper</td>
            <td>11 in × 17in</td>
            </tr>
            <tr>
            <td>4</td>
            <td>Ledger paper</td>
            <td>17 in × 11in</td>
            </tr>
            <tr>
            <td>5</td>
            <td>Legal paper</td>
            <td>8.5in × 14in</td>
            </tr>
            <tr>
            <td>6</td>
            <td>Statement paper</td>
            <td>5.5in × 8.5in</td>
            </tr>
            <tr>
            <td>7</td>
            <td>Executive paper</td>
            <td>7.25in × 10.5in</td>
            </tr>
            <tr>
            <td>8</td>
            <td>A3</td>
            <td>297mm × 420mm</td>
            </tr>
            <tr>
            <td>9</td>
            <td>A4</td>
            <td>210mm × 297mm</td>
            </tr>
            <tr>
            <td>10</td>
            <td>A4 small paper</td>
            <td>210mm × 297mm</td>
            </tr>
            <tr>
            <td>11</td>
            <td>A5</td>
            <td>148mm × 210mm</td>
            </tr>
            <tr>
            <td>12</td>
            <td>B4</td>
            <td>250mm × 353mm</td>
            </tr>
            <tr>
            <td>13</td>
            <td>B5</td>
            <td>176mm × 250mm</td>
            </tr>
            <tr>
            <td>14</td>
            <td>Folio paper</td>
            <td>8.5in × 13in</td>
            </tr>
            <tr>
            <td>15</td>
            <td>Quarto paper</td>
            <td>215mm × 275mm</td>
            </tr>
            <tr>
            <td>16</td>
            <td>Standard paper</td>
            <td>10in × 14in</td>
            </tr>
            <tr>
            <td>17</td>
            <td>Standard paper</td>
            <td>11in × 17in</td>
            </tr>
            <tr>
            <td>18</td>
            <td>Note paper</td>
            <td>8.5in × 11in</td>
            </tr>
            <tr>
            <td>19</td>
            <td>#9 envelope</td>
            <td>3.875in × 8.875in</td>
            </tr>
            <tr>
            <td>20</td>
            <td>#10 envelope</td>
            <td>4.125in * 9.5in</td>
            </tr>
            <tr>
            <td>21</td>
            <td>#11 envelope</td>
            <td>4.5in * 10.375in</td>
            </tr>
            <tr>
            <td>22</td>
            <td>#12 envelope</td>
            <td>4.75in * 11in</td>
            </tr>
            <tr>
            <td>23</td>
            <td>#14 envelope</td>
            <td>5in * 11.5in</td>
            </tr>
            <tr>
            <td>24</td>
            <td>C paper</td>
            <td>17in * 22in</td>
            </tr>
            <tr>
            <td>25</td>
            <td>D paper</td>
            <td>22in * 34in</td>
            </tr>
            <tr>
            <td>26</td>
            <td>E paper</td>
            <td>34in * 44in</td>
            </tr>
            <tr>
            <td>27</td>
            <td>DL envelope</td>
            <td>110mm × 220mm</td>
            </tr>
            <tr>
            <td>28</td>
            <td>C5 envelope</td>
            <td>162mm × 229mm</td>
            </tr>
            <tr>
            <td>29</td>
            <td>C3 envelope</td>
            <td>324mm × 458mm</td>
            </tr>
            <tr>
            <td>31</td>
            <td>C6 envelope</td>
            <td>114mm × 162mm</td>
            </tr>
            <tr>
            <td>32</td>
            <td>C65 envelope</td>
            <td>114mm × 229mm</td>
            </tr>
            <tr>
            <td>33</td>
            <td>B4 envelope</td>
            <td>250mm × 353mm</td>
            </tr>
            <tr>
            <td>34</td>
            <td>B5 envelope</td>
            <td>176mm × 250mm</td>
            </tr>
            <tr>
            <td>35</td>
            <td>B6 envelope</td>
            <td>176mm × 125mm</td>
            </tr>
            <tr>
            <td>36</td>
            <td>Italy envelope</td>
            <td>110mm × 230mm</td>
            </tr>
            <tr>
            <td>37</td>
            <td>Monarch envelope</td>
            <td>3.875in × 7.5in</td>
            </tr>
            <tr>
            <td>38</td>
            <td>6 3/4 envelope</td>
            <td>3.625in * 6.5in</td>
            </tr>
            <tr>
            <td>39</td>
            <td>US standard fanfold</td>
            <td>14.875in × 11in</td>
            </tr>
            <tr>
            <td>40</td>
            <td>German standard fanfold</td>
            <td>8.5in × 12in</td>
            </tr>
            <tr>
            <td>41</td>
            <td>German legal fanfold</td>
            <td>8.5in * 13in</td>
            </tr>
            <tr>
            <td>42</td>
            <td>ISO B4</td>
            <td>250mm * 353mm</td>
            </tr>
            <tr>
            <td>43</td>
            <td>Japanese double postcard</td>
            <td>200mm * 148mm</td>
            </tr>
            <tr>
            <td>44</td>
            <td>Standard paper</td>
            <td>9in * 11in</td>
            </tr>
            <tr>
            <td>45</td>
            <td>Standard paper</td>
            <td>10in * 11in</td>
            </tr>
            <tr>
            <td>46</td>
            <td>Standard paper</td>
            <td>15in * 11in</td>
            </tr>
            <tr>
            <td>47</td>
            <td>Invite envelope</td>
            <td>220mm * 220mm</td>
            </tr>
            <tr>
            <td>50</td>
            <td>Letter extra paper</td>
            <td>9.275in * 12in</td>
            </tr>
            <tr>
            <td>51</td>
            <td>Legal extra paper</td>
            <td>9.275in * 15in</td>
            </tr>
            <tr>
            <td>52</td>
            <td>Tabloid extra paper</td>
            <td>11.69in * 18in</td>
            </tr>
            <tr>
            <td>53</td>
            <td>A4 extra paper</td>
            <td>236mm * 322mm</td>
            </tr>
            <tr>
            <td>54</td>
            <td>Letter transverse paper</td>
            <td>8.275in * 11in</td>
            </tr>
            <tr>
            <td>55</td>
            <td>A4 transverse paper</td>
            <td>210mm * 297mm</td>
            </tr>
            <tr>
            <td>56</td>
            <td>Letter extra transverse paper</td>
            <td>9.275in * 12in</td>
            </tr>
            <tr>
            <td>57</td>
            <td>SuperA/SuperA/A4 paper</td>
            <td>227mm * 356mm</td>
            </tr>
            <tr>
            <td>58</td>
            <td>SuperB/SuperB/A3 paper</td>
            <td>305mm * 487mm</td>
            </tr>
            <tr>
            <td>59</td>
            <td>Letter plus paper</td>
            <td>8.5in * 12.69in</td>
            </tr>
            <tr>
            <td>60</td>
            <td>A4 plus paper</td>
            <td>210mm * 330mm</td>
            </tr>
            <tr>
            <td>61</td>
            <td>A5 transverse paper</td>
            <td>148mm * 210mm</td>
            </tr>
            <tr>
            <td>62</td>
            <td>JIS B5 transverse paper</td>
            <td>182mm * 257mm</td>
            </tr>
            <tr>
            <td>63</td>
            <td>A3 extra paper</td>
            <td>322mm * 445mm</td>
            </tr>
            <tr>
            <td>64</td>
            <td>A5 extra paper</td>
            <td>174mm * 235mm</td>
            </tr>
            <tr>
            <td>65</td>
            <td>ISO B5 extra paper </td>
            <td>201mm * 276mm</td>
            </tr>
            <tr>
            <td>66</td>
            <td>A2 paper</td>
            <td>420mm * 594mm</td>
            </tr>
            <tr>
            <td>67</td>
            <td>A3 transverse paper</td>
            <td>297mm * 420mm</td>
            </tr>
            <tr>
            <td>68</td>
            <td>A3 extra transverse paper</td>
            <td>322mm * 445mm</td>
            </tr>
            </table>
            </font>
            </p>
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelPrintOptions.StartPageNumber">
            <summary>
            Start page number.
            </summary>
            <remarks>
            Default value for this property is 1.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelPrintOptions.FitWorksheetWidthToPages">
            <summary>
            Fit worksheet width to this number of pages (0 = use as many as needed).
            </summary>
            <remarks>
            <p>Default value for this property is 0.</p>
            <p>If you set this property, <see cref="P:GemBox.Spreadsheet.ExcelPrintOptions.FitToPage">FitToPage</see>
            will automaticaly be set to <b>true</b>.</p>
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelPrintOptions.FitWorksheetHeightToPages">
            <summary>
            Fit worksheet height to this number of pages (0 = use as many as needed).
            </summary>
            <remarks>
            <p>Default value for this property is 0.</p>
            <p>If you set this property, <see cref="P:GemBox.Spreadsheet.ExcelPrintOptions.FitToPage">FitToPage</see>
            will automaticaly be set to <b>true</b>.</p>
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelPrintOptions.PrintPagesInRows">
            <summary>
            <b>True</b> for printing pages in rows, <b>false</b> otherwise.
            </summary>
            <remarks>
            Default value for this property is <b>false</b>.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelPrintOptions.Portrait">
            <summary>
            <b>True</b> for portrait orientation, <b>false</b> for landscape orientation.
            </summary>
            <remarks>
            Default value for this property is <b>true</b>.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelPrintOptions.PrintBlackWhite">
            <summary>
            <b>True</b> for printing in black and white, <b>false</b> otherwise.
            </summary>
            <remarks>
            Default value for this property is <b>false</b>.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelPrintOptions.DraftQuality">
            <summary>
            <b>True</b> for printing in draft quality, <b>false</b> otherwise.
            </summary>
            <remarks>
            Default value for this property is <b>false</b>.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelPrintOptions.PrintCellNotes">
            <summary>
            <b>True</b> for printing cell notes, <b>false</b> otherwise.
            </summary>
            <remarks>
            Default value for this property is <b>false</b>.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelPrintOptions.UseStartPageNumber">
            <summary>
            <b>True</b> for using start page number, <b>false</b> otherwise.
            </summary>
            <remarks>
            Default value for this property is <b>false</b>.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelPrintOptions.PrintNotesSheetEnd">
            <summary>
            <b>True</b> for printing notes at end of sheet, <b>false</b> otherwise.
            </summary>
            <remarks>
            Default value for this property is <b>false</b>.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelPrintOptions.PrintResolution">
            <summary>
            Print resolution in dpi.
            </summary>
            <remarks>
            Default value for this property is 0.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelPrintOptions.VerticalPrintResolution">
            <summary>
            Vertical print resolution in dpi.
            </summary>
            <remarks>
            Default value for this property is 0.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelPrintOptions.HeaderMargin">
            <summary>
            Header margin.
            </summary>
            <remarks>
            Default value for this property is 0.5.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelPrintOptions.FooterMargin">
            <summary>
            Footer margin.
            </summary>
            <remarks>
            Default value for this property is 0.5.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelPrintOptions.TopMargin">
            <summary>
            Top margin.
            </summary>
            <remarks>
            Default value for this property is 1.9.
            Currently supported only in XLSX.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelPrintOptions.BottomMargin">
            <summary>
            Bottom margin.
            </summary>
            <remarks>
            Default value for this property is 1.9.
            Currently supported only in XLSX.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelPrintOptions.LeftMargin">
            <summary>
            Left margin.
            </summary>
            <remarks>
            Default value for this property is 1.8.
            Currently supported only in XLSX.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelPrintOptions.RightMargin">
            <summary>
            Right margin.
            </summary>
            <remarks>
            Default value for this property is 1.8.
            Currently supported only in XLSX.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelPrintOptions.NumberOfCopies">
            <summary>
            Number of copies to print.
            </summary>
            <remarks>
            Default value for this property is 1.
            </remarks>
        </member>
        <member name="T:GemBox.Spreadsheet.ExcelViewOptions">
            <summary>
            Stores MS Excel display and view related options.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelViewOptions.FirstVisibleRow">
            <summary>
            Index of the first visible row in the worksheet.
            </summary>
            <remarks>
            Default value for this property is 0.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelViewOptions.FirstVisibleColumn">
            <summary>
            Index of the first visible column in the worksheet.
            </summary>
            <remarks>
            Default value for this property is 0.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelViewOptions.Zoom">
            <summary>
            Magnification factor in normal view.
            </summary>
            <remarks>
            <p>Unit is one percent. Value must be between 10 and 400.</p>
            <p>Default value for this property is 100.</p>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if value is out of 10 to 400 range.</exception>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelViewOptions.PageBreakViewZoom">
            <summary>
            Magnification factor in page break view.
            </summary>
            <remarks>
            <p>Unit is one percent. Value must be between 10 and 400.</p>
            <p>Default value for this property is 60.</p>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if value is out of 10 to 400 range.</exception>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelViewOptions.ShowFormulas">
            <summary>
            If true, MS Excel shows formulas. Otherwise, formula results are shown. 
            </summary>
            <remarks>
            Default value for this property is <b>false</b>.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelViewOptions.ShowGridLines">
            <summary>
            If true, MS Excel shows grid lines.
            </summary>
            <remarks>
            Default value for this property is <b>true</b>.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelViewOptions.ShowSheetHeaders">
            <summary>
            If true, MS Excel shows row and column headers.
            </summary>
            <remarks>
            Default value for this property is <b>true</b>.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelViewOptions.ShowZeroValues">
            <summary>
            If true, MS Excel shows zero values. Otherwise, zero values are shown as empty cells.
            </summary>
            <remarks>
            Default value for this property is <b>true</b>.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelViewOptions.ShowColumnsFromRightToLeft">
            <summary>
            If true, MS Excel shows columns from right to left.
            </summary>
            <remarks>
            Default value for this property is <b>false</b>.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelViewOptions.ShowOutlineSymbols">
            <summary>
            If true, MS Excel shows outline symbols.
            </summary>
            <remarks>
            Default value for this property is <b>true</b>.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelViewOptions.ShowInPageBreakPreview">
            <summary>
            If true, MS Excel shows worksheet in page break preview. Otherwise, normal view is used.
            </summary>
            <remarks>
            Default value for this property is <b>false</b>.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelViewOptions.OutlineRowButtonsBelow">
            <summary>
            Gets or sets whether outline row buttons are displayed below groups.
            </summary>
            <remarks>
            This property is simply written to Excel file and has no effect on behavior of this library.
            For more information on worksheet protection, consult Microsoft Excel documentation.
            </remarks>
            <example> Following code creates two horizontal groups and one vertical group. Horizontal groups have 
outline button above (default is below), while vertical group is collapsed.
<code lang="vbnet">
    Sub GroupingSample(ByVal ws As ExcelWorksheet)
        ws.Cells(0, 0).Value = "Grouping and outline example:"

        <font color="Green">' Vertical grouping.</font>
        ws.Cells(2, 0).Value = "GroupA Start"
        ws.Rows(2).OutlineLevel = 1
        ws.Cells(3, 0).Value = "A"
        ws.Rows(3).OutlineLevel = 1
        ws.Cells(4, 1).Value = "GroupB Start"
        ws.Rows(4).OutlineLevel = 2
        ws.Cells(5, 1).Value = "B"
        ws.Rows(5).OutlineLevel = 2
        ws.Cells(6, 1).Value = "GroupB End"
        ws.Rows(6).OutlineLevel = 2
        ws.Cells(7, 0).Value = "GroupA End"
        ws.Rows(7).OutlineLevel = 1
        <font color="Green">' Put outline row buttons above groups.</font>
        ws.ViewOptions.OutlineRowButtonsBelow = False

        <font color="Green">' Horizontal grouping (collapsed).</font>
        ws.Cells("E2").Value = "Gr.C Start"
        ws.Columns("E").OutlineLevel = 1
        ws.Columns("E").Hidden = True
        ws.Cells("F2").Value = "C"
        ws.Columns("F").OutlineLevel = 1
        ws.Columns("F").Hidden = True
        ws.Cells("G2").Value = "Gr.C End"
        ws.Columns("G").OutlineLevel = 1
        ws.Columns("G").Hidden = True
        ws.Columns("H").Collapsed = True
    End Sub
</code>
<code lang="C#">
	static void GroupingSample(ExcelWorksheet ws)
	{
		  ws.Cells[0,0].Value = "Grouping and outline example:";

		  //Vertical grouping.
      ws.Cells[2, 0].Value = "GroupA Start";
      ws.Rows[2].OutlineLevel = 1;
      ws.Cells[3, 0].Value = "A";
      ws.Rows[3].OutlineLevel = 1;
      ws.Cells[4, 1].Value = "GroupB Start";
      ws.Rows[4].OutlineLevel = 2;
      ws.Cells[5, 1].Value = "B";
      ws.Rows[5].OutlineLevel = 2;
      ws.Cells[6, 1].Value = "GroupB End";
      ws.Rows[6].OutlineLevel = 2;
      ws.Cells[7, 0].Value = "GroupA End";
      ws.Rows[7].OutlineLevel = 1;
      // Put outline row buttons above groups.
      ws.ViewOptions.OutlineRowButtonsBelow = false;

      //Horizontal grouping (collapsed).
      ws.Cells["E2"].Value = "Gr.C Start";
      ws.Columns["E"].OutlineLevel = 1;
      ws.Columns["E"].Hidden = true;
      ws.Cells["F2"].Value = "C";
      ws.Columns["F"].OutlineLevel = 1;
      ws.Columns["F"].Hidden = true;
      ws.Cells["G2"].Value = "Gr.C End";
      ws.Columns["G"].OutlineLevel = 1;
      ws.Columns["G"].Hidden = true;
      ws.Columns["H"].Collapsed = true;
  }
</code>
</example>
            <seealso cref="P:GemBox.Spreadsheet.ExcelViewOptions.OutlineColumnButtonsRight">ExcelWorksheet.OutlineColumnButtonsRight</seealso>
            <seealso cref="P:GemBox.Spreadsheet.ExcelColumnRowBase.Collapsed"/>
            <seealso cref="P:GemBox.Spreadsheet.ExcelColumnRowBase.OutlineLevel"/>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelViewOptions.OutlineColumnButtonsRight">
            <summary>
            Gets or sets whether outline column buttons are displayed on the right side of groups.
            </summary>
            <remarks>
            This property is simply written to Excel file and has no effect on behavior of this library.
            For more information on worksheet protection, consult Microsoft Excel documentation.
            </remarks>
            <example> Following code creates two horizontal groups and one vertical group. Horizontal groups have 
outline button above (default is below), while vertical group is collapsed.
<code lang="vbnet">
    Sub GroupingSample(ByVal ws As ExcelWorksheet)
        ws.Cells(0, 0).Value = "Grouping and outline example:"

        <font color="Green">' Vertical grouping.</font>
        ws.Cells(2, 0).Value = "GroupA Start"
        ws.Rows(2).OutlineLevel = 1
        ws.Cells(3, 0).Value = "A"
        ws.Rows(3).OutlineLevel = 1
        ws.Cells(4, 1).Value = "GroupB Start"
        ws.Rows(4).OutlineLevel = 2
        ws.Cells(5, 1).Value = "B"
        ws.Rows(5).OutlineLevel = 2
        ws.Cells(6, 1).Value = "GroupB End"
        ws.Rows(6).OutlineLevel = 2
        ws.Cells(7, 0).Value = "GroupA End"
        ws.Rows(7).OutlineLevel = 1
        <font color="Green">' Put outline row buttons above groups.</font>
        ws.ViewOptions.OutlineRowButtonsBelow = False

        <font color="Green">' Horizontal grouping (collapsed).</font>
        ws.Cells("E2").Value = "Gr.C Start"
        ws.Columns("E").OutlineLevel = 1
        ws.Columns("E").Hidden = True
        ws.Cells("F2").Value = "C"
        ws.Columns("F").OutlineLevel = 1
        ws.Columns("F").Hidden = True
        ws.Cells("G2").Value = "Gr.C End"
        ws.Columns("G").OutlineLevel = 1
        ws.Columns("G").Hidden = True
        ws.Columns("H").Collapsed = True
    End Sub
</code>
<code lang="C#">
	static void GroupingSample(ExcelWorksheet ws)
	{
		  ws.Cells[0,0].Value = "Grouping and outline example:";

		  //Vertical grouping.
      ws.Cells[2, 0].Value = "GroupA Start";
      ws.Rows[2].OutlineLevel = 1;
      ws.Cells[3, 0].Value = "A";
      ws.Rows[3].OutlineLevel = 1;
      ws.Cells[4, 1].Value = "GroupB Start";
      ws.Rows[4].OutlineLevel = 2;
      ws.Cells[5, 1].Value = "B";
      ws.Rows[5].OutlineLevel = 2;
      ws.Cells[6, 1].Value = "GroupB End";
      ws.Rows[6].OutlineLevel = 2;
      ws.Cells[7, 0].Value = "GroupA End";
      ws.Rows[7].OutlineLevel = 1;
      // Put outline row buttons above groups.
      ws.ViewOptions.OutlineRowButtonsBelow = false;

      //Horizontal grouping (collapsed).
      ws.Cells["E2"].Value = "Gr.C Start";
      ws.Columns["E"].OutlineLevel = 1;
      ws.Columns["E"].Hidden = true;
      ws.Cells["F2"].Value = "C";
      ws.Columns["F"].OutlineLevel = 1;
      ws.Columns["F"].Hidden = true;
      ws.Cells["G2"].Value = "Gr.C End";
      ws.Columns["G"].OutlineLevel = 1;
      ws.Columns["G"].Hidden = true;
      ws.Columns["H"].Collapsed = true;
  }
</code>
</example>
            <seealso cref="P:GemBox.Spreadsheet.ExcelViewOptions.OutlineRowButtonsBelow">ExcelWorksheet.OutlineRowButtonsBelow</seealso>
            <seealso cref="P:GemBox.Spreadsheet.ExcelColumnRowBase.Collapsed"/>
            <seealso cref="P:GemBox.Spreadsheet.ExcelColumnRowBase.OutlineLevel"/>
        </member>
        <member name="P:GemBox.Spreadsheet.ExcelViewOptions.SelectedCells">
            <summary>
            Gets or sets the selected cells.
            </summary>
            <value>
            The selected cells.
            </value>
            /* JK(2012-01-10): Added support for selected cells. Ticket: https://www.assembla.com/spaces/gemmeus/tickets/481 */
        </member>
        <member name="T:GemBox.Spreadsheet.ExtractDataError">
            <summary>
            Possible errors that can occur while extracting to DataTable.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ExtractDataError.WrongType">
            <summary>
            Error that indicates that data in ExcelWorksheet can't convert to DataTable type.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.ExtractDataEventAction">
            <summary>
            Possible ways of dealing with error after the event has been handled.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ExtractDataEventAction.ThrowException">
            <summary>
            Throw exception after event has been handled.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ExtractDataEventAction.Continue">
            <summary>
            Continue extracting data to DataTable.
            To the <see cref="T:System.Data.DataTable">DataTable</see> cell the
            DataTableValue property from <see cref="T:GemBox.Spreadsheet.ExtractDataDelegateEventArgs">ExtractDataDelegateEventArgs</see> object 
            is assigned.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ExtractDataEventAction.StopReading">
            <summary>
            Stop extracting data to DataTable.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ExtractDataEventAction.SkipRow">
            <summary>
            Skip row.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.ExtractDataDelegateEventArgs">
            <summary>
            Arguments of ExtractDataDelegate.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.ExtractDataDelegateEventArgs.ExcelValue">
            <summary>
            Value of the <see cref="T:GemBox.Spreadsheet.ExcelCell">ExcelCell</see>.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.ExtractDataDelegateEventArgs.DataTableValue">
            <summary>
            Value of the <see cref="T:System.Data.DataTable">DataTable</see> cell.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.ExtractDataDelegateEventArgs.ErrorID">
            <summary>
            Description of error that occurred.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.ExtractDataDelegateEventArgs.Mapping">
            <summary>
            Mapping of column which contains a cell where error occurred.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.ExtractDataDelegateEventArgs.WorksheetRow">
            <summary>
            <see cref="T:GemBox.Spreadsheet.ExcelRow">ExcelRow</see> which contains a cell where error occurred.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.ExtractDataDelegateEventArgs.DestinationTable">
            <summary>
            Destinaton <see cref="T:System.Data.DataTable">DataTable</see>.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.ExtractDataDelegateEventArgs.DataTableRow">
            <summary>
            Index of <see cref="T:System.Data.DataTable">DataTable</see> row where an error has occurred.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.ExtractDataDelegateEventArgs.Action">
            <summary>
            Defines how the error will be handled.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.SheetVisibility">
            <summary>
            Script positions used in <see cref="P:GemBox.Spreadsheet.ExcelWorksheet.Visibility">ExcelWorksheet.Visibility</see>.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.SheetVisibility.Visible">
            <summary>
            Sheet is visible.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.SheetVisibility.Hidden">
            <summary>
            Sheet is hidden, but is displayed in unhide dialog.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.SheetVisibility.VeryHidden">
            <summary>
            Sheet is very hidden and can be made visible only programmatically
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.SheetHeaderFooter">
            <summary>
            Represents sheet header/footer.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.SheetHeaderFooter.#ctor">
            <summary>
            SheetHeaderFooter constructor.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.SheetHeaderFooter.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:GemBox.Spreadsheet.SheetHeaderFooter">SheetHeaderFoote</see> is equal 
            to the current <see cref="T:GemBox.Spreadsheet.SheetHeaderFooter">SheetHeaderFoote</see>.
            </summary>
            <param name="obj">Object of <see cref="T:GemBox.Spreadsheet.SheetHeaderFooter">SheetHeaderFoote</see> type.</param>
            <returns><b>true</b> if the specified <see cref="T:GemBox.Spreadsheet.SheetHeaderFooter">SheetHeaderFoote</see> is equal 
            to the current <see cref="T:GemBox.Spreadsheet.SheetHeaderFooter">SheetHeaderFoote</see>; otherwise, <b>false</b>.</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.SheetHeaderFooter.GetHashCode">
            <summary>
            Returns the hash code of this object.
            </summary>
            <returns>Hash code.</returns>
        </member>
        <member name="P:GemBox.Spreadsheet.SheetHeaderFooter.AlignWithMargins">
            <summary>
            Gets or sets if header/footer margin will align with page margins.
            Supported in XLSX only.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.SheetHeaderFooter.DifferentFirst">
            <summary>
            Gets or sets if header/footer is different on the first page. 
            If true, FirstFooter and FirstHeader are on the first page.
            If false FirstFooter and FirstHeader are ignored.
            Supported in XLSX only.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.SheetHeaderFooter.DifferentOddEven">
            <summary>
            Gets or sets if there are different headers/footers on the even and odd pages.
            If true, Header/Footer and EvenHeader/EvenFooter specify page header and footer values for odd
            and even pages. 
            If false then Header/Footer is used, even when EvenHeader/EvenFooter are present.
            Supported in XLSX and ODS only.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.SheetHeaderFooter.ScaleWithDoc">
            <summary>
            Gets or sets if headers/footers will be scaled with document scaling.
            Supported in XLSX only.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.SheetHeaderFooter.EvenFooter">
            <summary>
            Gets or sets even footer.
            Supported in XLSX and ODS only.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.SheetHeaderFooter.EvenHeader">
            <summary>
            Gets or sets even header.
            Supported in XLSX and ODS only.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.SheetHeaderFooter.FirstFooter">
            <summary>
            Gets or sets first footer.
            Supported in XLSX only.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.SheetHeaderFooter.FirstHeader">
            <summary>
            Gets or sets first header.
            Supported in XLSX only.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.SheetHeaderFooter.Footer">
            <summary>
            Gets or sets default footer.
            </summary>
            <remarks>
            <p>This property is simply written to Excel file and has no effect on the behavior of this library.</p>
            <p>The header string may contain special commands, for example placeholders for the page number, 
            current date, or text formatting attributes. These fields are represented by single letters 
            (exception: font name and size) with a leading ampersand. If the ampersand is part of 
            the regular header text, it will be duplicated.</p>
            <p>For more information consult <a href="http://msdn.microsoft.com/en-us/library/dd905956.aspx">Microsoft Excel documentation</a>.</p>
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.SheetHeaderFooter.Header">
            <summary>
            Gets or sets default header.
            </summary>
            <remarks>
            <p>This property is simply written to Excel file and has no effect on the behavior of this library.</p>
            <p>The header string may contain special commands, for example placeholders for the page number, 
            current date, or text formatting attributes. These fields are represented by single letters 
            (exception: font name and size) with a leading ampersand. If the ampersand is part of 
            the regular header text, it will be duplicated.</p>
            <p>For more information consult <a href="http://msdn.microsoft.com/en-us/library/dd773041.aspx">Microsoft Excel documentation</a>.</p>
            </remarks>
        </member>
        <member name="T:GemBox.Spreadsheet.PanesState">
            <summary>
            Represents the state of the pane.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.PanesState.Frozen">
            <summary>
            Panes are frozen, but were not split being frozen. In this state, when the panes are unfrozen again, a single pane results, with no split. In this state, the split bars are not adjustable.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.PanesState.FrozenSplit">
            <summary>
            Panes are frozen and were split before being frozen. In this state, when the panes are unfrozen again, the split remains, but is adjustable.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.PanesState.Split">
            <summary>
            Panes are split, but not frozen. In this state, the split bars are adjustable by the user.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.PanePosition">
            <summary>
            Represents the position of the pane.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.PanePosition.BottomRight">
            <summary>
            Bottom right pane.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.PanePosition.TopRight">
            <summary>
            Top right pane.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.PanePosition.BottomLeft">
            <summary>
            Bottom left pane.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.PanePosition.TopLeft">
            <summary>
            Top left pane.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.WorksheetPanes">
            <summary>
            Represents the worksheet panes.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.WorksheetPanes.#ctor(GemBox.Spreadsheet.PanesState,System.Single,System.Single,System.String,GemBox.Spreadsheet.PanePosition)">
            <summary>
            Worksheet panes constructor.
            </summary>
            <param name="state">State of the panes.</param>
            <param name="xSplit">If the panes are frozen, xSplit represents the number of columns visible in the top right pane. If the panes are not frozen, xSplit represents the position of the split, in 1/20th of a point, 0 (zero) if none.</param>
            <param name="ySplit">If the panes are frozen, ySplit represents the number of rows visible in the top right pane. If the panes are not frozen, ySplit represents the position of the split, in 1/20th of a point, 0 (zero) if none.</param>
            <param name="topLeftCell">Top left visible cell in the bottom right pane.</param>
            <param name="activePane">Position of the active pane.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.WorksheetPanes.#ctor(GemBox.Spreadsheet.WorksheetPanes)">
            <summary>
            Copy constructor.
            </summary>
            <param name="sourcePane">Source pane.</param>
        </member>
        <member name="P:GemBox.Spreadsheet.WorksheetPanes.State">
            <summary>
            Gets or sets the state of the panes.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.WorksheetPanes.XSplit">
            <summary>
            Gets or sets the XSplit value.
            </summary>
            <remarks>
            If the panes are frozen, xSplit represents the number of columns visible in the top right pane. If the panes are not frozen, xSplit represents the position of the split, in 1/20th of a point, 0 (zero) if none.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.WorksheetPanes.YSplit">
            <summary>
            Gets or sets the XSplit value.
            </summary>
            <remarks>
            If the panes are frozen, ySplit represents the number of rows visible in the top right pane. If the panes are not frozen, ySplit represents the position of the split, in 1/20th of a point, 0 (zero) if none.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.WorksheetPanes.TopLeftCell">
            <summary>
            Gets or sets the top left visible cell in the bottom right pane. 
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.WorksheetPanes.ActivePane">
            <summary>
            Gets or sets the active pane.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.WorksheetProtection">
            <summary>
            Protection settings.
            Supported in XLSX only.
            </summary>
            <remarks>
            Properties in this class are simply written to Excel file and have no effect on the behavior of this library.
            For more information on worksheet protection, consult Microsoft Excel documentation.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.WorksheetProtection.PasswordHash">
            <summary>
            Gets or sets the password hash for protected sheet.
            </summary>
            <remarks>
            This property needs to be set to value of type ushort (property is of type int because ushort is not CLS compliant). 
            If you don't know which password hash corresponds to determinant password, make excel file using MS Excel, load it using GemBox.Spreadsheet, and read
            this property. Then reuse that value in your project.
            </remarks>
        </member>
        <member name="P:GemBox.Spreadsheet.WorksheetProtection.AllowSelectingLockedCells">
            <summary>
            Gets or sets if selecting locked cells is allowed.
            Default value is <b>True</b>.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.WorksheetProtection.AllowSelectingUnlockedCells">
            <summary>
            Gets or sets if selecting unlocked cells is allowed.
            Default value is <b>True</b>.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.WorksheetProtection.AllowFormattingCells">
            <summary>
            Gets or sets if formatting cells is allowed.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.WorksheetProtection.AllowFormattingColumns">
            <summary>
            Gets or sets if formatting columns is allowed.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.WorksheetProtection.AllowFormattingRows">
            <summary>
            Gets or sets if formatting rows is allowed.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.WorksheetProtection.AllowInsertingColumns">
            <summary>
            Gets or sets if inserting columns is allowed.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.WorksheetProtection.AllowInsertingRows">
            <summary>
            Gets or sets if inserting rows is allowed.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.WorksheetProtection.AllowInsertingHyperlinks">
            <summary>
            Gets or sets if inserting hyperlinks is allowed.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.WorksheetProtection.AllowDeletingColumns">
            <summary>
            Gets or sets if deleting columns is allowed.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.WorksheetProtection.AllowDeletingRows">
            <summary>
            Gets or sets if deleting rows is allowed.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.WorksheetProtection.AllowSorting">
            <summary>
            Gets or sets if sorting is allowed.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.WorksheetProtection.AllowUsingAutoFilter">
            <summary>
            Gets or sets if using autofilter is allowed.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.WorksheetProtection.AllowUsingPivotTableReports">
            <summary>
            Gets or sets if using pivot table reports is allowed.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.WorksheetProtection.AllowEditingObjects">
            <summary>
            Gets or sets if editing objects is allowed.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.WorksheetProtection.AllowEditingScenarios">
            <summary>
            Gets or sets if editing scenarios is allowed.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.ReReadApprovalCallback">
            <summary>
            Delegate for the callback by which the application gives approval for multiple
            reads of the file stream. This callback is called only when the initial 
            compression operation inflates the size of the file data. 
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.WantCompressionCallback">
            <summary>
            Delegate for the callback by which the application tells the libraary whether
            to use compression on the file or not.  
            </summary>
            <remarks>
            <para>
            Using this callback, the application can 
            specify that previously-compressed files (.mp3, .png, .docx, etc) should 
            not be compressed, for example, or can turn on or off compression based on any 
            other factor.
            </para>
            </remarks>
            <seealso cref="P:GemBox.Spreadsheet.ZipFile.WantCompression"/>
        </member>
        <member name="T:GemBox.Spreadsheet.ZipProgressEventType">
            <summary>
            In an EventArgs type, indicates which sort of progress event is being reported.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ZipProgressEventType.Reading_Started">
            <summary>
            Indicates that a Read() operation has started.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ZipProgressEventType.Reading_BeforeReadEntry">
            <summary>
            Indicates that an individual entry in the archive is about to be read.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ZipProgressEventType.Reading_AfterReadEntry">
            <summary>
            Indicates that an individual entry in the archive has just been read.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ZipProgressEventType.Reading_Completed">
            <summary>
            Indicates that a Read() operation has completed.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ZipProgressEventType.Reading_ArchiveBytesRead">
            <summary>
            The given event reports the number of bytes read so far
            during a Read() operation.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ZipProgressEventType.Saving_Started">
            <summary>
            Indicates that a Save() operation has started.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ZipProgressEventType.Saving_BeforeWriteEntry">
            <summary>
            Indicates that an individual entry in the archive is about to be written.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ZipProgressEventType.Saving_AfterWriteEntry">
            <summary>
            Indicates that an individual entry in the archive has just been saved.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ZipProgressEventType.Saving_Completed">
            <summary>
            Indicates that a Save() operation has completed.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ZipProgressEventType.Saving_AfterSaveTempArchive">
            <summary>
            Indicates that the zip archive has been created in a
            temporary location during a Save() operation.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ZipProgressEventType.Saving_BeforeRenameTempArchive">
            <summary>
            Indicates that the temporary file is about to be renamed to the final archive 
            name during a Save() operation.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ZipProgressEventType.Saving_AfterRenameTempArchive">
            <summary>
            Indicates that the temporary file is has just been renamed to the final archive 
            name during a Save() operation.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ZipProgressEventType.Saving_AfterCompileSelfExtractor">
            <summary>
            Indicates that the self-extracting archive has been compiled
            during a Save() operation.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ZipProgressEventType.Saving_EntryBytesRead">
            <summary>
            The given event is reporting the number of source bytes that have run through the compressor so far
            during a Save() operation.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ZipProgressEventType.Extracting_BeforeExtractEntry">
            <summary>
            Indicates that an entry is about to be extracted. 
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ZipProgressEventType.Extracting_AfterExtractEntry">
            <summary>
            Indicates that an entry has just been extracted. 
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ZipProgressEventType.Extracting_EntryBytesWritten">
            <summary>
            The given event is reporting the number of bytes written so far for the current entry
            during an Extract() operation.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ZipProgressEventType.Extracting_BeforeExtractAll">
            <summary>
            Indicates that an ExtractAll operation is about to begin.
            </summary>
        </member>
        <member name="F:GemBox.Spreadsheet.ZipProgressEventType.Extracting_AfterExtractAll">
            <summary>
            Indicates that an ExtractAll operation has completed.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.ZipProgressEventArgs">
            <summary>
            Provides information about the progress of a save, read, or extract operation. 
            This is a base class; you will probably use one of the classes derived from this one.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.ZipProgressEventArgs.EntriesTotal">
            <summary>
            The total number of entries to be saved or extracted.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.ZipProgressEventArgs.CurrentEntry">
            <summary>
            The name of the last entry saved or extracted.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.ZipProgressEventArgs.Cancel">
            <summary>
            In an event handler, set this to cancel the save or extract 
            operation that is in progress.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.ZipProgressEventArgs.EventType">
            <summary>
            The type of event being reported.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.ZipProgressEventArgs.ArchiveName">
            <summary>
            Returns the archive name associated to this event.
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.ZipProgressEventArgs.BytesTransferred">
            <summary>
            The number of bytes read or written so far for this entry.  
            </summary>
        </member>
        <member name="P:GemBox.Spreadsheet.ZipProgressEventArgs.TotalBytesToTransfer">
            <summary>
            Total number of bytes that will be read or written for this entry.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.ReadProgressEventArgs">
            <summary>
            Provides information about the progress of a Read operation.
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.SaveProgressEventArgs">
            <summary>
            Provides information about the progress of a save operation.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.SaveProgressEventArgs.#ctor(System.String,System.Boolean,System.Int32,System.Int32,GemBox.Spreadsheet.ZipEntry)">
            <summary>
            Constructor for the SaveProgressEventArgs.
            </summary>
            <param name="archiveName">the name of the zip archive.</param>
            <param name="before">whether this is before saving the entry, or after</param>
            <param name="entriesTotal">The total number of entries in the zip archive.</param>
            <param name="entriesSaved">Number of entries that have been saved.</param>
            <param name="entry">The entry involved in the event.</param>
        </member>
        <member name="T:GemBox.Spreadsheet.ExtractProgressEventArgs">
            <summary>
            Provides information about the progress of the extract operation.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.MsofbtSpgrRecord.Read(System.IO.BinaryReader)">
            <summary>
            Reads data from the specified reader.
            </summary>
            <param name="reader">The source binary reader.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.MsofbtSpgrRecord.SetData(GemBox.Spreadsheet.MsoDelayedRecords)">
            <summary>
            Sets the inner data( mso structure' data without header: atom, type, length ).
            </summary>
        </member>
        <member name="T:GemBox.Spreadsheet.ErrFormulaToken">
            <summary>
            Formula token for holding error value.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.ErrFormulaToken.#cctor">
            <summary>
            Initializes the <see cref="T:GemBox.Spreadsheet.ErrFormulaToken"/> class.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.ErrFormulaToken.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:GemBox.Spreadsheet.ErrFormulaToken"/> class.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.ErrFormulaToken.DelayInitialize(System.Object[])">
            <summary>
            Make custom delay initialize.
            </summary>
            <param name="data">The data for initialization which is unique for each formula token.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ErrFormulaToken.Read(System.Byte[],System.Int32)">
            <summary>
            Initialize formula token by reading input data from array of bytes
            </summary>
            <param name="rpnBytes">input data, array of bytes</param>
            <param name="startIndex">start position for array of bytes to read from</param>
        </member>
        <member name="M:GemBox.Spreadsheet.ErrFormulaToken.ConvertToBytes">
            <summary>
            Convert formula token to array of byte representation.
            </summary>
            <returns>formula token' array of byte representation</returns>
        </member>
        <member name="M:GemBox.Spreadsheet.ErrFormulaToken.ToString">
            <summary>
            Convert formula token to string representation.
            </summary>
            <returns>formula token string representation</returns>
        </member>
        <member name="P:GemBox.Spreadsheet.CmoObjSubRecord.ID">
            <summary>
            Object's id.
            </summary>
        </member>
        <member name="M:GemBox.Spreadsheet.UnknownObjSubRecord.Read(System.Byte[])">
            <summary>
            Reads bye array.
            </summary>
            <param name="buffer">Array to Read.</param>
        </member>
        <member name="M:GemBox.Spreadsheet.UnknownObjSubRecord.ConvertToBytes">
            <summary>
            Returns binary representation of the subrecord.
            </summary>
            <returns>Binary representation of the subrecord.</returns>
        </member>
    </members>
</doc>
